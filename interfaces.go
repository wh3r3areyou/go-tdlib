// AUTOGENERATED - DO NOT EDIT

package tdlib

import (
	"encoding/json"
	"fmt"
)

// AuthenticationCodeType Provides information about the method by which an authentication code is delivered to the user
type AuthenticationCodeType interface {
	GetAuthenticationCodeTypeEnum() AuthenticationCodeTypeEnum
}

// AuthenticationCodeTypeEnum Alias for abstract AuthenticationCodeType 'Sub-Classes', used as constant-enum here
type AuthenticationCodeTypeEnum string

// AuthenticationCodeType enums
const (
	AuthenticationCodeTypeTelegramMessageType AuthenticationCodeTypeEnum = "authenticationCodeTypeTelegramMessage"
	AuthenticationCodeTypeSmsType             AuthenticationCodeTypeEnum = "authenticationCodeTypeSms"
	AuthenticationCodeTypeCallType            AuthenticationCodeTypeEnum = "authenticationCodeTypeCall"
	AuthenticationCodeTypeFlashCallType       AuthenticationCodeTypeEnum = "authenticationCodeTypeFlashCall"
	AuthenticationCodeTypeMissedCallType      AuthenticationCodeTypeEnum = "authenticationCodeTypeMissedCall"
)

func unmarshalAuthenticationCodeType(rawMsg *json.RawMessage) (AuthenticationCodeType, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch AuthenticationCodeTypeEnum(objMap["@type"].(string)) {
	case AuthenticationCodeTypeTelegramMessageType:
		var authenticationCodeTypeTelegramMessage AuthenticationCodeTypeTelegramMessage
		err := json.Unmarshal(*rawMsg, &authenticationCodeTypeTelegramMessage)
		return &authenticationCodeTypeTelegramMessage, err

	case AuthenticationCodeTypeSmsType:
		var authenticationCodeTypeSms AuthenticationCodeTypeSms
		err := json.Unmarshal(*rawMsg, &authenticationCodeTypeSms)
		return &authenticationCodeTypeSms, err

	case AuthenticationCodeTypeCallType:
		var authenticationCodeTypeCall AuthenticationCodeTypeCall
		err := json.Unmarshal(*rawMsg, &authenticationCodeTypeCall)
		return &authenticationCodeTypeCall, err

	case AuthenticationCodeTypeFlashCallType:
		var authenticationCodeTypeFlashCall AuthenticationCodeTypeFlashCall
		err := json.Unmarshal(*rawMsg, &authenticationCodeTypeFlashCall)
		return &authenticationCodeTypeFlashCall, err

	case AuthenticationCodeTypeMissedCallType:
		var authenticationCodeTypeMissedCall AuthenticationCodeTypeMissedCall
		err := json.Unmarshal(*rawMsg, &authenticationCodeTypeMissedCall)
		return &authenticationCodeTypeMissedCall, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalAuthenticationCodeTypeSlice(rawMsg *json.RawMessage) ([]AuthenticationCodeType, error) {
	objects := make([]AuthenticationCodeType, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch AuthenticationCodeTypeEnum(objMap["@type"].(string)) {
		case AuthenticationCodeTypeTelegramMessageType:
			var authenticationCodeTypeTelegramMessage AuthenticationCodeTypeTelegramMessage
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &authenticationCodeTypeTelegramMessage)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &authenticationCodeTypeTelegramMessage)
		case AuthenticationCodeTypeSmsType:
			var authenticationCodeTypeSms AuthenticationCodeTypeSms
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &authenticationCodeTypeSms)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &authenticationCodeTypeSms)
		case AuthenticationCodeTypeCallType:
			var authenticationCodeTypeCall AuthenticationCodeTypeCall
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &authenticationCodeTypeCall)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &authenticationCodeTypeCall)
		case AuthenticationCodeTypeFlashCallType:
			var authenticationCodeTypeFlashCall AuthenticationCodeTypeFlashCall
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &authenticationCodeTypeFlashCall)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &authenticationCodeTypeFlashCall)
		case AuthenticationCodeTypeMissedCallType:
			var authenticationCodeTypeMissedCall AuthenticationCodeTypeMissedCall
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &authenticationCodeTypeMissedCall)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &authenticationCodeTypeMissedCall)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// AuthorizationState Represents the current authorization state of the TDLib client
type AuthorizationState interface {
	GetAuthorizationStateEnum() AuthorizationStateEnum
}

// AuthorizationStateEnum Alias for abstract AuthorizationState 'Sub-Classes', used as constant-enum here
type AuthorizationStateEnum string

// AuthorizationState enums
const (
	AuthorizationStateWaitTdlibParametersType         AuthorizationStateEnum = "authorizationStateWaitTdlibParameters"
	AuthorizationStateWaitEncryptionKeyType           AuthorizationStateEnum = "authorizationStateWaitEncryptionKey"
	AuthorizationStateWaitPhoneNumberType             AuthorizationStateEnum = "authorizationStateWaitPhoneNumber"
	AuthorizationStateWaitCodeType                    AuthorizationStateEnum = "authorizationStateWaitCode"
	AuthorizationStateWaitOtherDeviceConfirmationType AuthorizationStateEnum = "authorizationStateWaitOtherDeviceConfirmation"
	AuthorizationStateWaitRegistrationType            AuthorizationStateEnum = "authorizationStateWaitRegistration"
	AuthorizationStateWaitPasswordType                AuthorizationStateEnum = "authorizationStateWaitPassword"
	AuthorizationStateReadyType                       AuthorizationStateEnum = "authorizationStateReady"
	AuthorizationStateLoggingOutType                  AuthorizationStateEnum = "authorizationStateLoggingOut"
	AuthorizationStateClosingType                     AuthorizationStateEnum = "authorizationStateClosing"
	AuthorizationStateClosedType                      AuthorizationStateEnum = "authorizationStateClosed"
)

func unmarshalAuthorizationState(rawMsg *json.RawMessage) (AuthorizationState, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch AuthorizationStateEnum(objMap["@type"].(string)) {
	case AuthorizationStateWaitTdlibParametersType:
		var authorizationStateWaitTdlibParameters AuthorizationStateWaitTdlibParameters
		err := json.Unmarshal(*rawMsg, &authorizationStateWaitTdlibParameters)
		return &authorizationStateWaitTdlibParameters, err

	case AuthorizationStateWaitEncryptionKeyType:
		var authorizationStateWaitEncryptionKey AuthorizationStateWaitEncryptionKey
		err := json.Unmarshal(*rawMsg, &authorizationStateWaitEncryptionKey)
		return &authorizationStateWaitEncryptionKey, err

	case AuthorizationStateWaitPhoneNumberType:
		var authorizationStateWaitPhoneNumber AuthorizationStateWaitPhoneNumber
		err := json.Unmarshal(*rawMsg, &authorizationStateWaitPhoneNumber)
		return &authorizationStateWaitPhoneNumber, err

	case AuthorizationStateWaitCodeType:
		var authorizationStateWaitCode AuthorizationStateWaitCode
		err := json.Unmarshal(*rawMsg, &authorizationStateWaitCode)
		return &authorizationStateWaitCode, err

	case AuthorizationStateWaitOtherDeviceConfirmationType:
		var authorizationStateWaitOtherDeviceConfirmation AuthorizationStateWaitOtherDeviceConfirmation
		err := json.Unmarshal(*rawMsg, &authorizationStateWaitOtherDeviceConfirmation)
		return &authorizationStateWaitOtherDeviceConfirmation, err

	case AuthorizationStateWaitRegistrationType:
		var authorizationStateWaitRegistration AuthorizationStateWaitRegistration
		err := json.Unmarshal(*rawMsg, &authorizationStateWaitRegistration)
		return &authorizationStateWaitRegistration, err

	case AuthorizationStateWaitPasswordType:
		var authorizationStateWaitPassword AuthorizationStateWaitPassword
		err := json.Unmarshal(*rawMsg, &authorizationStateWaitPassword)
		return &authorizationStateWaitPassword, err

	case AuthorizationStateReadyType:
		var authorizationStateReady AuthorizationStateReady
		err := json.Unmarshal(*rawMsg, &authorizationStateReady)
		return &authorizationStateReady, err

	case AuthorizationStateLoggingOutType:
		var authorizationStateLoggingOut AuthorizationStateLoggingOut
		err := json.Unmarshal(*rawMsg, &authorizationStateLoggingOut)
		return &authorizationStateLoggingOut, err

	case AuthorizationStateClosingType:
		var authorizationStateClosing AuthorizationStateClosing
		err := json.Unmarshal(*rawMsg, &authorizationStateClosing)
		return &authorizationStateClosing, err

	case AuthorizationStateClosedType:
		var authorizationStateClosed AuthorizationStateClosed
		err := json.Unmarshal(*rawMsg, &authorizationStateClosed)
		return &authorizationStateClosed, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalAuthorizationStateSlice(rawMsg *json.RawMessage) ([]AuthorizationState, error) {
	objects := make([]AuthorizationState, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch AuthorizationStateEnum(objMap["@type"].(string)) {
		case AuthorizationStateWaitTdlibParametersType:
			var authorizationStateWaitTdlibParameters AuthorizationStateWaitTdlibParameters
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &authorizationStateWaitTdlibParameters)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &authorizationStateWaitTdlibParameters)
		case AuthorizationStateWaitEncryptionKeyType:
			var authorizationStateWaitEncryptionKey AuthorizationStateWaitEncryptionKey
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &authorizationStateWaitEncryptionKey)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &authorizationStateWaitEncryptionKey)
		case AuthorizationStateWaitPhoneNumberType:
			var authorizationStateWaitPhoneNumber AuthorizationStateWaitPhoneNumber
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &authorizationStateWaitPhoneNumber)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &authorizationStateWaitPhoneNumber)
		case AuthorizationStateWaitCodeType:
			var authorizationStateWaitCode AuthorizationStateWaitCode
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &authorizationStateWaitCode)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &authorizationStateWaitCode)
		case AuthorizationStateWaitOtherDeviceConfirmationType:
			var authorizationStateWaitOtherDeviceConfirmation AuthorizationStateWaitOtherDeviceConfirmation
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &authorizationStateWaitOtherDeviceConfirmation)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &authorizationStateWaitOtherDeviceConfirmation)
		case AuthorizationStateWaitRegistrationType:
			var authorizationStateWaitRegistration AuthorizationStateWaitRegistration
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &authorizationStateWaitRegistration)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &authorizationStateWaitRegistration)
		case AuthorizationStateWaitPasswordType:
			var authorizationStateWaitPassword AuthorizationStateWaitPassword
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &authorizationStateWaitPassword)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &authorizationStateWaitPassword)
		case AuthorizationStateReadyType:
			var authorizationStateReady AuthorizationStateReady
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &authorizationStateReady)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &authorizationStateReady)
		case AuthorizationStateLoggingOutType:
			var authorizationStateLoggingOut AuthorizationStateLoggingOut
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &authorizationStateLoggingOut)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &authorizationStateLoggingOut)
		case AuthorizationStateClosingType:
			var authorizationStateClosing AuthorizationStateClosing
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &authorizationStateClosing)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &authorizationStateClosing)
		case AuthorizationStateClosedType:
			var authorizationStateClosed AuthorizationStateClosed
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &authorizationStateClosed)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &authorizationStateClosed)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// InputFile Points to a file
type InputFile interface {
	GetInputFileEnum() InputFileEnum
}

// InputFileEnum Alias for abstract InputFile 'Sub-Classes', used as constant-enum here
type InputFileEnum string

// InputFile enums
const (
	InputFileIDType        InputFileEnum = "inputFileId"
	InputFileRemoteType    InputFileEnum = "inputFileRemote"
	InputFileLocalType     InputFileEnum = "inputFileLocal"
	InputFileGeneratedType InputFileEnum = "inputFileGenerated"
)

func unmarshalInputFile(rawMsg *json.RawMessage) (InputFile, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch InputFileEnum(objMap["@type"].(string)) {
	case InputFileIDType:
		var inputFileID InputFileID
		err := json.Unmarshal(*rawMsg, &inputFileID)
		return &inputFileID, err

	case InputFileRemoteType:
		var inputFileRemote InputFileRemote
		err := json.Unmarshal(*rawMsg, &inputFileRemote)
		return &inputFileRemote, err

	case InputFileLocalType:
		var inputFileLocal InputFileLocal
		err := json.Unmarshal(*rawMsg, &inputFileLocal)
		return &inputFileLocal, err

	case InputFileGeneratedType:
		var inputFileGenerated InputFileGenerated
		err := json.Unmarshal(*rawMsg, &inputFileGenerated)
		return &inputFileGenerated, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalInputFileSlice(rawMsg *json.RawMessage) ([]InputFile, error) {
	objects := make([]InputFile, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch InputFileEnum(objMap["@type"].(string)) {
		case InputFileIDType:
			var inputFileID InputFileID
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputFileID)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputFileID)
		case InputFileRemoteType:
			var inputFileRemote InputFileRemote
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputFileRemote)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputFileRemote)
		case InputFileLocalType:
			var inputFileLocal InputFileLocal
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputFileLocal)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputFileLocal)
		case InputFileGeneratedType:
			var inputFileGenerated InputFileGenerated
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputFileGenerated)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputFileGenerated)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// ThumbnailFormat Describes format of the thumbnail
type ThumbnailFormat interface {
	GetThumbnailFormatEnum() ThumbnailFormatEnum
}

// ThumbnailFormatEnum Alias for abstract ThumbnailFormat 'Sub-Classes', used as constant-enum here
type ThumbnailFormatEnum string

// ThumbnailFormat enums
const (
	ThumbnailFormatJpegType  ThumbnailFormatEnum = "thumbnailFormatJpeg"
	ThumbnailFormatPngType   ThumbnailFormatEnum = "thumbnailFormatPng"
	ThumbnailFormatWebpType  ThumbnailFormatEnum = "thumbnailFormatWebp"
	ThumbnailFormatGifType   ThumbnailFormatEnum = "thumbnailFormatGif"
	ThumbnailFormatTgsType   ThumbnailFormatEnum = "thumbnailFormatTgs"
	ThumbnailFormatMpeg4Type ThumbnailFormatEnum = "thumbnailFormatMpeg4"
)

func unmarshalThumbnailFormat(rawMsg *json.RawMessage) (ThumbnailFormat, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch ThumbnailFormatEnum(objMap["@type"].(string)) {
	case ThumbnailFormatJpegType:
		var thumbnailFormatJpeg ThumbnailFormatJpeg
		err := json.Unmarshal(*rawMsg, &thumbnailFormatJpeg)
		return &thumbnailFormatJpeg, err

	case ThumbnailFormatPngType:
		var thumbnailFormatPng ThumbnailFormatPng
		err := json.Unmarshal(*rawMsg, &thumbnailFormatPng)
		return &thumbnailFormatPng, err

	case ThumbnailFormatWebpType:
		var thumbnailFormatWebp ThumbnailFormatWebp
		err := json.Unmarshal(*rawMsg, &thumbnailFormatWebp)
		return &thumbnailFormatWebp, err

	case ThumbnailFormatGifType:
		var thumbnailFormatGif ThumbnailFormatGif
		err := json.Unmarshal(*rawMsg, &thumbnailFormatGif)
		return &thumbnailFormatGif, err

	case ThumbnailFormatTgsType:
		var thumbnailFormatTgs ThumbnailFormatTgs
		err := json.Unmarshal(*rawMsg, &thumbnailFormatTgs)
		return &thumbnailFormatTgs, err

	case ThumbnailFormatMpeg4Type:
		var thumbnailFormatMpeg4 ThumbnailFormatMpeg4
		err := json.Unmarshal(*rawMsg, &thumbnailFormatMpeg4)
		return &thumbnailFormatMpeg4, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalThumbnailFormatSlice(rawMsg *json.RawMessage) ([]ThumbnailFormat, error) {
	objects := make([]ThumbnailFormat, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch ThumbnailFormatEnum(objMap["@type"].(string)) {
		case ThumbnailFormatJpegType:
			var thumbnailFormatJpeg ThumbnailFormatJpeg
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &thumbnailFormatJpeg)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &thumbnailFormatJpeg)
		case ThumbnailFormatPngType:
			var thumbnailFormatPng ThumbnailFormatPng
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &thumbnailFormatPng)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &thumbnailFormatPng)
		case ThumbnailFormatWebpType:
			var thumbnailFormatWebp ThumbnailFormatWebp
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &thumbnailFormatWebp)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &thumbnailFormatWebp)
		case ThumbnailFormatGifType:
			var thumbnailFormatGif ThumbnailFormatGif
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &thumbnailFormatGif)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &thumbnailFormatGif)
		case ThumbnailFormatTgsType:
			var thumbnailFormatTgs ThumbnailFormatTgs
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &thumbnailFormatTgs)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &thumbnailFormatTgs)
		case ThumbnailFormatMpeg4Type:
			var thumbnailFormatMpeg4 ThumbnailFormatMpeg4
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &thumbnailFormatMpeg4)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &thumbnailFormatMpeg4)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// MaskPoint Part of the face, relative to which a mask is placed
type MaskPoint interface {
	GetMaskPointEnum() MaskPointEnum
}

// MaskPointEnum Alias for abstract MaskPoint 'Sub-Classes', used as constant-enum here
type MaskPointEnum string

// MaskPoint enums
const (
	MaskPointForeheadType MaskPointEnum = "maskPointForehead"
	MaskPointEyesType     MaskPointEnum = "maskPointEyes"
	MaskPointMouthType    MaskPointEnum = "maskPointMouth"
	MaskPointChinType     MaskPointEnum = "maskPointChin"
)

func unmarshalMaskPoint(rawMsg *json.RawMessage) (MaskPoint, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch MaskPointEnum(objMap["@type"].(string)) {
	case MaskPointForeheadType:
		var maskPointForehead MaskPointForehead
		err := json.Unmarshal(*rawMsg, &maskPointForehead)
		return &maskPointForehead, err

	case MaskPointEyesType:
		var maskPointEyes MaskPointEyes
		err := json.Unmarshal(*rawMsg, &maskPointEyes)
		return &maskPointEyes, err

	case MaskPointMouthType:
		var maskPointMouth MaskPointMouth
		err := json.Unmarshal(*rawMsg, &maskPointMouth)
		return &maskPointMouth, err

	case MaskPointChinType:
		var maskPointChin MaskPointChin
		err := json.Unmarshal(*rawMsg, &maskPointChin)
		return &maskPointChin, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalMaskPointSlice(rawMsg *json.RawMessage) ([]MaskPoint, error) {
	objects := make([]MaskPoint, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch MaskPointEnum(objMap["@type"].(string)) {
		case MaskPointForeheadType:
			var maskPointForehead MaskPointForehead
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &maskPointForehead)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &maskPointForehead)
		case MaskPointEyesType:
			var maskPointEyes MaskPointEyes
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &maskPointEyes)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &maskPointEyes)
		case MaskPointMouthType:
			var maskPointMouth MaskPointMouth
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &maskPointMouth)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &maskPointMouth)
		case MaskPointChinType:
			var maskPointChin MaskPointChin
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &maskPointChin)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &maskPointChin)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// PollType Describes the type of a poll
type PollType interface {
	GetPollTypeEnum() PollTypeEnum
}

// PollTypeEnum Alias for abstract PollType 'Sub-Classes', used as constant-enum here
type PollTypeEnum string

// PollType enums
const (
	PollTypeRegularType PollTypeEnum = "pollTypeRegular"
	PollTypeQuizType    PollTypeEnum = "pollTypeQuiz"
)

func unmarshalPollType(rawMsg *json.RawMessage) (PollType, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch PollTypeEnum(objMap["@type"].(string)) {
	case PollTypeRegularType:
		var pollTypeRegular PollTypeRegular
		err := json.Unmarshal(*rawMsg, &pollTypeRegular)
		return &pollTypeRegular, err

	case PollTypeQuizType:
		var pollTypeQuiz PollTypeQuiz
		err := json.Unmarshal(*rawMsg, &pollTypeQuiz)
		return &pollTypeQuiz, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalPollTypeSlice(rawMsg *json.RawMessage) ([]PollType, error) {
	objects := make([]PollType, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch PollTypeEnum(objMap["@type"].(string)) {
		case PollTypeRegularType:
			var pollTypeRegular PollTypeRegular
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pollTypeRegular)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pollTypeRegular)
		case PollTypeQuizType:
			var pollTypeQuiz PollTypeQuiz
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pollTypeQuiz)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pollTypeQuiz)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// UserType Represents the type of a user. The following types are possible: regular users, deleted users and bots
type UserType interface {
	GetUserTypeEnum() UserTypeEnum
}

// UserTypeEnum Alias for abstract UserType 'Sub-Classes', used as constant-enum here
type UserTypeEnum string

// UserType enums
const (
	UserTypeRegularType UserTypeEnum = "userTypeRegular"
	UserTypeDeletedType UserTypeEnum = "userTypeDeleted"
	UserTypeBotType     UserTypeEnum = "userTypeBot"
	UserTypeUnknownType UserTypeEnum = "userTypeUnknown"
)

func unmarshalUserType(rawMsg *json.RawMessage) (UserType, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch UserTypeEnum(objMap["@type"].(string)) {
	case UserTypeRegularType:
		var userTypeRegular UserTypeRegular
		err := json.Unmarshal(*rawMsg, &userTypeRegular)
		return &userTypeRegular, err

	case UserTypeDeletedType:
		var userTypeDeleted UserTypeDeleted
		err := json.Unmarshal(*rawMsg, &userTypeDeleted)
		return &userTypeDeleted, err

	case UserTypeBotType:
		var userTypeBot UserTypeBot
		err := json.Unmarshal(*rawMsg, &userTypeBot)
		return &userTypeBot, err

	case UserTypeUnknownType:
		var userTypeUnknown UserTypeUnknown
		err := json.Unmarshal(*rawMsg, &userTypeUnknown)
		return &userTypeUnknown, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalUserTypeSlice(rawMsg *json.RawMessage) ([]UserType, error) {
	objects := make([]UserType, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch UserTypeEnum(objMap["@type"].(string)) {
		case UserTypeRegularType:
			var userTypeRegular UserTypeRegular
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &userTypeRegular)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &userTypeRegular)
		case UserTypeDeletedType:
			var userTypeDeleted UserTypeDeleted
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &userTypeDeleted)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &userTypeDeleted)
		case UserTypeBotType:
			var userTypeBot UserTypeBot
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &userTypeBot)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &userTypeBot)
		case UserTypeUnknownType:
			var userTypeUnknown UserTypeUnknown
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &userTypeUnknown)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &userTypeUnknown)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// InputChatPhoto Describes a photo to be set as a user profile or chat photo
type InputChatPhoto interface {
	GetInputChatPhotoEnum() InputChatPhotoEnum
}

// InputChatPhotoEnum Alias for abstract InputChatPhoto 'Sub-Classes', used as constant-enum here
type InputChatPhotoEnum string

// InputChatPhoto enums
const (
	InputChatPhotoPreviousType  InputChatPhotoEnum = "inputChatPhotoPrevious"
	InputChatPhotoStaticType    InputChatPhotoEnum = "inputChatPhotoStatic"
	InputChatPhotoAnimationType InputChatPhotoEnum = "inputChatPhotoAnimation"
)

func unmarshalInputChatPhoto(rawMsg *json.RawMessage) (InputChatPhoto, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch InputChatPhotoEnum(objMap["@type"].(string)) {
	case InputChatPhotoPreviousType:
		var inputChatPhotoPrevious InputChatPhotoPrevious
		err := json.Unmarshal(*rawMsg, &inputChatPhotoPrevious)
		return &inputChatPhotoPrevious, err

	case InputChatPhotoStaticType:
		var inputChatPhotoStatic InputChatPhotoStatic
		err := json.Unmarshal(*rawMsg, &inputChatPhotoStatic)
		return &inputChatPhotoStatic, err

	case InputChatPhotoAnimationType:
		var inputChatPhotoAnimation InputChatPhotoAnimation
		err := json.Unmarshal(*rawMsg, &inputChatPhotoAnimation)
		return &inputChatPhotoAnimation, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalInputChatPhotoSlice(rawMsg *json.RawMessage) ([]InputChatPhoto, error) {
	objects := make([]InputChatPhoto, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch InputChatPhotoEnum(objMap["@type"].(string)) {
		case InputChatPhotoPreviousType:
			var inputChatPhotoPrevious InputChatPhotoPrevious
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputChatPhotoPrevious)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputChatPhotoPrevious)
		case InputChatPhotoStaticType:
			var inputChatPhotoStatic InputChatPhotoStatic
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputChatPhotoStatic)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputChatPhotoStatic)
		case InputChatPhotoAnimationType:
			var inputChatPhotoAnimation InputChatPhotoAnimation
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputChatPhotoAnimation)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputChatPhotoAnimation)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// ChatMemberStatus Provides information about the status of a member in a chat
type ChatMemberStatus interface {
	GetChatMemberStatusEnum() ChatMemberStatusEnum
}

// ChatMemberStatusEnum Alias for abstract ChatMemberStatus 'Sub-Classes', used as constant-enum here
type ChatMemberStatusEnum string

// ChatMemberStatus enums
const (
	ChatMemberStatusCreatorType       ChatMemberStatusEnum = "chatMemberStatusCreator"
	ChatMemberStatusAdministratorType ChatMemberStatusEnum = "chatMemberStatusAdministrator"
	ChatMemberStatusMemberType        ChatMemberStatusEnum = "chatMemberStatusMember"
	ChatMemberStatusRestrictedType    ChatMemberStatusEnum = "chatMemberStatusRestricted"
	ChatMemberStatusLeftType          ChatMemberStatusEnum = "chatMemberStatusLeft"
	ChatMemberStatusBannedType        ChatMemberStatusEnum = "chatMemberStatusBanned"
)

func unmarshalChatMemberStatus(rawMsg *json.RawMessage) (ChatMemberStatus, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch ChatMemberStatusEnum(objMap["@type"].(string)) {
	case ChatMemberStatusCreatorType:
		var chatMemberStatusCreator ChatMemberStatusCreator
		err := json.Unmarshal(*rawMsg, &chatMemberStatusCreator)
		return &chatMemberStatusCreator, err

	case ChatMemberStatusAdministratorType:
		var chatMemberStatusAdministrator ChatMemberStatusAdministrator
		err := json.Unmarshal(*rawMsg, &chatMemberStatusAdministrator)
		return &chatMemberStatusAdministrator, err

	case ChatMemberStatusMemberType:
		var chatMemberStatusMember ChatMemberStatusMember
		err := json.Unmarshal(*rawMsg, &chatMemberStatusMember)
		return &chatMemberStatusMember, err

	case ChatMemberStatusRestrictedType:
		var chatMemberStatusRestricted ChatMemberStatusRestricted
		err := json.Unmarshal(*rawMsg, &chatMemberStatusRestricted)
		return &chatMemberStatusRestricted, err

	case ChatMemberStatusLeftType:
		var chatMemberStatusLeft ChatMemberStatusLeft
		err := json.Unmarshal(*rawMsg, &chatMemberStatusLeft)
		return &chatMemberStatusLeft, err

	case ChatMemberStatusBannedType:
		var chatMemberStatusBanned ChatMemberStatusBanned
		err := json.Unmarshal(*rawMsg, &chatMemberStatusBanned)
		return &chatMemberStatusBanned, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalChatMemberStatusSlice(rawMsg *json.RawMessage) ([]ChatMemberStatus, error) {
	objects := make([]ChatMemberStatus, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch ChatMemberStatusEnum(objMap["@type"].(string)) {
		case ChatMemberStatusCreatorType:
			var chatMemberStatusCreator ChatMemberStatusCreator
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatMemberStatusCreator)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatMemberStatusCreator)
		case ChatMemberStatusAdministratorType:
			var chatMemberStatusAdministrator ChatMemberStatusAdministrator
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatMemberStatusAdministrator)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatMemberStatusAdministrator)
		case ChatMemberStatusMemberType:
			var chatMemberStatusMember ChatMemberStatusMember
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatMemberStatusMember)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatMemberStatusMember)
		case ChatMemberStatusRestrictedType:
			var chatMemberStatusRestricted ChatMemberStatusRestricted
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatMemberStatusRestricted)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatMemberStatusRestricted)
		case ChatMemberStatusLeftType:
			var chatMemberStatusLeft ChatMemberStatusLeft
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatMemberStatusLeft)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatMemberStatusLeft)
		case ChatMemberStatusBannedType:
			var chatMemberStatusBanned ChatMemberStatusBanned
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatMemberStatusBanned)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatMemberStatusBanned)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// ChatMembersFilter Specifies the kind of chat members to return in searchChatMembers
type ChatMembersFilter interface {
	GetChatMembersFilterEnum() ChatMembersFilterEnum
}

// ChatMembersFilterEnum Alias for abstract ChatMembersFilter 'Sub-Classes', used as constant-enum here
type ChatMembersFilterEnum string

// ChatMembersFilter enums
const (
	ChatMembersFilterContactsType       ChatMembersFilterEnum = "chatMembersFilterContacts"
	ChatMembersFilterAdministratorsType ChatMembersFilterEnum = "chatMembersFilterAdministrators"
	ChatMembersFilterMembersType        ChatMembersFilterEnum = "chatMembersFilterMembers"
	ChatMembersFilterMentionType        ChatMembersFilterEnum = "chatMembersFilterMention"
	ChatMembersFilterRestrictedType     ChatMembersFilterEnum = "chatMembersFilterRestricted"
	ChatMembersFilterBannedType         ChatMembersFilterEnum = "chatMembersFilterBanned"
	ChatMembersFilterBotsType           ChatMembersFilterEnum = "chatMembersFilterBots"
)

func unmarshalChatMembersFilter(rawMsg *json.RawMessage) (ChatMembersFilter, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch ChatMembersFilterEnum(objMap["@type"].(string)) {
	case ChatMembersFilterContactsType:
		var chatMembersFilterContacts ChatMembersFilterContacts
		err := json.Unmarshal(*rawMsg, &chatMembersFilterContacts)
		return &chatMembersFilterContacts, err

	case ChatMembersFilterAdministratorsType:
		var chatMembersFilterAdministrators ChatMembersFilterAdministrators
		err := json.Unmarshal(*rawMsg, &chatMembersFilterAdministrators)
		return &chatMembersFilterAdministrators, err

	case ChatMembersFilterMembersType:
		var chatMembersFilterMembers ChatMembersFilterMembers
		err := json.Unmarshal(*rawMsg, &chatMembersFilterMembers)
		return &chatMembersFilterMembers, err

	case ChatMembersFilterMentionType:
		var chatMembersFilterMention ChatMembersFilterMention
		err := json.Unmarshal(*rawMsg, &chatMembersFilterMention)
		return &chatMembersFilterMention, err

	case ChatMembersFilterRestrictedType:
		var chatMembersFilterRestricted ChatMembersFilterRestricted
		err := json.Unmarshal(*rawMsg, &chatMembersFilterRestricted)
		return &chatMembersFilterRestricted, err

	case ChatMembersFilterBannedType:
		var chatMembersFilterBanned ChatMembersFilterBanned
		err := json.Unmarshal(*rawMsg, &chatMembersFilterBanned)
		return &chatMembersFilterBanned, err

	case ChatMembersFilterBotsType:
		var chatMembersFilterBots ChatMembersFilterBots
		err := json.Unmarshal(*rawMsg, &chatMembersFilterBots)
		return &chatMembersFilterBots, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalChatMembersFilterSlice(rawMsg *json.RawMessage) ([]ChatMembersFilter, error) {
	objects := make([]ChatMembersFilter, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch ChatMembersFilterEnum(objMap["@type"].(string)) {
		case ChatMembersFilterContactsType:
			var chatMembersFilterContacts ChatMembersFilterContacts
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatMembersFilterContacts)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatMembersFilterContacts)
		case ChatMembersFilterAdministratorsType:
			var chatMembersFilterAdministrators ChatMembersFilterAdministrators
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatMembersFilterAdministrators)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatMembersFilterAdministrators)
		case ChatMembersFilterMembersType:
			var chatMembersFilterMembers ChatMembersFilterMembers
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatMembersFilterMembers)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatMembersFilterMembers)
		case ChatMembersFilterMentionType:
			var chatMembersFilterMention ChatMembersFilterMention
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatMembersFilterMention)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatMembersFilterMention)
		case ChatMembersFilterRestrictedType:
			var chatMembersFilterRestricted ChatMembersFilterRestricted
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatMembersFilterRestricted)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatMembersFilterRestricted)
		case ChatMembersFilterBannedType:
			var chatMembersFilterBanned ChatMembersFilterBanned
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatMembersFilterBanned)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatMembersFilterBanned)
		case ChatMembersFilterBotsType:
			var chatMembersFilterBots ChatMembersFilterBots
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatMembersFilterBots)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatMembersFilterBots)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// SupergroupMembersFilter Specifies the kind of chat members to return in getSupergroupMembers
type SupergroupMembersFilter interface {
	GetSupergroupMembersFilterEnum() SupergroupMembersFilterEnum
}

// SupergroupMembersFilterEnum Alias for abstract SupergroupMembersFilter 'Sub-Classes', used as constant-enum here
type SupergroupMembersFilterEnum string

// SupergroupMembersFilter enums
const (
	SupergroupMembersFilterRecentType         SupergroupMembersFilterEnum = "supergroupMembersFilterRecent"
	SupergroupMembersFilterContactsType       SupergroupMembersFilterEnum = "supergroupMembersFilterContacts"
	SupergroupMembersFilterAdministratorsType SupergroupMembersFilterEnum = "supergroupMembersFilterAdministrators"
	SupergroupMembersFilterSearchType         SupergroupMembersFilterEnum = "supergroupMembersFilterSearch"
	SupergroupMembersFilterRestrictedType     SupergroupMembersFilterEnum = "supergroupMembersFilterRestricted"
	SupergroupMembersFilterBannedType         SupergroupMembersFilterEnum = "supergroupMembersFilterBanned"
	SupergroupMembersFilterMentionType        SupergroupMembersFilterEnum = "supergroupMembersFilterMention"
	SupergroupMembersFilterBotsType           SupergroupMembersFilterEnum = "supergroupMembersFilterBots"
)

func unmarshalSupergroupMembersFilter(rawMsg *json.RawMessage) (SupergroupMembersFilter, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch SupergroupMembersFilterEnum(objMap["@type"].(string)) {
	case SupergroupMembersFilterRecentType:
		var supergroupMembersFilterRecent SupergroupMembersFilterRecent
		err := json.Unmarshal(*rawMsg, &supergroupMembersFilterRecent)
		return &supergroupMembersFilterRecent, err

	case SupergroupMembersFilterContactsType:
		var supergroupMembersFilterContacts SupergroupMembersFilterContacts
		err := json.Unmarshal(*rawMsg, &supergroupMembersFilterContacts)
		return &supergroupMembersFilterContacts, err

	case SupergroupMembersFilterAdministratorsType:
		var supergroupMembersFilterAdministrators SupergroupMembersFilterAdministrators
		err := json.Unmarshal(*rawMsg, &supergroupMembersFilterAdministrators)
		return &supergroupMembersFilterAdministrators, err

	case SupergroupMembersFilterSearchType:
		var supergroupMembersFilterSearch SupergroupMembersFilterSearch
		err := json.Unmarshal(*rawMsg, &supergroupMembersFilterSearch)
		return &supergroupMembersFilterSearch, err

	case SupergroupMembersFilterRestrictedType:
		var supergroupMembersFilterRestricted SupergroupMembersFilterRestricted
		err := json.Unmarshal(*rawMsg, &supergroupMembersFilterRestricted)
		return &supergroupMembersFilterRestricted, err

	case SupergroupMembersFilterBannedType:
		var supergroupMembersFilterBanned SupergroupMembersFilterBanned
		err := json.Unmarshal(*rawMsg, &supergroupMembersFilterBanned)
		return &supergroupMembersFilterBanned, err

	case SupergroupMembersFilterMentionType:
		var supergroupMembersFilterMention SupergroupMembersFilterMention
		err := json.Unmarshal(*rawMsg, &supergroupMembersFilterMention)
		return &supergroupMembersFilterMention, err

	case SupergroupMembersFilterBotsType:
		var supergroupMembersFilterBots SupergroupMembersFilterBots
		err := json.Unmarshal(*rawMsg, &supergroupMembersFilterBots)
		return &supergroupMembersFilterBots, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalSupergroupMembersFilterSlice(rawMsg *json.RawMessage) ([]SupergroupMembersFilter, error) {
	objects := make([]SupergroupMembersFilter, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch SupergroupMembersFilterEnum(objMap["@type"].(string)) {
		case SupergroupMembersFilterRecentType:
			var supergroupMembersFilterRecent SupergroupMembersFilterRecent
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &supergroupMembersFilterRecent)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &supergroupMembersFilterRecent)
		case SupergroupMembersFilterContactsType:
			var supergroupMembersFilterContacts SupergroupMembersFilterContacts
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &supergroupMembersFilterContacts)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &supergroupMembersFilterContacts)
		case SupergroupMembersFilterAdministratorsType:
			var supergroupMembersFilterAdministrators SupergroupMembersFilterAdministrators
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &supergroupMembersFilterAdministrators)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &supergroupMembersFilterAdministrators)
		case SupergroupMembersFilterSearchType:
			var supergroupMembersFilterSearch SupergroupMembersFilterSearch
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &supergroupMembersFilterSearch)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &supergroupMembersFilterSearch)
		case SupergroupMembersFilterRestrictedType:
			var supergroupMembersFilterRestricted SupergroupMembersFilterRestricted
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &supergroupMembersFilterRestricted)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &supergroupMembersFilterRestricted)
		case SupergroupMembersFilterBannedType:
			var supergroupMembersFilterBanned SupergroupMembersFilterBanned
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &supergroupMembersFilterBanned)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &supergroupMembersFilterBanned)
		case SupergroupMembersFilterMentionType:
			var supergroupMembersFilterMention SupergroupMembersFilterMention
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &supergroupMembersFilterMention)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &supergroupMembersFilterMention)
		case SupergroupMembersFilterBotsType:
			var supergroupMembersFilterBots SupergroupMembersFilterBots
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &supergroupMembersFilterBots)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &supergroupMembersFilterBots)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// SecretChatState Describes the current secret chat state
type SecretChatState interface {
	GetSecretChatStateEnum() SecretChatStateEnum
}

// SecretChatStateEnum Alias for abstract SecretChatState 'Sub-Classes', used as constant-enum here
type SecretChatStateEnum string

// SecretChatState enums
const (
	SecretChatStatePendingType SecretChatStateEnum = "secretChatStatePending"
	SecretChatStateReadyType   SecretChatStateEnum = "secretChatStateReady"
	SecretChatStateClosedType  SecretChatStateEnum = "secretChatStateClosed"
)

func unmarshalSecretChatState(rawMsg *json.RawMessage) (SecretChatState, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch SecretChatStateEnum(objMap["@type"].(string)) {
	case SecretChatStatePendingType:
		var secretChatStatePending SecretChatStatePending
		err := json.Unmarshal(*rawMsg, &secretChatStatePending)
		return &secretChatStatePending, err

	case SecretChatStateReadyType:
		var secretChatStateReady SecretChatStateReady
		err := json.Unmarshal(*rawMsg, &secretChatStateReady)
		return &secretChatStateReady, err

	case SecretChatStateClosedType:
		var secretChatStateClosed SecretChatStateClosed
		err := json.Unmarshal(*rawMsg, &secretChatStateClosed)
		return &secretChatStateClosed, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalSecretChatStateSlice(rawMsg *json.RawMessage) ([]SecretChatState, error) {
	objects := make([]SecretChatState, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch SecretChatStateEnum(objMap["@type"].(string)) {
		case SecretChatStatePendingType:
			var secretChatStatePending SecretChatStatePending
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &secretChatStatePending)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &secretChatStatePending)
		case SecretChatStateReadyType:
			var secretChatStateReady SecretChatStateReady
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &secretChatStateReady)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &secretChatStateReady)
		case SecretChatStateClosedType:
			var secretChatStateClosed SecretChatStateClosed
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &secretChatStateClosed)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &secretChatStateClosed)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// MessageSender Contains information about the sender of a message
type MessageSender interface {
	GetMessageSenderEnum() MessageSenderEnum
}

// MessageSenderEnum Alias for abstract MessageSender 'Sub-Classes', used as constant-enum here
type MessageSenderEnum string

// MessageSender enums
const (
	MessageSenderUserType MessageSenderEnum = "messageSenderUser"
	MessageSenderChatType MessageSenderEnum = "messageSenderChat"
)

func unmarshalMessageSender(rawMsg *json.RawMessage) (MessageSender, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch MessageSenderEnum(objMap["@type"].(string)) {
	case MessageSenderUserType:
		var messageSenderUser MessageSenderUser
		err := json.Unmarshal(*rawMsg, &messageSenderUser)
		return &messageSenderUser, err

	case MessageSenderChatType:
		var messageSenderChat MessageSenderChat
		err := json.Unmarshal(*rawMsg, &messageSenderChat)
		return &messageSenderChat, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalMessageSenderSlice(rawMsg *json.RawMessage) ([]MessageSender, error) {
	objects := make([]MessageSender, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch MessageSenderEnum(objMap["@type"].(string)) {
		case MessageSenderUserType:
			var messageSenderUser MessageSenderUser
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageSenderUser)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageSenderUser)
		case MessageSenderChatType:
			var messageSenderChat MessageSenderChat
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageSenderChat)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageSenderChat)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// MessageForwardOrigin Contains information about the origin of a forwarded message
type MessageForwardOrigin interface {
	GetMessageForwardOriginEnum() MessageForwardOriginEnum
}

// MessageForwardOriginEnum Alias for abstract MessageForwardOrigin 'Sub-Classes', used as constant-enum here
type MessageForwardOriginEnum string

// MessageForwardOrigin enums
const (
	MessageForwardOriginUserType          MessageForwardOriginEnum = "messageForwardOriginUser"
	MessageForwardOriginChatType          MessageForwardOriginEnum = "messageForwardOriginChat"
	MessageForwardOriginHiddenUserType    MessageForwardOriginEnum = "messageForwardOriginHiddenUser"
	MessageForwardOriginChannelType       MessageForwardOriginEnum = "messageForwardOriginChannel"
	MessageForwardOriginMessageImportType MessageForwardOriginEnum = "messageForwardOriginMessageImport"
)

func unmarshalMessageForwardOrigin(rawMsg *json.RawMessage) (MessageForwardOrigin, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch MessageForwardOriginEnum(objMap["@type"].(string)) {
	case MessageForwardOriginUserType:
		var messageForwardOriginUser MessageForwardOriginUser
		err := json.Unmarshal(*rawMsg, &messageForwardOriginUser)
		return &messageForwardOriginUser, err

	case MessageForwardOriginChatType:
		var messageForwardOriginChat MessageForwardOriginChat
		err := json.Unmarshal(*rawMsg, &messageForwardOriginChat)
		return &messageForwardOriginChat, err

	case MessageForwardOriginHiddenUserType:
		var messageForwardOriginHiddenUser MessageForwardOriginHiddenUser
		err := json.Unmarshal(*rawMsg, &messageForwardOriginHiddenUser)
		return &messageForwardOriginHiddenUser, err

	case MessageForwardOriginChannelType:
		var messageForwardOriginChannel MessageForwardOriginChannel
		err := json.Unmarshal(*rawMsg, &messageForwardOriginChannel)
		return &messageForwardOriginChannel, err

	case MessageForwardOriginMessageImportType:
		var messageForwardOriginMessageImport MessageForwardOriginMessageImport
		err := json.Unmarshal(*rawMsg, &messageForwardOriginMessageImport)
		return &messageForwardOriginMessageImport, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalMessageForwardOriginSlice(rawMsg *json.RawMessage) ([]MessageForwardOrigin, error) {
	objects := make([]MessageForwardOrigin, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch MessageForwardOriginEnum(objMap["@type"].(string)) {
		case MessageForwardOriginUserType:
			var messageForwardOriginUser MessageForwardOriginUser
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageForwardOriginUser)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageForwardOriginUser)
		case MessageForwardOriginChatType:
			var messageForwardOriginChat MessageForwardOriginChat
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageForwardOriginChat)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageForwardOriginChat)
		case MessageForwardOriginHiddenUserType:
			var messageForwardOriginHiddenUser MessageForwardOriginHiddenUser
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageForwardOriginHiddenUser)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageForwardOriginHiddenUser)
		case MessageForwardOriginChannelType:
			var messageForwardOriginChannel MessageForwardOriginChannel
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageForwardOriginChannel)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageForwardOriginChannel)
		case MessageForwardOriginMessageImportType:
			var messageForwardOriginMessageImport MessageForwardOriginMessageImport
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageForwardOriginMessageImport)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageForwardOriginMessageImport)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// MessageSendingState Contains information about the sending state of the message
type MessageSendingState interface {
	GetMessageSendingStateEnum() MessageSendingStateEnum
}

// MessageSendingStateEnum Alias for abstract MessageSendingState 'Sub-Classes', used as constant-enum here
type MessageSendingStateEnum string

// MessageSendingState enums
const (
	MessageSendingStatePendingType MessageSendingStateEnum = "messageSendingStatePending"
	MessageSendingStateFailedType  MessageSendingStateEnum = "messageSendingStateFailed"
)

func unmarshalMessageSendingState(rawMsg *json.RawMessage) (MessageSendingState, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch MessageSendingStateEnum(objMap["@type"].(string)) {
	case MessageSendingStatePendingType:
		var messageSendingStatePending MessageSendingStatePending
		err := json.Unmarshal(*rawMsg, &messageSendingStatePending)
		return &messageSendingStatePending, err

	case MessageSendingStateFailedType:
		var messageSendingStateFailed MessageSendingStateFailed
		err := json.Unmarshal(*rawMsg, &messageSendingStateFailed)
		return &messageSendingStateFailed, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalMessageSendingStateSlice(rawMsg *json.RawMessage) ([]MessageSendingState, error) {
	objects := make([]MessageSendingState, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch MessageSendingStateEnum(objMap["@type"].(string)) {
		case MessageSendingStatePendingType:
			var messageSendingStatePending MessageSendingStatePending
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageSendingStatePending)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageSendingStatePending)
		case MessageSendingStateFailedType:
			var messageSendingStateFailed MessageSendingStateFailed
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageSendingStateFailed)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageSendingStateFailed)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// NotificationSettingsScope Describes the types of chats to which notification settings are relevant
type NotificationSettingsScope interface {
	GetNotificationSettingsScopeEnum() NotificationSettingsScopeEnum
}

// NotificationSettingsScopeEnum Alias for abstract NotificationSettingsScope 'Sub-Classes', used as constant-enum here
type NotificationSettingsScopeEnum string

// NotificationSettingsScope enums
const (
	NotificationSettingsScopePrivateChatsType NotificationSettingsScopeEnum = "notificationSettingsScopePrivateChats"
	NotificationSettingsScopeGroupChatsType   NotificationSettingsScopeEnum = "notificationSettingsScopeGroupChats"
	NotificationSettingsScopeChannelChatsType NotificationSettingsScopeEnum = "notificationSettingsScopeChannelChats"
)

func unmarshalNotificationSettingsScope(rawMsg *json.RawMessage) (NotificationSettingsScope, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch NotificationSettingsScopeEnum(objMap["@type"].(string)) {
	case NotificationSettingsScopePrivateChatsType:
		var notificationSettingsScopePrivateChats NotificationSettingsScopePrivateChats
		err := json.Unmarshal(*rawMsg, &notificationSettingsScopePrivateChats)
		return &notificationSettingsScopePrivateChats, err

	case NotificationSettingsScopeGroupChatsType:
		var notificationSettingsScopeGroupChats NotificationSettingsScopeGroupChats
		err := json.Unmarshal(*rawMsg, &notificationSettingsScopeGroupChats)
		return &notificationSettingsScopeGroupChats, err

	case NotificationSettingsScopeChannelChatsType:
		var notificationSettingsScopeChannelChats NotificationSettingsScopeChannelChats
		err := json.Unmarshal(*rawMsg, &notificationSettingsScopeChannelChats)
		return &notificationSettingsScopeChannelChats, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalNotificationSettingsScopeSlice(rawMsg *json.RawMessage) ([]NotificationSettingsScope, error) {
	objects := make([]NotificationSettingsScope, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch NotificationSettingsScopeEnum(objMap["@type"].(string)) {
		case NotificationSettingsScopePrivateChatsType:
			var notificationSettingsScopePrivateChats NotificationSettingsScopePrivateChats
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &notificationSettingsScopePrivateChats)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &notificationSettingsScopePrivateChats)
		case NotificationSettingsScopeGroupChatsType:
			var notificationSettingsScopeGroupChats NotificationSettingsScopeGroupChats
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &notificationSettingsScopeGroupChats)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &notificationSettingsScopeGroupChats)
		case NotificationSettingsScopeChannelChatsType:
			var notificationSettingsScopeChannelChats NotificationSettingsScopeChannelChats
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &notificationSettingsScopeChannelChats)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &notificationSettingsScopeChannelChats)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// ChatType Describes the type of a chat
type ChatType interface {
	GetChatTypeEnum() ChatTypeEnum
}

// ChatTypeEnum Alias for abstract ChatType 'Sub-Classes', used as constant-enum here
type ChatTypeEnum string

// ChatType enums
const (
	ChatTypePrivateType    ChatTypeEnum = "chatTypePrivate"
	ChatTypeBasicGroupType ChatTypeEnum = "chatTypeBasicGroup"
	ChatTypeSupergroupType ChatTypeEnum = "chatTypeSupergroup"
	ChatTypeSecretType     ChatTypeEnum = "chatTypeSecret"
)

func unmarshalChatType(rawMsg *json.RawMessage) (ChatType, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch ChatTypeEnum(objMap["@type"].(string)) {
	case ChatTypePrivateType:
		var chatTypePrivate ChatTypePrivate
		err := json.Unmarshal(*rawMsg, &chatTypePrivate)
		return &chatTypePrivate, err

	case ChatTypeBasicGroupType:
		var chatTypeBasicGroup ChatTypeBasicGroup
		err := json.Unmarshal(*rawMsg, &chatTypeBasicGroup)
		return &chatTypeBasicGroup, err

	case ChatTypeSupergroupType:
		var chatTypeSupergroup ChatTypeSupergroup
		err := json.Unmarshal(*rawMsg, &chatTypeSupergroup)
		return &chatTypeSupergroup, err

	case ChatTypeSecretType:
		var chatTypeSecret ChatTypeSecret
		err := json.Unmarshal(*rawMsg, &chatTypeSecret)
		return &chatTypeSecret, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalChatTypeSlice(rawMsg *json.RawMessage) ([]ChatType, error) {
	objects := make([]ChatType, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch ChatTypeEnum(objMap["@type"].(string)) {
		case ChatTypePrivateType:
			var chatTypePrivate ChatTypePrivate
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatTypePrivate)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatTypePrivate)
		case ChatTypeBasicGroupType:
			var chatTypeBasicGroup ChatTypeBasicGroup
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatTypeBasicGroup)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatTypeBasicGroup)
		case ChatTypeSupergroupType:
			var chatTypeSupergroup ChatTypeSupergroup
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatTypeSupergroup)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatTypeSupergroup)
		case ChatTypeSecretType:
			var chatTypeSecret ChatTypeSecret
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatTypeSecret)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatTypeSecret)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// ChatList Describes a list of chats
type ChatList interface {
	GetChatListEnum() ChatListEnum
}

// ChatListEnum Alias for abstract ChatList 'Sub-Classes', used as constant-enum here
type ChatListEnum string

// ChatList enums
const (
	ChatListMainType    ChatListEnum = "chatListMain"
	ChatListArchiveType ChatListEnum = "chatListArchive"
	ChatListFilterType  ChatListEnum = "chatListFilter"
)

func unmarshalChatList(rawMsg *json.RawMessage) (ChatList, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch ChatListEnum(objMap["@type"].(string)) {
	case ChatListMainType:
		var chatListMain ChatListMain
		err := json.Unmarshal(*rawMsg, &chatListMain)
		return &chatListMain, err

	case ChatListArchiveType:
		var chatListArchive ChatListArchive
		err := json.Unmarshal(*rawMsg, &chatListArchive)
		return &chatListArchive, err

	case ChatListFilterType:
		var chatListFilter ChatListFilter
		err := json.Unmarshal(*rawMsg, &chatListFilter)
		return &chatListFilter, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalChatListSlice(rawMsg *json.RawMessage) ([]ChatList, error) {
	objects := make([]ChatList, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch ChatListEnum(objMap["@type"].(string)) {
		case ChatListMainType:
			var chatListMain ChatListMain
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatListMain)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatListMain)
		case ChatListArchiveType:
			var chatListArchive ChatListArchive
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatListArchive)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatListArchive)
		case ChatListFilterType:
			var chatListFilter ChatListFilter
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatListFilter)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatListFilter)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// ChatSource Describes a reason why an external chat is shown in a chat list
type ChatSource interface {
	GetChatSourceEnum() ChatSourceEnum
}

// ChatSourceEnum Alias for abstract ChatSource 'Sub-Classes', used as constant-enum here
type ChatSourceEnum string

// ChatSource enums
const (
	ChatSourceMtprotoProxyType              ChatSourceEnum = "chatSourceMtprotoProxy"
	ChatSourcePublicServiceAnnouncementType ChatSourceEnum = "chatSourcePublicServiceAnnouncement"
)

func unmarshalChatSource(rawMsg *json.RawMessage) (ChatSource, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch ChatSourceEnum(objMap["@type"].(string)) {
	case ChatSourceMtprotoProxyType:
		var chatSourceMtprotoProxy ChatSourceMtprotoProxy
		err := json.Unmarshal(*rawMsg, &chatSourceMtprotoProxy)
		return &chatSourceMtprotoProxy, err

	case ChatSourcePublicServiceAnnouncementType:
		var chatSourcePublicServiceAnnouncement ChatSourcePublicServiceAnnouncement
		err := json.Unmarshal(*rawMsg, &chatSourcePublicServiceAnnouncement)
		return &chatSourcePublicServiceAnnouncement, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalChatSourceSlice(rawMsg *json.RawMessage) ([]ChatSource, error) {
	objects := make([]ChatSource, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch ChatSourceEnum(objMap["@type"].(string)) {
		case ChatSourceMtprotoProxyType:
			var chatSourceMtprotoProxy ChatSourceMtprotoProxy
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatSourceMtprotoProxy)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatSourceMtprotoProxy)
		case ChatSourcePublicServiceAnnouncementType:
			var chatSourcePublicServiceAnnouncement ChatSourcePublicServiceAnnouncement
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatSourcePublicServiceAnnouncement)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatSourcePublicServiceAnnouncement)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// PublicChatType Describes a type of public chats
type PublicChatType interface {
	GetPublicChatTypeEnum() PublicChatTypeEnum
}

// PublicChatTypeEnum Alias for abstract PublicChatType 'Sub-Classes', used as constant-enum here
type PublicChatTypeEnum string

// PublicChatType enums
const (
	PublicChatTypeHasUsernameType     PublicChatTypeEnum = "publicChatTypeHasUsername"
	PublicChatTypeIsLocationBasedType PublicChatTypeEnum = "publicChatTypeIsLocationBased"
)

func unmarshalPublicChatType(rawMsg *json.RawMessage) (PublicChatType, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch PublicChatTypeEnum(objMap["@type"].(string)) {
	case PublicChatTypeHasUsernameType:
		var publicChatTypeHasUsername PublicChatTypeHasUsername
		err := json.Unmarshal(*rawMsg, &publicChatTypeHasUsername)
		return &publicChatTypeHasUsername, err

	case PublicChatTypeIsLocationBasedType:
		var publicChatTypeIsLocationBased PublicChatTypeIsLocationBased
		err := json.Unmarshal(*rawMsg, &publicChatTypeIsLocationBased)
		return &publicChatTypeIsLocationBased, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalPublicChatTypeSlice(rawMsg *json.RawMessage) ([]PublicChatType, error) {
	objects := make([]PublicChatType, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch PublicChatTypeEnum(objMap["@type"].(string)) {
		case PublicChatTypeHasUsernameType:
			var publicChatTypeHasUsername PublicChatTypeHasUsername
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &publicChatTypeHasUsername)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &publicChatTypeHasUsername)
		case PublicChatTypeIsLocationBasedType:
			var publicChatTypeIsLocationBased PublicChatTypeIsLocationBased
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &publicChatTypeIsLocationBased)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &publicChatTypeIsLocationBased)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// ChatActionBar Describes actions which must be possible to do through a chat action bar
type ChatActionBar interface {
	GetChatActionBarEnum() ChatActionBarEnum
}

// ChatActionBarEnum Alias for abstract ChatActionBar 'Sub-Classes', used as constant-enum here
type ChatActionBarEnum string

// ChatActionBar enums
const (
	ChatActionBarReportSpamType              ChatActionBarEnum = "chatActionBarReportSpam"
	ChatActionBarReportUnrelatedLocationType ChatActionBarEnum = "chatActionBarReportUnrelatedLocation"
	ChatActionBarInviteMembersType           ChatActionBarEnum = "chatActionBarInviteMembers"
	ChatActionBarReportAddBlockType          ChatActionBarEnum = "chatActionBarReportAddBlock"
	ChatActionBarAddContactType              ChatActionBarEnum = "chatActionBarAddContact"
	ChatActionBarSharePhoneNumberType        ChatActionBarEnum = "chatActionBarSharePhoneNumber"
	ChatActionBarJoinRequestType             ChatActionBarEnum = "chatActionBarJoinRequest"
)

func unmarshalChatActionBar(rawMsg *json.RawMessage) (ChatActionBar, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch ChatActionBarEnum(objMap["@type"].(string)) {
	case ChatActionBarReportSpamType:
		var chatActionBarReportSpam ChatActionBarReportSpam
		err := json.Unmarshal(*rawMsg, &chatActionBarReportSpam)
		return &chatActionBarReportSpam, err

	case ChatActionBarReportUnrelatedLocationType:
		var chatActionBarReportUnrelatedLocation ChatActionBarReportUnrelatedLocation
		err := json.Unmarshal(*rawMsg, &chatActionBarReportUnrelatedLocation)
		return &chatActionBarReportUnrelatedLocation, err

	case ChatActionBarInviteMembersType:
		var chatActionBarInviteMembers ChatActionBarInviteMembers
		err := json.Unmarshal(*rawMsg, &chatActionBarInviteMembers)
		return &chatActionBarInviteMembers, err

	case ChatActionBarReportAddBlockType:
		var chatActionBarReportAddBlock ChatActionBarReportAddBlock
		err := json.Unmarshal(*rawMsg, &chatActionBarReportAddBlock)
		return &chatActionBarReportAddBlock, err

	case ChatActionBarAddContactType:
		var chatActionBarAddContact ChatActionBarAddContact
		err := json.Unmarshal(*rawMsg, &chatActionBarAddContact)
		return &chatActionBarAddContact, err

	case ChatActionBarSharePhoneNumberType:
		var chatActionBarSharePhoneNumber ChatActionBarSharePhoneNumber
		err := json.Unmarshal(*rawMsg, &chatActionBarSharePhoneNumber)
		return &chatActionBarSharePhoneNumber, err

	case ChatActionBarJoinRequestType:
		var chatActionBarJoinRequest ChatActionBarJoinRequest
		err := json.Unmarshal(*rawMsg, &chatActionBarJoinRequest)
		return &chatActionBarJoinRequest, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalChatActionBarSlice(rawMsg *json.RawMessage) ([]ChatActionBar, error) {
	objects := make([]ChatActionBar, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch ChatActionBarEnum(objMap["@type"].(string)) {
		case ChatActionBarReportSpamType:
			var chatActionBarReportSpam ChatActionBarReportSpam
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatActionBarReportSpam)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatActionBarReportSpam)
		case ChatActionBarReportUnrelatedLocationType:
			var chatActionBarReportUnrelatedLocation ChatActionBarReportUnrelatedLocation
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatActionBarReportUnrelatedLocation)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatActionBarReportUnrelatedLocation)
		case ChatActionBarInviteMembersType:
			var chatActionBarInviteMembers ChatActionBarInviteMembers
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatActionBarInviteMembers)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatActionBarInviteMembers)
		case ChatActionBarReportAddBlockType:
			var chatActionBarReportAddBlock ChatActionBarReportAddBlock
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatActionBarReportAddBlock)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatActionBarReportAddBlock)
		case ChatActionBarAddContactType:
			var chatActionBarAddContact ChatActionBarAddContact
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatActionBarAddContact)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatActionBarAddContact)
		case ChatActionBarSharePhoneNumberType:
			var chatActionBarSharePhoneNumber ChatActionBarSharePhoneNumber
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatActionBarSharePhoneNumber)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatActionBarSharePhoneNumber)
		case ChatActionBarJoinRequestType:
			var chatActionBarJoinRequest ChatActionBarJoinRequest
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatActionBarJoinRequest)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatActionBarJoinRequest)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// KeyboardButtonType Describes a keyboard button type
type KeyboardButtonType interface {
	GetKeyboardButtonTypeEnum() KeyboardButtonTypeEnum
}

// KeyboardButtonTypeEnum Alias for abstract KeyboardButtonType 'Sub-Classes', used as constant-enum here
type KeyboardButtonTypeEnum string

// KeyboardButtonType enums
const (
	KeyboardButtonTypeTextType               KeyboardButtonTypeEnum = "keyboardButtonTypeText"
	KeyboardButtonTypeRequestPhoneNumberType KeyboardButtonTypeEnum = "keyboardButtonTypeRequestPhoneNumber"
	KeyboardButtonTypeRequestLocationType    KeyboardButtonTypeEnum = "keyboardButtonTypeRequestLocation"
	KeyboardButtonTypeRequestPollType        KeyboardButtonTypeEnum = "keyboardButtonTypeRequestPoll"
)

func unmarshalKeyboardButtonType(rawMsg *json.RawMessage) (KeyboardButtonType, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch KeyboardButtonTypeEnum(objMap["@type"].(string)) {
	case KeyboardButtonTypeTextType:
		var keyboardButtonTypeText KeyboardButtonTypeText
		err := json.Unmarshal(*rawMsg, &keyboardButtonTypeText)
		return &keyboardButtonTypeText, err

	case KeyboardButtonTypeRequestPhoneNumberType:
		var keyboardButtonTypeRequestPhoneNumber KeyboardButtonTypeRequestPhoneNumber
		err := json.Unmarshal(*rawMsg, &keyboardButtonTypeRequestPhoneNumber)
		return &keyboardButtonTypeRequestPhoneNumber, err

	case KeyboardButtonTypeRequestLocationType:
		var keyboardButtonTypeRequestLocation KeyboardButtonTypeRequestLocation
		err := json.Unmarshal(*rawMsg, &keyboardButtonTypeRequestLocation)
		return &keyboardButtonTypeRequestLocation, err

	case KeyboardButtonTypeRequestPollType:
		var keyboardButtonTypeRequestPoll KeyboardButtonTypeRequestPoll
		err := json.Unmarshal(*rawMsg, &keyboardButtonTypeRequestPoll)
		return &keyboardButtonTypeRequestPoll, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalKeyboardButtonTypeSlice(rawMsg *json.RawMessage) ([]KeyboardButtonType, error) {
	objects := make([]KeyboardButtonType, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch KeyboardButtonTypeEnum(objMap["@type"].(string)) {
		case KeyboardButtonTypeTextType:
			var keyboardButtonTypeText KeyboardButtonTypeText
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &keyboardButtonTypeText)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &keyboardButtonTypeText)
		case KeyboardButtonTypeRequestPhoneNumberType:
			var keyboardButtonTypeRequestPhoneNumber KeyboardButtonTypeRequestPhoneNumber
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &keyboardButtonTypeRequestPhoneNumber)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &keyboardButtonTypeRequestPhoneNumber)
		case KeyboardButtonTypeRequestLocationType:
			var keyboardButtonTypeRequestLocation KeyboardButtonTypeRequestLocation
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &keyboardButtonTypeRequestLocation)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &keyboardButtonTypeRequestLocation)
		case KeyboardButtonTypeRequestPollType:
			var keyboardButtonTypeRequestPoll KeyboardButtonTypeRequestPoll
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &keyboardButtonTypeRequestPoll)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &keyboardButtonTypeRequestPoll)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// InlineKeyboardButtonType Describes the type of an inline keyboard button
type InlineKeyboardButtonType interface {
	GetInlineKeyboardButtonTypeEnum() InlineKeyboardButtonTypeEnum
}

// InlineKeyboardButtonTypeEnum Alias for abstract InlineKeyboardButtonType 'Sub-Classes', used as constant-enum here
type InlineKeyboardButtonTypeEnum string

// InlineKeyboardButtonType enums
const (
	InlineKeyboardButtonTypeURLType                  InlineKeyboardButtonTypeEnum = "inlineKeyboardButtonTypeUrl"
	InlineKeyboardButtonTypeLoginURLType             InlineKeyboardButtonTypeEnum = "inlineKeyboardButtonTypeLoginUrl"
	InlineKeyboardButtonTypeCallbackType             InlineKeyboardButtonTypeEnum = "inlineKeyboardButtonTypeCallback"
	InlineKeyboardButtonTypeCallbackWithPasswordType InlineKeyboardButtonTypeEnum = "inlineKeyboardButtonTypeCallbackWithPassword"
	InlineKeyboardButtonTypeCallbackGameType         InlineKeyboardButtonTypeEnum = "inlineKeyboardButtonTypeCallbackGame"
	InlineKeyboardButtonTypeSwitchInlineType         InlineKeyboardButtonTypeEnum = "inlineKeyboardButtonTypeSwitchInline"
	InlineKeyboardButtonTypeBuyType                  InlineKeyboardButtonTypeEnum = "inlineKeyboardButtonTypeBuy"
	InlineKeyboardButtonTypeUserType                 InlineKeyboardButtonTypeEnum = "inlineKeyboardButtonTypeUser"
)

func unmarshalInlineKeyboardButtonType(rawMsg *json.RawMessage) (InlineKeyboardButtonType, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch InlineKeyboardButtonTypeEnum(objMap["@type"].(string)) {
	case InlineKeyboardButtonTypeURLType:
		var inlineKeyboardButtonTypeURL InlineKeyboardButtonTypeURL
		err := json.Unmarshal(*rawMsg, &inlineKeyboardButtonTypeURL)
		return &inlineKeyboardButtonTypeURL, err

	case InlineKeyboardButtonTypeLoginURLType:
		var inlineKeyboardButtonTypeLoginURL InlineKeyboardButtonTypeLoginURL
		err := json.Unmarshal(*rawMsg, &inlineKeyboardButtonTypeLoginURL)
		return &inlineKeyboardButtonTypeLoginURL, err

	case InlineKeyboardButtonTypeCallbackType:
		var inlineKeyboardButtonTypeCallback InlineKeyboardButtonTypeCallback
		err := json.Unmarshal(*rawMsg, &inlineKeyboardButtonTypeCallback)
		return &inlineKeyboardButtonTypeCallback, err

	case InlineKeyboardButtonTypeCallbackWithPasswordType:
		var inlineKeyboardButtonTypeCallbackWithPassword InlineKeyboardButtonTypeCallbackWithPassword
		err := json.Unmarshal(*rawMsg, &inlineKeyboardButtonTypeCallbackWithPassword)
		return &inlineKeyboardButtonTypeCallbackWithPassword, err

	case InlineKeyboardButtonTypeCallbackGameType:
		var inlineKeyboardButtonTypeCallbackGame InlineKeyboardButtonTypeCallbackGame
		err := json.Unmarshal(*rawMsg, &inlineKeyboardButtonTypeCallbackGame)
		return &inlineKeyboardButtonTypeCallbackGame, err

	case InlineKeyboardButtonTypeSwitchInlineType:
		var inlineKeyboardButtonTypeSwitchInline InlineKeyboardButtonTypeSwitchInline
		err := json.Unmarshal(*rawMsg, &inlineKeyboardButtonTypeSwitchInline)
		return &inlineKeyboardButtonTypeSwitchInline, err

	case InlineKeyboardButtonTypeBuyType:
		var inlineKeyboardButtonTypeBuy InlineKeyboardButtonTypeBuy
		err := json.Unmarshal(*rawMsg, &inlineKeyboardButtonTypeBuy)
		return &inlineKeyboardButtonTypeBuy, err

	case InlineKeyboardButtonTypeUserType:
		var inlineKeyboardButtonTypeUser InlineKeyboardButtonTypeUser
		err := json.Unmarshal(*rawMsg, &inlineKeyboardButtonTypeUser)
		return &inlineKeyboardButtonTypeUser, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalInlineKeyboardButtonTypeSlice(rawMsg *json.RawMessage) ([]InlineKeyboardButtonType, error) {
	objects := make([]InlineKeyboardButtonType, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch InlineKeyboardButtonTypeEnum(objMap["@type"].(string)) {
		case InlineKeyboardButtonTypeURLType:
			var inlineKeyboardButtonTypeURL InlineKeyboardButtonTypeURL
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inlineKeyboardButtonTypeURL)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inlineKeyboardButtonTypeURL)
		case InlineKeyboardButtonTypeLoginURLType:
			var inlineKeyboardButtonTypeLoginURL InlineKeyboardButtonTypeLoginURL
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inlineKeyboardButtonTypeLoginURL)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inlineKeyboardButtonTypeLoginURL)
		case InlineKeyboardButtonTypeCallbackType:
			var inlineKeyboardButtonTypeCallback InlineKeyboardButtonTypeCallback
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inlineKeyboardButtonTypeCallback)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inlineKeyboardButtonTypeCallback)
		case InlineKeyboardButtonTypeCallbackWithPasswordType:
			var inlineKeyboardButtonTypeCallbackWithPassword InlineKeyboardButtonTypeCallbackWithPassword
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inlineKeyboardButtonTypeCallbackWithPassword)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inlineKeyboardButtonTypeCallbackWithPassword)
		case InlineKeyboardButtonTypeCallbackGameType:
			var inlineKeyboardButtonTypeCallbackGame InlineKeyboardButtonTypeCallbackGame
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inlineKeyboardButtonTypeCallbackGame)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inlineKeyboardButtonTypeCallbackGame)
		case InlineKeyboardButtonTypeSwitchInlineType:
			var inlineKeyboardButtonTypeSwitchInline InlineKeyboardButtonTypeSwitchInline
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inlineKeyboardButtonTypeSwitchInline)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inlineKeyboardButtonTypeSwitchInline)
		case InlineKeyboardButtonTypeBuyType:
			var inlineKeyboardButtonTypeBuy InlineKeyboardButtonTypeBuy
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inlineKeyboardButtonTypeBuy)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inlineKeyboardButtonTypeBuy)
		case InlineKeyboardButtonTypeUserType:
			var inlineKeyboardButtonTypeUser InlineKeyboardButtonTypeUser
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inlineKeyboardButtonTypeUser)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inlineKeyboardButtonTypeUser)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// ReplyMarkup Contains a description of a custom keyboard and actions that can be done with it to quickly reply to bots
type ReplyMarkup interface {
	GetReplyMarkupEnum() ReplyMarkupEnum
}

// ReplyMarkupEnum Alias for abstract ReplyMarkup 'Sub-Classes', used as constant-enum here
type ReplyMarkupEnum string

// ReplyMarkup enums
const (
	ReplyMarkupRemoveKeyboardType ReplyMarkupEnum = "replyMarkupRemoveKeyboard"
	ReplyMarkupForceReplyType     ReplyMarkupEnum = "replyMarkupForceReply"
	ReplyMarkupShowKeyboardType   ReplyMarkupEnum = "replyMarkupShowKeyboard"
	ReplyMarkupInlineKeyboardType ReplyMarkupEnum = "replyMarkupInlineKeyboard"
)

func unmarshalReplyMarkup(rawMsg *json.RawMessage) (ReplyMarkup, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch ReplyMarkupEnum(objMap["@type"].(string)) {
	case ReplyMarkupRemoveKeyboardType:
		var replyMarkupRemoveKeyboard ReplyMarkupRemoveKeyboard
		err := json.Unmarshal(*rawMsg, &replyMarkupRemoveKeyboard)
		return &replyMarkupRemoveKeyboard, err

	case ReplyMarkupForceReplyType:
		var replyMarkupForceReply ReplyMarkupForceReply
		err := json.Unmarshal(*rawMsg, &replyMarkupForceReply)
		return &replyMarkupForceReply, err

	case ReplyMarkupShowKeyboardType:
		var replyMarkupShowKeyboard ReplyMarkupShowKeyboard
		err := json.Unmarshal(*rawMsg, &replyMarkupShowKeyboard)
		return &replyMarkupShowKeyboard, err

	case ReplyMarkupInlineKeyboardType:
		var replyMarkupInlineKeyboard ReplyMarkupInlineKeyboard
		err := json.Unmarshal(*rawMsg, &replyMarkupInlineKeyboard)
		return &replyMarkupInlineKeyboard, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalReplyMarkupSlice(rawMsg *json.RawMessage) ([]ReplyMarkup, error) {
	objects := make([]ReplyMarkup, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch ReplyMarkupEnum(objMap["@type"].(string)) {
		case ReplyMarkupRemoveKeyboardType:
			var replyMarkupRemoveKeyboard ReplyMarkupRemoveKeyboard
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &replyMarkupRemoveKeyboard)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &replyMarkupRemoveKeyboard)
		case ReplyMarkupForceReplyType:
			var replyMarkupForceReply ReplyMarkupForceReply
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &replyMarkupForceReply)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &replyMarkupForceReply)
		case ReplyMarkupShowKeyboardType:
			var replyMarkupShowKeyboard ReplyMarkupShowKeyboard
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &replyMarkupShowKeyboard)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &replyMarkupShowKeyboard)
		case ReplyMarkupInlineKeyboardType:
			var replyMarkupInlineKeyboard ReplyMarkupInlineKeyboard
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &replyMarkupInlineKeyboard)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &replyMarkupInlineKeyboard)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// LoginURLInfo Contains information about an inline button of type inlineKeyboardButtonTypeLoginUrl
type LoginURLInfo interface {
	GetLoginURLInfoEnum() LoginURLInfoEnum
}

// LoginURLInfoEnum Alias for abstract LoginURLInfo 'Sub-Classes', used as constant-enum here
type LoginURLInfoEnum string

// LoginURLInfo enums
const ()

func unmarshalLoginURLInfo(rawMsg *json.RawMessage) (LoginURLInfo, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch LoginURLInfoEnum(objMap["@type"].(string)) {

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalLoginURLInfoSlice(rawMsg *json.RawMessage) ([]LoginURLInfo, error) {
	objects := make([]LoginURLInfo, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch LoginURLInfoEnum(objMap["@type"].(string)) {

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// RichText Describes a text object inside an instant-view web page
type RichText interface {
	GetRichTextEnum() RichTextEnum
}

// RichTextEnum Alias for abstract RichText 'Sub-Classes', used as constant-enum here
type RichTextEnum string

// RichText enums
const (
	RichTextPlainType         RichTextEnum = "richTextPlain"
	RichTextBoldType          RichTextEnum = "richTextBold"
	RichTextItalicType        RichTextEnum = "richTextItalic"
	RichTextUnderlineType     RichTextEnum = "richTextUnderline"
	RichTextStrikethroughType RichTextEnum = "richTextStrikethrough"
	RichTextFixedType         RichTextEnum = "richTextFixed"
	RichTextURLType           RichTextEnum = "richTextUrl"
	RichTextEmailAddressType  RichTextEnum = "richTextEmailAddress"
	RichTextSubscriptType     RichTextEnum = "richTextSubscript"
	RichTextSuperscriptType   RichTextEnum = "richTextSuperscript"
	RichTextMarkedType        RichTextEnum = "richTextMarked"
	RichTextPhoneNumberType   RichTextEnum = "richTextPhoneNumber"
	RichTextIconType          RichTextEnum = "richTextIcon"
	RichTextReferenceType     RichTextEnum = "richTextReference"
	RichTextAnchorType        RichTextEnum = "richTextAnchor"
	RichTextAnchorLinkType    RichTextEnum = "richTextAnchorLink"
	RichTextsType             RichTextEnum = "richTexts"
)

func unmarshalRichText(rawMsg *json.RawMessage) (RichText, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch RichTextEnum(objMap["@type"].(string)) {
	case RichTextPlainType:
		var richTextPlain RichTextPlain
		err := json.Unmarshal(*rawMsg, &richTextPlain)
		return &richTextPlain, err

	case RichTextBoldType:
		var richTextBold RichTextBold
		err := json.Unmarshal(*rawMsg, &richTextBold)
		return &richTextBold, err

	case RichTextItalicType:
		var richTextItalic RichTextItalic
		err := json.Unmarshal(*rawMsg, &richTextItalic)
		return &richTextItalic, err

	case RichTextUnderlineType:
		var richTextUnderline RichTextUnderline
		err := json.Unmarshal(*rawMsg, &richTextUnderline)
		return &richTextUnderline, err

	case RichTextStrikethroughType:
		var richTextStrikethrough RichTextStrikethrough
		err := json.Unmarshal(*rawMsg, &richTextStrikethrough)
		return &richTextStrikethrough, err

	case RichTextFixedType:
		var richTextFixed RichTextFixed
		err := json.Unmarshal(*rawMsg, &richTextFixed)
		return &richTextFixed, err

	case RichTextURLType:
		var richTextURL RichTextURL
		err := json.Unmarshal(*rawMsg, &richTextURL)
		return &richTextURL, err

	case RichTextEmailAddressType:
		var richTextEmailAddress RichTextEmailAddress
		err := json.Unmarshal(*rawMsg, &richTextEmailAddress)
		return &richTextEmailAddress, err

	case RichTextSubscriptType:
		var richTextSubscript RichTextSubscript
		err := json.Unmarshal(*rawMsg, &richTextSubscript)
		return &richTextSubscript, err

	case RichTextSuperscriptType:
		var richTextSuperscript RichTextSuperscript
		err := json.Unmarshal(*rawMsg, &richTextSuperscript)
		return &richTextSuperscript, err

	case RichTextMarkedType:
		var richTextMarked RichTextMarked
		err := json.Unmarshal(*rawMsg, &richTextMarked)
		return &richTextMarked, err

	case RichTextPhoneNumberType:
		var richTextPhoneNumber RichTextPhoneNumber
		err := json.Unmarshal(*rawMsg, &richTextPhoneNumber)
		return &richTextPhoneNumber, err

	case RichTextIconType:
		var richTextIcon RichTextIcon
		err := json.Unmarshal(*rawMsg, &richTextIcon)
		return &richTextIcon, err

	case RichTextReferenceType:
		var richTextReference RichTextReference
		err := json.Unmarshal(*rawMsg, &richTextReference)
		return &richTextReference, err

	case RichTextAnchorType:
		var richTextAnchor RichTextAnchor
		err := json.Unmarshal(*rawMsg, &richTextAnchor)
		return &richTextAnchor, err

	case RichTextAnchorLinkType:
		var richTextAnchorLink RichTextAnchorLink
		err := json.Unmarshal(*rawMsg, &richTextAnchorLink)
		return &richTextAnchorLink, err

	case RichTextsType:
		var richTexts RichTexts
		err := json.Unmarshal(*rawMsg, &richTexts)
		return &richTexts, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalRichTextSlice(rawMsg *json.RawMessage) ([]RichText, error) {
	objects := make([]RichText, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch RichTextEnum(objMap["@type"].(string)) {
		case RichTextPlainType:
			var richTextPlain RichTextPlain
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &richTextPlain)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &richTextPlain)
		case RichTextBoldType:
			var richTextBold RichTextBold
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &richTextBold)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &richTextBold)
		case RichTextItalicType:
			var richTextItalic RichTextItalic
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &richTextItalic)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &richTextItalic)
		case RichTextUnderlineType:
			var richTextUnderline RichTextUnderline
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &richTextUnderline)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &richTextUnderline)
		case RichTextStrikethroughType:
			var richTextStrikethrough RichTextStrikethrough
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &richTextStrikethrough)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &richTextStrikethrough)
		case RichTextFixedType:
			var richTextFixed RichTextFixed
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &richTextFixed)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &richTextFixed)
		case RichTextURLType:
			var richTextURL RichTextURL
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &richTextURL)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &richTextURL)
		case RichTextEmailAddressType:
			var richTextEmailAddress RichTextEmailAddress
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &richTextEmailAddress)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &richTextEmailAddress)
		case RichTextSubscriptType:
			var richTextSubscript RichTextSubscript
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &richTextSubscript)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &richTextSubscript)
		case RichTextSuperscriptType:
			var richTextSuperscript RichTextSuperscript
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &richTextSuperscript)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &richTextSuperscript)
		case RichTextMarkedType:
			var richTextMarked RichTextMarked
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &richTextMarked)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &richTextMarked)
		case RichTextPhoneNumberType:
			var richTextPhoneNumber RichTextPhoneNumber
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &richTextPhoneNumber)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &richTextPhoneNumber)
		case RichTextIconType:
			var richTextIcon RichTextIcon
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &richTextIcon)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &richTextIcon)
		case RichTextReferenceType:
			var richTextReference RichTextReference
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &richTextReference)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &richTextReference)
		case RichTextAnchorType:
			var richTextAnchor RichTextAnchor
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &richTextAnchor)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &richTextAnchor)
		case RichTextAnchorLinkType:
			var richTextAnchorLink RichTextAnchorLink
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &richTextAnchorLink)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &richTextAnchorLink)
		case RichTextsType:
			var richTexts RichTexts
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &richTexts)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &richTexts)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// PageBlockHorizontalAlignment Describes a horizontal alignment of a table cell content
type PageBlockHorizontalAlignment interface {
	GetPageBlockHorizontalAlignmentEnum() PageBlockHorizontalAlignmentEnum
}

// PageBlockHorizontalAlignmentEnum Alias for abstract PageBlockHorizontalAlignment 'Sub-Classes', used as constant-enum here
type PageBlockHorizontalAlignmentEnum string

// PageBlockHorizontalAlignment enums
const (
	PageBlockHorizontalAlignmentLeftType   PageBlockHorizontalAlignmentEnum = "pageBlockHorizontalAlignmentLeft"
	PageBlockHorizontalAlignmentCenterType PageBlockHorizontalAlignmentEnum = "pageBlockHorizontalAlignmentCenter"
	PageBlockHorizontalAlignmentRightType  PageBlockHorizontalAlignmentEnum = "pageBlockHorizontalAlignmentRight"
)

func unmarshalPageBlockHorizontalAlignment(rawMsg *json.RawMessage) (PageBlockHorizontalAlignment, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch PageBlockHorizontalAlignmentEnum(objMap["@type"].(string)) {
	case PageBlockHorizontalAlignmentLeftType:
		var pageBlockHorizontalAlignmentLeft PageBlockHorizontalAlignmentLeft
		err := json.Unmarshal(*rawMsg, &pageBlockHorizontalAlignmentLeft)
		return &pageBlockHorizontalAlignmentLeft, err

	case PageBlockHorizontalAlignmentCenterType:
		var pageBlockHorizontalAlignmentCenter PageBlockHorizontalAlignmentCenter
		err := json.Unmarshal(*rawMsg, &pageBlockHorizontalAlignmentCenter)
		return &pageBlockHorizontalAlignmentCenter, err

	case PageBlockHorizontalAlignmentRightType:
		var pageBlockHorizontalAlignmentRight PageBlockHorizontalAlignmentRight
		err := json.Unmarshal(*rawMsg, &pageBlockHorizontalAlignmentRight)
		return &pageBlockHorizontalAlignmentRight, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalPageBlockHorizontalAlignmentSlice(rawMsg *json.RawMessage) ([]PageBlockHorizontalAlignment, error) {
	objects := make([]PageBlockHorizontalAlignment, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch PageBlockHorizontalAlignmentEnum(objMap["@type"].(string)) {
		case PageBlockHorizontalAlignmentLeftType:
			var pageBlockHorizontalAlignmentLeft PageBlockHorizontalAlignmentLeft
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pageBlockHorizontalAlignmentLeft)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pageBlockHorizontalAlignmentLeft)
		case PageBlockHorizontalAlignmentCenterType:
			var pageBlockHorizontalAlignmentCenter PageBlockHorizontalAlignmentCenter
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pageBlockHorizontalAlignmentCenter)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pageBlockHorizontalAlignmentCenter)
		case PageBlockHorizontalAlignmentRightType:
			var pageBlockHorizontalAlignmentRight PageBlockHorizontalAlignmentRight
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pageBlockHorizontalAlignmentRight)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pageBlockHorizontalAlignmentRight)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// PageBlockVerticalAlignment Describes a Vertical alignment of a table cell content
type PageBlockVerticalAlignment interface {
	GetPageBlockVerticalAlignmentEnum() PageBlockVerticalAlignmentEnum
}

// PageBlockVerticalAlignmentEnum Alias for abstract PageBlockVerticalAlignment 'Sub-Classes', used as constant-enum here
type PageBlockVerticalAlignmentEnum string

// PageBlockVerticalAlignment enums
const (
	PageBlockVerticalAlignmentTopType    PageBlockVerticalAlignmentEnum = "pageBlockVerticalAlignmentTop"
	PageBlockVerticalAlignmentMiddleType PageBlockVerticalAlignmentEnum = "pageBlockVerticalAlignmentMiddle"
	PageBlockVerticalAlignmentBottomType PageBlockVerticalAlignmentEnum = "pageBlockVerticalAlignmentBottom"
)

func unmarshalPageBlockVerticalAlignment(rawMsg *json.RawMessage) (PageBlockVerticalAlignment, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch PageBlockVerticalAlignmentEnum(objMap["@type"].(string)) {
	case PageBlockVerticalAlignmentTopType:
		var pageBlockVerticalAlignmentTop PageBlockVerticalAlignmentTop
		err := json.Unmarshal(*rawMsg, &pageBlockVerticalAlignmentTop)
		return &pageBlockVerticalAlignmentTop, err

	case PageBlockVerticalAlignmentMiddleType:
		var pageBlockVerticalAlignmentMiddle PageBlockVerticalAlignmentMiddle
		err := json.Unmarshal(*rawMsg, &pageBlockVerticalAlignmentMiddle)
		return &pageBlockVerticalAlignmentMiddle, err

	case PageBlockVerticalAlignmentBottomType:
		var pageBlockVerticalAlignmentBottom PageBlockVerticalAlignmentBottom
		err := json.Unmarshal(*rawMsg, &pageBlockVerticalAlignmentBottom)
		return &pageBlockVerticalAlignmentBottom, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalPageBlockVerticalAlignmentSlice(rawMsg *json.RawMessage) ([]PageBlockVerticalAlignment, error) {
	objects := make([]PageBlockVerticalAlignment, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch PageBlockVerticalAlignmentEnum(objMap["@type"].(string)) {
		case PageBlockVerticalAlignmentTopType:
			var pageBlockVerticalAlignmentTop PageBlockVerticalAlignmentTop
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pageBlockVerticalAlignmentTop)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pageBlockVerticalAlignmentTop)
		case PageBlockVerticalAlignmentMiddleType:
			var pageBlockVerticalAlignmentMiddle PageBlockVerticalAlignmentMiddle
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pageBlockVerticalAlignmentMiddle)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pageBlockVerticalAlignmentMiddle)
		case PageBlockVerticalAlignmentBottomType:
			var pageBlockVerticalAlignmentBottom PageBlockVerticalAlignmentBottom
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pageBlockVerticalAlignmentBottom)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pageBlockVerticalAlignmentBottom)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// PageBlock Describes a block of an instant view web page
type PageBlock interface {
	GetPageBlockEnum() PageBlockEnum
}

// PageBlockEnum Alias for abstract PageBlock 'Sub-Classes', used as constant-enum here
type PageBlockEnum string

// PageBlock enums
const (
	PageBlockTitleType           PageBlockEnum = "pageBlockTitle"
	PageBlockSubtitleType        PageBlockEnum = "pageBlockSubtitle"
	PageBlockAuthorDateType      PageBlockEnum = "pageBlockAuthorDate"
	PageBlockHeaderType          PageBlockEnum = "pageBlockHeader"
	PageBlockSubheaderType       PageBlockEnum = "pageBlockSubheader"
	PageBlockKickerType          PageBlockEnum = "pageBlockKicker"
	PageBlockParagraphType       PageBlockEnum = "pageBlockParagraph"
	PageBlockPreformattedType    PageBlockEnum = "pageBlockPreformatted"
	PageBlockFooterType          PageBlockEnum = "pageBlockFooter"
	PageBlockDividerType         PageBlockEnum = "pageBlockDivider"
	PageBlockAnchorType          PageBlockEnum = "pageBlockAnchor"
	PageBlockListType            PageBlockEnum = "pageBlockList"
	PageBlockBlockQuoteType      PageBlockEnum = "pageBlockBlockQuote"
	PageBlockPullQuoteType       PageBlockEnum = "pageBlockPullQuote"
	PageBlockAnimationType       PageBlockEnum = "pageBlockAnimation"
	PageBlockAudioType           PageBlockEnum = "pageBlockAudio"
	PageBlockPhotoType           PageBlockEnum = "pageBlockPhoto"
	PageBlockVideoType           PageBlockEnum = "pageBlockVideo"
	PageBlockVoiceNoteType       PageBlockEnum = "pageBlockVoiceNote"
	PageBlockCoverType           PageBlockEnum = "pageBlockCover"
	PageBlockEmbeddedType        PageBlockEnum = "pageBlockEmbedded"
	PageBlockEmbeddedPostType    PageBlockEnum = "pageBlockEmbeddedPost"
	PageBlockCollageType         PageBlockEnum = "pageBlockCollage"
	PageBlockSlideshowType       PageBlockEnum = "pageBlockSlideshow"
	PageBlockChatLinkType        PageBlockEnum = "pageBlockChatLink"
	PageBlockTableType           PageBlockEnum = "pageBlockTable"
	PageBlockDetailsType         PageBlockEnum = "pageBlockDetails"
	PageBlockRelatedArticlesType PageBlockEnum = "pageBlockRelatedArticles"
	PageBlockMapType             PageBlockEnum = "pageBlockMap"
)

func unmarshalPageBlock(rawMsg *json.RawMessage) (PageBlock, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch PageBlockEnum(objMap["@type"].(string)) {
	case PageBlockTitleType:
		var pageBlockTitle PageBlockTitle
		err := json.Unmarshal(*rawMsg, &pageBlockTitle)
		return &pageBlockTitle, err

	case PageBlockSubtitleType:
		var pageBlockSubtitle PageBlockSubtitle
		err := json.Unmarshal(*rawMsg, &pageBlockSubtitle)
		return &pageBlockSubtitle, err

	case PageBlockAuthorDateType:
		var pageBlockAuthorDate PageBlockAuthorDate
		err := json.Unmarshal(*rawMsg, &pageBlockAuthorDate)
		return &pageBlockAuthorDate, err

	case PageBlockHeaderType:
		var pageBlockHeader PageBlockHeader
		err := json.Unmarshal(*rawMsg, &pageBlockHeader)
		return &pageBlockHeader, err

	case PageBlockSubheaderType:
		var pageBlockSubheader PageBlockSubheader
		err := json.Unmarshal(*rawMsg, &pageBlockSubheader)
		return &pageBlockSubheader, err

	case PageBlockKickerType:
		var pageBlockKicker PageBlockKicker
		err := json.Unmarshal(*rawMsg, &pageBlockKicker)
		return &pageBlockKicker, err

	case PageBlockParagraphType:
		var pageBlockParagraph PageBlockParagraph
		err := json.Unmarshal(*rawMsg, &pageBlockParagraph)
		return &pageBlockParagraph, err

	case PageBlockPreformattedType:
		var pageBlockPreformatted PageBlockPreformatted
		err := json.Unmarshal(*rawMsg, &pageBlockPreformatted)
		return &pageBlockPreformatted, err

	case PageBlockFooterType:
		var pageBlockFooter PageBlockFooter
		err := json.Unmarshal(*rawMsg, &pageBlockFooter)
		return &pageBlockFooter, err

	case PageBlockDividerType:
		var pageBlockDivider PageBlockDivider
		err := json.Unmarshal(*rawMsg, &pageBlockDivider)
		return &pageBlockDivider, err

	case PageBlockAnchorType:
		var pageBlockAnchor PageBlockAnchor
		err := json.Unmarshal(*rawMsg, &pageBlockAnchor)
		return &pageBlockAnchor, err

	case PageBlockListType:
		var pageBlockList PageBlockList
		err := json.Unmarshal(*rawMsg, &pageBlockList)
		return &pageBlockList, err

	case PageBlockBlockQuoteType:
		var pageBlockBlockQuote PageBlockBlockQuote
		err := json.Unmarshal(*rawMsg, &pageBlockBlockQuote)
		return &pageBlockBlockQuote, err

	case PageBlockPullQuoteType:
		var pageBlockPullQuote PageBlockPullQuote
		err := json.Unmarshal(*rawMsg, &pageBlockPullQuote)
		return &pageBlockPullQuote, err

	case PageBlockAnimationType:
		var pageBlockAnimation PageBlockAnimation
		err := json.Unmarshal(*rawMsg, &pageBlockAnimation)
		return &pageBlockAnimation, err

	case PageBlockAudioType:
		var pageBlockAudio PageBlockAudio
		err := json.Unmarshal(*rawMsg, &pageBlockAudio)
		return &pageBlockAudio, err

	case PageBlockPhotoType:
		var pageBlockPhoto PageBlockPhoto
		err := json.Unmarshal(*rawMsg, &pageBlockPhoto)
		return &pageBlockPhoto, err

	case PageBlockVideoType:
		var pageBlockVideo PageBlockVideo
		err := json.Unmarshal(*rawMsg, &pageBlockVideo)
		return &pageBlockVideo, err

	case PageBlockVoiceNoteType:
		var pageBlockVoiceNote PageBlockVoiceNote
		err := json.Unmarshal(*rawMsg, &pageBlockVoiceNote)
		return &pageBlockVoiceNote, err

	case PageBlockCoverType:
		var pageBlockCover PageBlockCover
		err := json.Unmarshal(*rawMsg, &pageBlockCover)
		return &pageBlockCover, err

	case PageBlockEmbeddedType:
		var pageBlockEmbedded PageBlockEmbedded
		err := json.Unmarshal(*rawMsg, &pageBlockEmbedded)
		return &pageBlockEmbedded, err

	case PageBlockEmbeddedPostType:
		var pageBlockEmbeddedPost PageBlockEmbeddedPost
		err := json.Unmarshal(*rawMsg, &pageBlockEmbeddedPost)
		return &pageBlockEmbeddedPost, err

	case PageBlockCollageType:
		var pageBlockCollage PageBlockCollage
		err := json.Unmarshal(*rawMsg, &pageBlockCollage)
		return &pageBlockCollage, err

	case PageBlockSlideshowType:
		var pageBlockSlideshow PageBlockSlideshow
		err := json.Unmarshal(*rawMsg, &pageBlockSlideshow)
		return &pageBlockSlideshow, err

	case PageBlockChatLinkType:
		var pageBlockChatLink PageBlockChatLink
		err := json.Unmarshal(*rawMsg, &pageBlockChatLink)
		return &pageBlockChatLink, err

	case PageBlockTableType:
		var pageBlockTable PageBlockTable
		err := json.Unmarshal(*rawMsg, &pageBlockTable)
		return &pageBlockTable, err

	case PageBlockDetailsType:
		var pageBlockDetails PageBlockDetails
		err := json.Unmarshal(*rawMsg, &pageBlockDetails)
		return &pageBlockDetails, err

	case PageBlockRelatedArticlesType:
		var pageBlockRelatedArticles PageBlockRelatedArticles
		err := json.Unmarshal(*rawMsg, &pageBlockRelatedArticles)
		return &pageBlockRelatedArticles, err

	case PageBlockMapType:
		var pageBlockMap PageBlockMap
		err := json.Unmarshal(*rawMsg, &pageBlockMap)
		return &pageBlockMap, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalPageBlockSlice(rawMsg *json.RawMessage) ([]PageBlock, error) {
	objects := make([]PageBlock, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch PageBlockEnum(objMap["@type"].(string)) {
		case PageBlockTitleType:
			var pageBlockTitle PageBlockTitle
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pageBlockTitle)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pageBlockTitle)
		case PageBlockSubtitleType:
			var pageBlockSubtitle PageBlockSubtitle
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pageBlockSubtitle)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pageBlockSubtitle)
		case PageBlockAuthorDateType:
			var pageBlockAuthorDate PageBlockAuthorDate
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pageBlockAuthorDate)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pageBlockAuthorDate)
		case PageBlockHeaderType:
			var pageBlockHeader PageBlockHeader
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pageBlockHeader)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pageBlockHeader)
		case PageBlockSubheaderType:
			var pageBlockSubheader PageBlockSubheader
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pageBlockSubheader)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pageBlockSubheader)
		case PageBlockKickerType:
			var pageBlockKicker PageBlockKicker
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pageBlockKicker)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pageBlockKicker)
		case PageBlockParagraphType:
			var pageBlockParagraph PageBlockParagraph
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pageBlockParagraph)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pageBlockParagraph)
		case PageBlockPreformattedType:
			var pageBlockPreformatted PageBlockPreformatted
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pageBlockPreformatted)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pageBlockPreformatted)
		case PageBlockFooterType:
			var pageBlockFooter PageBlockFooter
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pageBlockFooter)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pageBlockFooter)
		case PageBlockDividerType:
			var pageBlockDivider PageBlockDivider
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pageBlockDivider)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pageBlockDivider)
		case PageBlockAnchorType:
			var pageBlockAnchor PageBlockAnchor
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pageBlockAnchor)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pageBlockAnchor)
		case PageBlockListType:
			var pageBlockList PageBlockList
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pageBlockList)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pageBlockList)
		case PageBlockBlockQuoteType:
			var pageBlockBlockQuote PageBlockBlockQuote
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pageBlockBlockQuote)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pageBlockBlockQuote)
		case PageBlockPullQuoteType:
			var pageBlockPullQuote PageBlockPullQuote
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pageBlockPullQuote)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pageBlockPullQuote)
		case PageBlockAnimationType:
			var pageBlockAnimation PageBlockAnimation
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pageBlockAnimation)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pageBlockAnimation)
		case PageBlockAudioType:
			var pageBlockAudio PageBlockAudio
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pageBlockAudio)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pageBlockAudio)
		case PageBlockPhotoType:
			var pageBlockPhoto PageBlockPhoto
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pageBlockPhoto)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pageBlockPhoto)
		case PageBlockVideoType:
			var pageBlockVideo PageBlockVideo
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pageBlockVideo)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pageBlockVideo)
		case PageBlockVoiceNoteType:
			var pageBlockVoiceNote PageBlockVoiceNote
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pageBlockVoiceNote)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pageBlockVoiceNote)
		case PageBlockCoverType:
			var pageBlockCover PageBlockCover
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pageBlockCover)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pageBlockCover)
		case PageBlockEmbeddedType:
			var pageBlockEmbedded PageBlockEmbedded
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pageBlockEmbedded)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pageBlockEmbedded)
		case PageBlockEmbeddedPostType:
			var pageBlockEmbeddedPost PageBlockEmbeddedPost
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pageBlockEmbeddedPost)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pageBlockEmbeddedPost)
		case PageBlockCollageType:
			var pageBlockCollage PageBlockCollage
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pageBlockCollage)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pageBlockCollage)
		case PageBlockSlideshowType:
			var pageBlockSlideshow PageBlockSlideshow
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pageBlockSlideshow)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pageBlockSlideshow)
		case PageBlockChatLinkType:
			var pageBlockChatLink PageBlockChatLink
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pageBlockChatLink)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pageBlockChatLink)
		case PageBlockTableType:
			var pageBlockTable PageBlockTable
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pageBlockTable)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pageBlockTable)
		case PageBlockDetailsType:
			var pageBlockDetails PageBlockDetails
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pageBlockDetails)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pageBlockDetails)
		case PageBlockRelatedArticlesType:
			var pageBlockRelatedArticles PageBlockRelatedArticles
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pageBlockRelatedArticles)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pageBlockRelatedArticles)
		case PageBlockMapType:
			var pageBlockMap PageBlockMap
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pageBlockMap)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pageBlockMap)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// InputCredentials Contains information about the payment method chosen by the user
type InputCredentials interface {
	GetInputCredentialsEnum() InputCredentialsEnum
}

// InputCredentialsEnum Alias for abstract InputCredentials 'Sub-Classes', used as constant-enum here
type InputCredentialsEnum string

// InputCredentials enums
const (
	InputCredentialsSavedType     InputCredentialsEnum = "inputCredentialsSaved"
	InputCredentialsNewType       InputCredentialsEnum = "inputCredentialsNew"
	InputCredentialsApplePayType  InputCredentialsEnum = "inputCredentialsApplePay"
	InputCredentialsGooglePayType InputCredentialsEnum = "inputCredentialsGooglePay"
)

func unmarshalInputCredentials(rawMsg *json.RawMessage) (InputCredentials, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch InputCredentialsEnum(objMap["@type"].(string)) {
	case InputCredentialsSavedType:
		var inputCredentialsSaved InputCredentialsSaved
		err := json.Unmarshal(*rawMsg, &inputCredentialsSaved)
		return &inputCredentialsSaved, err

	case InputCredentialsNewType:
		var inputCredentialsNew InputCredentialsNew
		err := json.Unmarshal(*rawMsg, &inputCredentialsNew)
		return &inputCredentialsNew, err

	case InputCredentialsApplePayType:
		var inputCredentialsApplePay InputCredentialsApplePay
		err := json.Unmarshal(*rawMsg, &inputCredentialsApplePay)
		return &inputCredentialsApplePay, err

	case InputCredentialsGooglePayType:
		var inputCredentialsGooglePay InputCredentialsGooglePay
		err := json.Unmarshal(*rawMsg, &inputCredentialsGooglePay)
		return &inputCredentialsGooglePay, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalInputCredentialsSlice(rawMsg *json.RawMessage) ([]InputCredentials, error) {
	objects := make([]InputCredentials, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch InputCredentialsEnum(objMap["@type"].(string)) {
		case InputCredentialsSavedType:
			var inputCredentialsSaved InputCredentialsSaved
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputCredentialsSaved)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputCredentialsSaved)
		case InputCredentialsNewType:
			var inputCredentialsNew InputCredentialsNew
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputCredentialsNew)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputCredentialsNew)
		case InputCredentialsApplePayType:
			var inputCredentialsApplePay InputCredentialsApplePay
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputCredentialsApplePay)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputCredentialsApplePay)
		case InputCredentialsGooglePayType:
			var inputCredentialsGooglePay InputCredentialsGooglePay
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputCredentialsGooglePay)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputCredentialsGooglePay)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// PassportElementType Contains the type of a Telegram Passport element
type PassportElementType interface {
	GetPassportElementTypeEnum() PassportElementTypeEnum
}

// PassportElementTypeEnum Alias for abstract PassportElementType 'Sub-Classes', used as constant-enum here
type PassportElementTypeEnum string

// PassportElementType enums
const (
	PassportElementTypePersonalDetailsType       PassportElementTypeEnum = "passportElementTypePersonalDetails"
	PassportElementTypePassportType              PassportElementTypeEnum = "passportElementTypePassport"
	PassportElementTypeDriverLicenseType         PassportElementTypeEnum = "passportElementTypeDriverLicense"
	PassportElementTypeIDentityCardType          PassportElementTypeEnum = "passportElementTypeIdentityCard"
	PassportElementTypeInternalPassportType      PassportElementTypeEnum = "passportElementTypeInternalPassport"
	PassportElementTypeAddressType               PassportElementTypeEnum = "passportElementTypeAddress"
	PassportElementTypeUtilityBillType           PassportElementTypeEnum = "passportElementTypeUtilityBill"
	PassportElementTypeBankStatementType         PassportElementTypeEnum = "passportElementTypeBankStatement"
	PassportElementTypeRentalAgreementType       PassportElementTypeEnum = "passportElementTypeRentalAgreement"
	PassportElementTypePassportRegistrationType  PassportElementTypeEnum = "passportElementTypePassportRegistration"
	PassportElementTypeTemporaryRegistrationType PassportElementTypeEnum = "passportElementTypeTemporaryRegistration"
	PassportElementTypePhoneNumberType           PassportElementTypeEnum = "passportElementTypePhoneNumber"
	PassportElementTypeEmailAddressType          PassportElementTypeEnum = "passportElementTypeEmailAddress"
)

func unmarshalPassportElementType(rawMsg *json.RawMessage) (PassportElementType, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch PassportElementTypeEnum(objMap["@type"].(string)) {
	case PassportElementTypePersonalDetailsType:
		var passportElementTypePersonalDetails PassportElementTypePersonalDetails
		err := json.Unmarshal(*rawMsg, &passportElementTypePersonalDetails)
		return &passportElementTypePersonalDetails, err

	case PassportElementTypePassportType:
		var passportElementTypePassport PassportElementTypePassport
		err := json.Unmarshal(*rawMsg, &passportElementTypePassport)
		return &passportElementTypePassport, err

	case PassportElementTypeDriverLicenseType:
		var passportElementTypeDriverLicense PassportElementTypeDriverLicense
		err := json.Unmarshal(*rawMsg, &passportElementTypeDriverLicense)
		return &passportElementTypeDriverLicense, err

	case PassportElementTypeIDentityCardType:
		var passportElementTypeIDentityCard PassportElementTypeIDentityCard
		err := json.Unmarshal(*rawMsg, &passportElementTypeIDentityCard)
		return &passportElementTypeIDentityCard, err

	case PassportElementTypeInternalPassportType:
		var passportElementTypeInternalPassport PassportElementTypeInternalPassport
		err := json.Unmarshal(*rawMsg, &passportElementTypeInternalPassport)
		return &passportElementTypeInternalPassport, err

	case PassportElementTypeAddressType:
		var passportElementTypeAddress PassportElementTypeAddress
		err := json.Unmarshal(*rawMsg, &passportElementTypeAddress)
		return &passportElementTypeAddress, err

	case PassportElementTypeUtilityBillType:
		var passportElementTypeUtilityBill PassportElementTypeUtilityBill
		err := json.Unmarshal(*rawMsg, &passportElementTypeUtilityBill)
		return &passportElementTypeUtilityBill, err

	case PassportElementTypeBankStatementType:
		var passportElementTypeBankStatement PassportElementTypeBankStatement
		err := json.Unmarshal(*rawMsg, &passportElementTypeBankStatement)
		return &passportElementTypeBankStatement, err

	case PassportElementTypeRentalAgreementType:
		var passportElementTypeRentalAgreement PassportElementTypeRentalAgreement
		err := json.Unmarshal(*rawMsg, &passportElementTypeRentalAgreement)
		return &passportElementTypeRentalAgreement, err

	case PassportElementTypePassportRegistrationType:
		var passportElementTypePassportRegistration PassportElementTypePassportRegistration
		err := json.Unmarshal(*rawMsg, &passportElementTypePassportRegistration)
		return &passportElementTypePassportRegistration, err

	case PassportElementTypeTemporaryRegistrationType:
		var passportElementTypeTemporaryRegistration PassportElementTypeTemporaryRegistration
		err := json.Unmarshal(*rawMsg, &passportElementTypeTemporaryRegistration)
		return &passportElementTypeTemporaryRegistration, err

	case PassportElementTypePhoneNumberType:
		var passportElementTypePhoneNumber PassportElementTypePhoneNumber
		err := json.Unmarshal(*rawMsg, &passportElementTypePhoneNumber)
		return &passportElementTypePhoneNumber, err

	case PassportElementTypeEmailAddressType:
		var passportElementTypeEmailAddress PassportElementTypeEmailAddress
		err := json.Unmarshal(*rawMsg, &passportElementTypeEmailAddress)
		return &passportElementTypeEmailAddress, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalPassportElementTypeSlice(rawMsg *json.RawMessage) ([]PassportElementType, error) {
	objects := make([]PassportElementType, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch PassportElementTypeEnum(objMap["@type"].(string)) {
		case PassportElementTypePersonalDetailsType:
			var passportElementTypePersonalDetails PassportElementTypePersonalDetails
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &passportElementTypePersonalDetails)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &passportElementTypePersonalDetails)
		case PassportElementTypePassportType:
			var passportElementTypePassport PassportElementTypePassport
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &passportElementTypePassport)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &passportElementTypePassport)
		case PassportElementTypeDriverLicenseType:
			var passportElementTypeDriverLicense PassportElementTypeDriverLicense
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &passportElementTypeDriverLicense)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &passportElementTypeDriverLicense)
		case PassportElementTypeIDentityCardType:
			var passportElementTypeIDentityCard PassportElementTypeIDentityCard
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &passportElementTypeIDentityCard)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &passportElementTypeIDentityCard)
		case PassportElementTypeInternalPassportType:
			var passportElementTypeInternalPassport PassportElementTypeInternalPassport
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &passportElementTypeInternalPassport)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &passportElementTypeInternalPassport)
		case PassportElementTypeAddressType:
			var passportElementTypeAddress PassportElementTypeAddress
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &passportElementTypeAddress)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &passportElementTypeAddress)
		case PassportElementTypeUtilityBillType:
			var passportElementTypeUtilityBill PassportElementTypeUtilityBill
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &passportElementTypeUtilityBill)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &passportElementTypeUtilityBill)
		case PassportElementTypeBankStatementType:
			var passportElementTypeBankStatement PassportElementTypeBankStatement
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &passportElementTypeBankStatement)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &passportElementTypeBankStatement)
		case PassportElementTypeRentalAgreementType:
			var passportElementTypeRentalAgreement PassportElementTypeRentalAgreement
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &passportElementTypeRentalAgreement)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &passportElementTypeRentalAgreement)
		case PassportElementTypePassportRegistrationType:
			var passportElementTypePassportRegistration PassportElementTypePassportRegistration
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &passportElementTypePassportRegistration)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &passportElementTypePassportRegistration)
		case PassportElementTypeTemporaryRegistrationType:
			var passportElementTypeTemporaryRegistration PassportElementTypeTemporaryRegistration
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &passportElementTypeTemporaryRegistration)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &passportElementTypeTemporaryRegistration)
		case PassportElementTypePhoneNumberType:
			var passportElementTypePhoneNumber PassportElementTypePhoneNumber
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &passportElementTypePhoneNumber)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &passportElementTypePhoneNumber)
		case PassportElementTypeEmailAddressType:
			var passportElementTypeEmailAddress PassportElementTypeEmailAddress
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &passportElementTypeEmailAddress)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &passportElementTypeEmailAddress)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// PassportElement Contains information about a Telegram Passport element
type PassportElement interface {
	GetPassportElementEnum() PassportElementEnum
}

// PassportElementEnum Alias for abstract PassportElement 'Sub-Classes', used as constant-enum here
type PassportElementEnum string

// PassportElement enums
const (
	PassportElementPersonalDetailsType       PassportElementEnum = "passportElementPersonalDetails"
	PassportElementPassportType              PassportElementEnum = "passportElementPassport"
	PassportElementDriverLicenseType         PassportElementEnum = "passportElementDriverLicense"
	PassportElementIDentityCardType          PassportElementEnum = "passportElementIdentityCard"
	PassportElementInternalPassportType      PassportElementEnum = "passportElementInternalPassport"
	PassportElementAddressType               PassportElementEnum = "passportElementAddress"
	PassportElementUtilityBillType           PassportElementEnum = "passportElementUtilityBill"
	PassportElementBankStatementType         PassportElementEnum = "passportElementBankStatement"
	PassportElementRentalAgreementType       PassportElementEnum = "passportElementRentalAgreement"
	PassportElementPassportRegistrationType  PassportElementEnum = "passportElementPassportRegistration"
	PassportElementTemporaryRegistrationType PassportElementEnum = "passportElementTemporaryRegistration"
	PassportElementPhoneNumberType           PassportElementEnum = "passportElementPhoneNumber"
	PassportElementEmailAddressType          PassportElementEnum = "passportElementEmailAddress"
)

func unmarshalPassportElement(rawMsg *json.RawMessage) (PassportElement, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch PassportElementEnum(objMap["@type"].(string)) {
	case PassportElementPersonalDetailsType:
		var passportElementPersonalDetails PassportElementPersonalDetails
		err := json.Unmarshal(*rawMsg, &passportElementPersonalDetails)
		return &passportElementPersonalDetails, err

	case PassportElementPassportType:
		var passportElementPassport PassportElementPassport
		err := json.Unmarshal(*rawMsg, &passportElementPassport)
		return &passportElementPassport, err

	case PassportElementDriverLicenseType:
		var passportElementDriverLicense PassportElementDriverLicense
		err := json.Unmarshal(*rawMsg, &passportElementDriverLicense)
		return &passportElementDriverLicense, err

	case PassportElementIDentityCardType:
		var passportElementIDentityCard PassportElementIDentityCard
		err := json.Unmarshal(*rawMsg, &passportElementIDentityCard)
		return &passportElementIDentityCard, err

	case PassportElementInternalPassportType:
		var passportElementInternalPassport PassportElementInternalPassport
		err := json.Unmarshal(*rawMsg, &passportElementInternalPassport)
		return &passportElementInternalPassport, err

	case PassportElementAddressType:
		var passportElementAddress PassportElementAddress
		err := json.Unmarshal(*rawMsg, &passportElementAddress)
		return &passportElementAddress, err

	case PassportElementUtilityBillType:
		var passportElementUtilityBill PassportElementUtilityBill
		err := json.Unmarshal(*rawMsg, &passportElementUtilityBill)
		return &passportElementUtilityBill, err

	case PassportElementBankStatementType:
		var passportElementBankStatement PassportElementBankStatement
		err := json.Unmarshal(*rawMsg, &passportElementBankStatement)
		return &passportElementBankStatement, err

	case PassportElementRentalAgreementType:
		var passportElementRentalAgreement PassportElementRentalAgreement
		err := json.Unmarshal(*rawMsg, &passportElementRentalAgreement)
		return &passportElementRentalAgreement, err

	case PassportElementPassportRegistrationType:
		var passportElementPassportRegistration PassportElementPassportRegistration
		err := json.Unmarshal(*rawMsg, &passportElementPassportRegistration)
		return &passportElementPassportRegistration, err

	case PassportElementTemporaryRegistrationType:
		var passportElementTemporaryRegistration PassportElementTemporaryRegistration
		err := json.Unmarshal(*rawMsg, &passportElementTemporaryRegistration)
		return &passportElementTemporaryRegistration, err

	case PassportElementPhoneNumberType:
		var passportElementPhoneNumber PassportElementPhoneNumber
		err := json.Unmarshal(*rawMsg, &passportElementPhoneNumber)
		return &passportElementPhoneNumber, err

	case PassportElementEmailAddressType:
		var passportElementEmailAddress PassportElementEmailAddress
		err := json.Unmarshal(*rawMsg, &passportElementEmailAddress)
		return &passportElementEmailAddress, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalPassportElementSlice(rawMsg *json.RawMessage) ([]PassportElement, error) {
	objects := make([]PassportElement, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch PassportElementEnum(objMap["@type"].(string)) {
		case PassportElementPersonalDetailsType:
			var passportElementPersonalDetails PassportElementPersonalDetails
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &passportElementPersonalDetails)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &passportElementPersonalDetails)
		case PassportElementPassportType:
			var passportElementPassport PassportElementPassport
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &passportElementPassport)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &passportElementPassport)
		case PassportElementDriverLicenseType:
			var passportElementDriverLicense PassportElementDriverLicense
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &passportElementDriverLicense)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &passportElementDriverLicense)
		case PassportElementIDentityCardType:
			var passportElementIDentityCard PassportElementIDentityCard
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &passportElementIDentityCard)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &passportElementIDentityCard)
		case PassportElementInternalPassportType:
			var passportElementInternalPassport PassportElementInternalPassport
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &passportElementInternalPassport)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &passportElementInternalPassport)
		case PassportElementAddressType:
			var passportElementAddress PassportElementAddress
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &passportElementAddress)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &passportElementAddress)
		case PassportElementUtilityBillType:
			var passportElementUtilityBill PassportElementUtilityBill
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &passportElementUtilityBill)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &passportElementUtilityBill)
		case PassportElementBankStatementType:
			var passportElementBankStatement PassportElementBankStatement
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &passportElementBankStatement)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &passportElementBankStatement)
		case PassportElementRentalAgreementType:
			var passportElementRentalAgreement PassportElementRentalAgreement
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &passportElementRentalAgreement)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &passportElementRentalAgreement)
		case PassportElementPassportRegistrationType:
			var passportElementPassportRegistration PassportElementPassportRegistration
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &passportElementPassportRegistration)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &passportElementPassportRegistration)
		case PassportElementTemporaryRegistrationType:
			var passportElementTemporaryRegistration PassportElementTemporaryRegistration
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &passportElementTemporaryRegistration)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &passportElementTemporaryRegistration)
		case PassportElementPhoneNumberType:
			var passportElementPhoneNumber PassportElementPhoneNumber
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &passportElementPhoneNumber)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &passportElementPhoneNumber)
		case PassportElementEmailAddressType:
			var passportElementEmailAddress PassportElementEmailAddress
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &passportElementEmailAddress)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &passportElementEmailAddress)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// InputPassportElement Contains information about a Telegram Passport element to be saved
type InputPassportElement interface {
	GetInputPassportElementEnum() InputPassportElementEnum
}

// InputPassportElementEnum Alias for abstract InputPassportElement 'Sub-Classes', used as constant-enum here
type InputPassportElementEnum string

// InputPassportElement enums
const (
	InputPassportElementPersonalDetailsType       InputPassportElementEnum = "inputPassportElementPersonalDetails"
	InputPassportElementPassportType              InputPassportElementEnum = "inputPassportElementPassport"
	InputPassportElementDriverLicenseType         InputPassportElementEnum = "inputPassportElementDriverLicense"
	InputPassportElementIDentityCardType          InputPassportElementEnum = "inputPassportElementIdentityCard"
	InputPassportElementInternalPassportType      InputPassportElementEnum = "inputPassportElementInternalPassport"
	InputPassportElementAddressType               InputPassportElementEnum = "inputPassportElementAddress"
	InputPassportElementUtilityBillType           InputPassportElementEnum = "inputPassportElementUtilityBill"
	InputPassportElementBankStatementType         InputPassportElementEnum = "inputPassportElementBankStatement"
	InputPassportElementRentalAgreementType       InputPassportElementEnum = "inputPassportElementRentalAgreement"
	InputPassportElementPassportRegistrationType  InputPassportElementEnum = "inputPassportElementPassportRegistration"
	InputPassportElementTemporaryRegistrationType InputPassportElementEnum = "inputPassportElementTemporaryRegistration"
	InputPassportElementPhoneNumberType           InputPassportElementEnum = "inputPassportElementPhoneNumber"
	InputPassportElementEmailAddressType          InputPassportElementEnum = "inputPassportElementEmailAddress"
)

func unmarshalInputPassportElement(rawMsg *json.RawMessage) (InputPassportElement, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch InputPassportElementEnum(objMap["@type"].(string)) {
	case InputPassportElementPersonalDetailsType:
		var inputPassportElementPersonalDetails InputPassportElementPersonalDetails
		err := json.Unmarshal(*rawMsg, &inputPassportElementPersonalDetails)
		return &inputPassportElementPersonalDetails, err

	case InputPassportElementPassportType:
		var inputPassportElementPassport InputPassportElementPassport
		err := json.Unmarshal(*rawMsg, &inputPassportElementPassport)
		return &inputPassportElementPassport, err

	case InputPassportElementDriverLicenseType:
		var inputPassportElementDriverLicense InputPassportElementDriverLicense
		err := json.Unmarshal(*rawMsg, &inputPassportElementDriverLicense)
		return &inputPassportElementDriverLicense, err

	case InputPassportElementIDentityCardType:
		var inputPassportElementIDentityCard InputPassportElementIDentityCard
		err := json.Unmarshal(*rawMsg, &inputPassportElementIDentityCard)
		return &inputPassportElementIDentityCard, err

	case InputPassportElementInternalPassportType:
		var inputPassportElementInternalPassport InputPassportElementInternalPassport
		err := json.Unmarshal(*rawMsg, &inputPassportElementInternalPassport)
		return &inputPassportElementInternalPassport, err

	case InputPassportElementAddressType:
		var inputPassportElementAddress InputPassportElementAddress
		err := json.Unmarshal(*rawMsg, &inputPassportElementAddress)
		return &inputPassportElementAddress, err

	case InputPassportElementUtilityBillType:
		var inputPassportElementUtilityBill InputPassportElementUtilityBill
		err := json.Unmarshal(*rawMsg, &inputPassportElementUtilityBill)
		return &inputPassportElementUtilityBill, err

	case InputPassportElementBankStatementType:
		var inputPassportElementBankStatement InputPassportElementBankStatement
		err := json.Unmarshal(*rawMsg, &inputPassportElementBankStatement)
		return &inputPassportElementBankStatement, err

	case InputPassportElementRentalAgreementType:
		var inputPassportElementRentalAgreement InputPassportElementRentalAgreement
		err := json.Unmarshal(*rawMsg, &inputPassportElementRentalAgreement)
		return &inputPassportElementRentalAgreement, err

	case InputPassportElementPassportRegistrationType:
		var inputPassportElementPassportRegistration InputPassportElementPassportRegistration
		err := json.Unmarshal(*rawMsg, &inputPassportElementPassportRegistration)
		return &inputPassportElementPassportRegistration, err

	case InputPassportElementTemporaryRegistrationType:
		var inputPassportElementTemporaryRegistration InputPassportElementTemporaryRegistration
		err := json.Unmarshal(*rawMsg, &inputPassportElementTemporaryRegistration)
		return &inputPassportElementTemporaryRegistration, err

	case InputPassportElementPhoneNumberType:
		var inputPassportElementPhoneNumber InputPassportElementPhoneNumber
		err := json.Unmarshal(*rawMsg, &inputPassportElementPhoneNumber)
		return &inputPassportElementPhoneNumber, err

	case InputPassportElementEmailAddressType:
		var inputPassportElementEmailAddress InputPassportElementEmailAddress
		err := json.Unmarshal(*rawMsg, &inputPassportElementEmailAddress)
		return &inputPassportElementEmailAddress, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalInputPassportElementSlice(rawMsg *json.RawMessage) ([]InputPassportElement, error) {
	objects := make([]InputPassportElement, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch InputPassportElementEnum(objMap["@type"].(string)) {
		case InputPassportElementPersonalDetailsType:
			var inputPassportElementPersonalDetails InputPassportElementPersonalDetails
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputPassportElementPersonalDetails)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputPassportElementPersonalDetails)
		case InputPassportElementPassportType:
			var inputPassportElementPassport InputPassportElementPassport
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputPassportElementPassport)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputPassportElementPassport)
		case InputPassportElementDriverLicenseType:
			var inputPassportElementDriverLicense InputPassportElementDriverLicense
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputPassportElementDriverLicense)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputPassportElementDriverLicense)
		case InputPassportElementIDentityCardType:
			var inputPassportElementIDentityCard InputPassportElementIDentityCard
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputPassportElementIDentityCard)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputPassportElementIDentityCard)
		case InputPassportElementInternalPassportType:
			var inputPassportElementInternalPassport InputPassportElementInternalPassport
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputPassportElementInternalPassport)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputPassportElementInternalPassport)
		case InputPassportElementAddressType:
			var inputPassportElementAddress InputPassportElementAddress
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputPassportElementAddress)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputPassportElementAddress)
		case InputPassportElementUtilityBillType:
			var inputPassportElementUtilityBill InputPassportElementUtilityBill
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputPassportElementUtilityBill)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputPassportElementUtilityBill)
		case InputPassportElementBankStatementType:
			var inputPassportElementBankStatement InputPassportElementBankStatement
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputPassportElementBankStatement)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputPassportElementBankStatement)
		case InputPassportElementRentalAgreementType:
			var inputPassportElementRentalAgreement InputPassportElementRentalAgreement
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputPassportElementRentalAgreement)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputPassportElementRentalAgreement)
		case InputPassportElementPassportRegistrationType:
			var inputPassportElementPassportRegistration InputPassportElementPassportRegistration
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputPassportElementPassportRegistration)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputPassportElementPassportRegistration)
		case InputPassportElementTemporaryRegistrationType:
			var inputPassportElementTemporaryRegistration InputPassportElementTemporaryRegistration
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputPassportElementTemporaryRegistration)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputPassportElementTemporaryRegistration)
		case InputPassportElementPhoneNumberType:
			var inputPassportElementPhoneNumber InputPassportElementPhoneNumber
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputPassportElementPhoneNumber)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputPassportElementPhoneNumber)
		case InputPassportElementEmailAddressType:
			var inputPassportElementEmailAddress InputPassportElementEmailAddress
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputPassportElementEmailAddress)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputPassportElementEmailAddress)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// PassportElementErrorSource Contains the description of an error in a Telegram Passport element
type PassportElementErrorSource interface {
	GetPassportElementErrorSourceEnum() PassportElementErrorSourceEnum
}

// PassportElementErrorSourceEnum Alias for abstract PassportElementErrorSource 'Sub-Classes', used as constant-enum here
type PassportElementErrorSourceEnum string

// PassportElementErrorSource enums
const (
	PassportElementErrorSourceUnspecifiedType      PassportElementErrorSourceEnum = "passportElementErrorSourceUnspecified"
	PassportElementErrorSourceDataFieldType        PassportElementErrorSourceEnum = "passportElementErrorSourceDataField"
	PassportElementErrorSourceFrontSideType        PassportElementErrorSourceEnum = "passportElementErrorSourceFrontSide"
	PassportElementErrorSourceReverseSideType      PassportElementErrorSourceEnum = "passportElementErrorSourceReverseSide"
	PassportElementErrorSourceSelfieType           PassportElementErrorSourceEnum = "passportElementErrorSourceSelfie"
	PassportElementErrorSourceTranslationFileType  PassportElementErrorSourceEnum = "passportElementErrorSourceTranslationFile"
	PassportElementErrorSourceTranslationFilesType PassportElementErrorSourceEnum = "passportElementErrorSourceTranslationFiles"
	PassportElementErrorSourceFileType             PassportElementErrorSourceEnum = "passportElementErrorSourceFile"
	PassportElementErrorSourceFilesType            PassportElementErrorSourceEnum = "passportElementErrorSourceFiles"
)

func unmarshalPassportElementErrorSource(rawMsg *json.RawMessage) (PassportElementErrorSource, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch PassportElementErrorSourceEnum(objMap["@type"].(string)) {
	case PassportElementErrorSourceUnspecifiedType:
		var passportElementErrorSourceUnspecified PassportElementErrorSourceUnspecified
		err := json.Unmarshal(*rawMsg, &passportElementErrorSourceUnspecified)
		return &passportElementErrorSourceUnspecified, err

	case PassportElementErrorSourceDataFieldType:
		var passportElementErrorSourceDataField PassportElementErrorSourceDataField
		err := json.Unmarshal(*rawMsg, &passportElementErrorSourceDataField)
		return &passportElementErrorSourceDataField, err

	case PassportElementErrorSourceFrontSideType:
		var passportElementErrorSourceFrontSide PassportElementErrorSourceFrontSide
		err := json.Unmarshal(*rawMsg, &passportElementErrorSourceFrontSide)
		return &passportElementErrorSourceFrontSide, err

	case PassportElementErrorSourceReverseSideType:
		var passportElementErrorSourceReverseSide PassportElementErrorSourceReverseSide
		err := json.Unmarshal(*rawMsg, &passportElementErrorSourceReverseSide)
		return &passportElementErrorSourceReverseSide, err

	case PassportElementErrorSourceSelfieType:
		var passportElementErrorSourceSelfie PassportElementErrorSourceSelfie
		err := json.Unmarshal(*rawMsg, &passportElementErrorSourceSelfie)
		return &passportElementErrorSourceSelfie, err

	case PassportElementErrorSourceTranslationFileType:
		var passportElementErrorSourceTranslationFile PassportElementErrorSourceTranslationFile
		err := json.Unmarshal(*rawMsg, &passportElementErrorSourceTranslationFile)
		return &passportElementErrorSourceTranslationFile, err

	case PassportElementErrorSourceTranslationFilesType:
		var passportElementErrorSourceTranslationFiles PassportElementErrorSourceTranslationFiles
		err := json.Unmarshal(*rawMsg, &passportElementErrorSourceTranslationFiles)
		return &passportElementErrorSourceTranslationFiles, err

	case PassportElementErrorSourceFileType:
		var passportElementErrorSourceFile PassportElementErrorSourceFile
		err := json.Unmarshal(*rawMsg, &passportElementErrorSourceFile)
		return &passportElementErrorSourceFile, err

	case PassportElementErrorSourceFilesType:
		var passportElementErrorSourceFiles PassportElementErrorSourceFiles
		err := json.Unmarshal(*rawMsg, &passportElementErrorSourceFiles)
		return &passportElementErrorSourceFiles, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalPassportElementErrorSourceSlice(rawMsg *json.RawMessage) ([]PassportElementErrorSource, error) {
	objects := make([]PassportElementErrorSource, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch PassportElementErrorSourceEnum(objMap["@type"].(string)) {
		case PassportElementErrorSourceUnspecifiedType:
			var passportElementErrorSourceUnspecified PassportElementErrorSourceUnspecified
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &passportElementErrorSourceUnspecified)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &passportElementErrorSourceUnspecified)
		case PassportElementErrorSourceDataFieldType:
			var passportElementErrorSourceDataField PassportElementErrorSourceDataField
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &passportElementErrorSourceDataField)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &passportElementErrorSourceDataField)
		case PassportElementErrorSourceFrontSideType:
			var passportElementErrorSourceFrontSide PassportElementErrorSourceFrontSide
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &passportElementErrorSourceFrontSide)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &passportElementErrorSourceFrontSide)
		case PassportElementErrorSourceReverseSideType:
			var passportElementErrorSourceReverseSide PassportElementErrorSourceReverseSide
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &passportElementErrorSourceReverseSide)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &passportElementErrorSourceReverseSide)
		case PassportElementErrorSourceSelfieType:
			var passportElementErrorSourceSelfie PassportElementErrorSourceSelfie
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &passportElementErrorSourceSelfie)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &passportElementErrorSourceSelfie)
		case PassportElementErrorSourceTranslationFileType:
			var passportElementErrorSourceTranslationFile PassportElementErrorSourceTranslationFile
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &passportElementErrorSourceTranslationFile)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &passportElementErrorSourceTranslationFile)
		case PassportElementErrorSourceTranslationFilesType:
			var passportElementErrorSourceTranslationFiles PassportElementErrorSourceTranslationFiles
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &passportElementErrorSourceTranslationFiles)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &passportElementErrorSourceTranslationFiles)
		case PassportElementErrorSourceFileType:
			var passportElementErrorSourceFile PassportElementErrorSourceFile
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &passportElementErrorSourceFile)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &passportElementErrorSourceFile)
		case PassportElementErrorSourceFilesType:
			var passportElementErrorSourceFiles PassportElementErrorSourceFiles
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &passportElementErrorSourceFiles)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &passportElementErrorSourceFiles)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// InputPassportElementErrorSource Contains the description of an error in a Telegram Passport element; for bots only
type InputPassportElementErrorSource interface {
	GetInputPassportElementErrorSourceEnum() InputPassportElementErrorSourceEnum
}

// InputPassportElementErrorSourceEnum Alias for abstract InputPassportElementErrorSource 'Sub-Classes', used as constant-enum here
type InputPassportElementErrorSourceEnum string

// InputPassportElementErrorSource enums
const (
	InputPassportElementErrorSourceUnspecifiedType      InputPassportElementErrorSourceEnum = "inputPassportElementErrorSourceUnspecified"
	InputPassportElementErrorSourceDataFieldType        InputPassportElementErrorSourceEnum = "inputPassportElementErrorSourceDataField"
	InputPassportElementErrorSourceFrontSideType        InputPassportElementErrorSourceEnum = "inputPassportElementErrorSourceFrontSide"
	InputPassportElementErrorSourceReverseSideType      InputPassportElementErrorSourceEnum = "inputPassportElementErrorSourceReverseSide"
	InputPassportElementErrorSourceSelfieType           InputPassportElementErrorSourceEnum = "inputPassportElementErrorSourceSelfie"
	InputPassportElementErrorSourceTranslationFileType  InputPassportElementErrorSourceEnum = "inputPassportElementErrorSourceTranslationFile"
	InputPassportElementErrorSourceTranslationFilesType InputPassportElementErrorSourceEnum = "inputPassportElementErrorSourceTranslationFiles"
	InputPassportElementErrorSourceFileType             InputPassportElementErrorSourceEnum = "inputPassportElementErrorSourceFile"
	InputPassportElementErrorSourceFilesType            InputPassportElementErrorSourceEnum = "inputPassportElementErrorSourceFiles"
)

func unmarshalInputPassportElementErrorSource(rawMsg *json.RawMessage) (InputPassportElementErrorSource, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch InputPassportElementErrorSourceEnum(objMap["@type"].(string)) {
	case InputPassportElementErrorSourceUnspecifiedType:
		var inputPassportElementErrorSourceUnspecified InputPassportElementErrorSourceUnspecified
		err := json.Unmarshal(*rawMsg, &inputPassportElementErrorSourceUnspecified)
		return &inputPassportElementErrorSourceUnspecified, err

	case InputPassportElementErrorSourceDataFieldType:
		var inputPassportElementErrorSourceDataField InputPassportElementErrorSourceDataField
		err := json.Unmarshal(*rawMsg, &inputPassportElementErrorSourceDataField)
		return &inputPassportElementErrorSourceDataField, err

	case InputPassportElementErrorSourceFrontSideType:
		var inputPassportElementErrorSourceFrontSide InputPassportElementErrorSourceFrontSide
		err := json.Unmarshal(*rawMsg, &inputPassportElementErrorSourceFrontSide)
		return &inputPassportElementErrorSourceFrontSide, err

	case InputPassportElementErrorSourceReverseSideType:
		var inputPassportElementErrorSourceReverseSide InputPassportElementErrorSourceReverseSide
		err := json.Unmarshal(*rawMsg, &inputPassportElementErrorSourceReverseSide)
		return &inputPassportElementErrorSourceReverseSide, err

	case InputPassportElementErrorSourceSelfieType:
		var inputPassportElementErrorSourceSelfie InputPassportElementErrorSourceSelfie
		err := json.Unmarshal(*rawMsg, &inputPassportElementErrorSourceSelfie)
		return &inputPassportElementErrorSourceSelfie, err

	case InputPassportElementErrorSourceTranslationFileType:
		var inputPassportElementErrorSourceTranslationFile InputPassportElementErrorSourceTranslationFile
		err := json.Unmarshal(*rawMsg, &inputPassportElementErrorSourceTranslationFile)
		return &inputPassportElementErrorSourceTranslationFile, err

	case InputPassportElementErrorSourceTranslationFilesType:
		var inputPassportElementErrorSourceTranslationFiles InputPassportElementErrorSourceTranslationFiles
		err := json.Unmarshal(*rawMsg, &inputPassportElementErrorSourceTranslationFiles)
		return &inputPassportElementErrorSourceTranslationFiles, err

	case InputPassportElementErrorSourceFileType:
		var inputPassportElementErrorSourceFile InputPassportElementErrorSourceFile
		err := json.Unmarshal(*rawMsg, &inputPassportElementErrorSourceFile)
		return &inputPassportElementErrorSourceFile, err

	case InputPassportElementErrorSourceFilesType:
		var inputPassportElementErrorSourceFiles InputPassportElementErrorSourceFiles
		err := json.Unmarshal(*rawMsg, &inputPassportElementErrorSourceFiles)
		return &inputPassportElementErrorSourceFiles, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalInputPassportElementErrorSourceSlice(rawMsg *json.RawMessage) ([]InputPassportElementErrorSource, error) {
	objects := make([]InputPassportElementErrorSource, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch InputPassportElementErrorSourceEnum(objMap["@type"].(string)) {
		case InputPassportElementErrorSourceUnspecifiedType:
			var inputPassportElementErrorSourceUnspecified InputPassportElementErrorSourceUnspecified
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputPassportElementErrorSourceUnspecified)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputPassportElementErrorSourceUnspecified)
		case InputPassportElementErrorSourceDataFieldType:
			var inputPassportElementErrorSourceDataField InputPassportElementErrorSourceDataField
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputPassportElementErrorSourceDataField)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputPassportElementErrorSourceDataField)
		case InputPassportElementErrorSourceFrontSideType:
			var inputPassportElementErrorSourceFrontSide InputPassportElementErrorSourceFrontSide
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputPassportElementErrorSourceFrontSide)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputPassportElementErrorSourceFrontSide)
		case InputPassportElementErrorSourceReverseSideType:
			var inputPassportElementErrorSourceReverseSide InputPassportElementErrorSourceReverseSide
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputPassportElementErrorSourceReverseSide)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputPassportElementErrorSourceReverseSide)
		case InputPassportElementErrorSourceSelfieType:
			var inputPassportElementErrorSourceSelfie InputPassportElementErrorSourceSelfie
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputPassportElementErrorSourceSelfie)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputPassportElementErrorSourceSelfie)
		case InputPassportElementErrorSourceTranslationFileType:
			var inputPassportElementErrorSourceTranslationFile InputPassportElementErrorSourceTranslationFile
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputPassportElementErrorSourceTranslationFile)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputPassportElementErrorSourceTranslationFile)
		case InputPassportElementErrorSourceTranslationFilesType:
			var inputPassportElementErrorSourceTranslationFiles InputPassportElementErrorSourceTranslationFiles
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputPassportElementErrorSourceTranslationFiles)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputPassportElementErrorSourceTranslationFiles)
		case InputPassportElementErrorSourceFileType:
			var inputPassportElementErrorSourceFile InputPassportElementErrorSourceFile
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputPassportElementErrorSourceFile)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputPassportElementErrorSourceFile)
		case InputPassportElementErrorSourceFilesType:
			var inputPassportElementErrorSourceFiles InputPassportElementErrorSourceFiles
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputPassportElementErrorSourceFiles)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputPassportElementErrorSourceFiles)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// MessageContent Contains the content of a message
type MessageContent interface {
	GetMessageContentEnum() MessageContentEnum
}

// MessageContentEnum Alias for abstract MessageContent 'Sub-Classes', used as constant-enum here
type MessageContentEnum string

// MessageContent enums
const (
	MessageTextType                        MessageContentEnum = "messageText"
	MessageAnimationType                   MessageContentEnum = "messageAnimation"
	MessageAudioType                       MessageContentEnum = "messageAudio"
	MessageDocumentType                    MessageContentEnum = "messageDocument"
	MessagePhotoType                       MessageContentEnum = "messagePhoto"
	MessageExpiredPhotoType                MessageContentEnum = "messageExpiredPhoto"
	MessageStickerType                     MessageContentEnum = "messageSticker"
	MessageVideoType                       MessageContentEnum = "messageVideo"
	MessageExpiredVideoType                MessageContentEnum = "messageExpiredVideo"
	MessageVideoNoteType                   MessageContentEnum = "messageVideoNote"
	MessageVoiceNoteType                   MessageContentEnum = "messageVoiceNote"
	MessageLocationType                    MessageContentEnum = "messageLocation"
	MessageVenueType                       MessageContentEnum = "messageVenue"
	MessageContactType                     MessageContentEnum = "messageContact"
	MessageAnimatedEmojiType               MessageContentEnum = "messageAnimatedEmoji"
	MessageDiceType                        MessageContentEnum = "messageDice"
	MessageGameType                        MessageContentEnum = "messageGame"
	MessagePollType                        MessageContentEnum = "messagePoll"
	MessageInvoiceType                     MessageContentEnum = "messageInvoice"
	MessageCallType                        MessageContentEnum = "messageCall"
	MessageVideoChatScheduledType          MessageContentEnum = "messageVideoChatScheduled"
	MessageVideoChatStartedType            MessageContentEnum = "messageVideoChatStarted"
	MessageVideoChatEndedType              MessageContentEnum = "messageVideoChatEnded"
	MessageInviteVideoChatParticipantsType MessageContentEnum = "messageInviteVideoChatParticipants"
	MessageBasicGroupChatCreateType        MessageContentEnum = "messageBasicGroupChatCreate"
	MessageSupergroupChatCreateType        MessageContentEnum = "messageSupergroupChatCreate"
	MessageChatChangeTitleType             MessageContentEnum = "messageChatChangeTitle"
	MessageChatChangePhotoType             MessageContentEnum = "messageChatChangePhoto"
	MessageChatDeletePhotoType             MessageContentEnum = "messageChatDeletePhoto"
	MessageChatAddMembersType              MessageContentEnum = "messageChatAddMembers"
	MessageChatJoinByLinkType              MessageContentEnum = "messageChatJoinByLink"
	MessageChatJoinByRequestType           MessageContentEnum = "messageChatJoinByRequest"
	MessageChatDeleteMemberType            MessageContentEnum = "messageChatDeleteMember"
	MessageChatUpgradeToType               MessageContentEnum = "messageChatUpgradeTo"
	MessageChatUpgradeFromType             MessageContentEnum = "messageChatUpgradeFrom"
	MessagePinMessageType                  MessageContentEnum = "messagePinMessage"
	MessageScreenshotTakenType             MessageContentEnum = "messageScreenshotTaken"
	MessageChatSetThemeType                MessageContentEnum = "messageChatSetTheme"
	MessageChatSetTTLType                  MessageContentEnum = "messageChatSetTtl"
	MessageCustomServiceActionType         MessageContentEnum = "messageCustomServiceAction"
	MessageGameScoreType                   MessageContentEnum = "messageGameScore"
	MessagePaymentSuccessfulType           MessageContentEnum = "messagePaymentSuccessful"
	MessagePaymentSuccessfulBotType        MessageContentEnum = "messagePaymentSuccessfulBot"
	MessageContactRegisteredType           MessageContentEnum = "messageContactRegistered"
	MessageWebsiteConnectedType            MessageContentEnum = "messageWebsiteConnected"
	MessagePassportDataSentType            MessageContentEnum = "messagePassportDataSent"
	MessagePassportDataReceivedType        MessageContentEnum = "messagePassportDataReceived"
	MessageProximityAlertTriggeredType     MessageContentEnum = "messageProximityAlertTriggered"
	MessageUnsupportedType                 MessageContentEnum = "messageUnsupported"
)

func unmarshalMessageContent(rawMsg *json.RawMessage) (MessageContent, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch MessageContentEnum(objMap["@type"].(string)) {
	case MessageTextType:
		var messageText MessageText
		err := json.Unmarshal(*rawMsg, &messageText)
		return &messageText, err

	case MessageAnimationType:
		var messageAnimation MessageAnimation
		err := json.Unmarshal(*rawMsg, &messageAnimation)
		return &messageAnimation, err

	case MessageAudioType:
		var messageAudio MessageAudio
		err := json.Unmarshal(*rawMsg, &messageAudio)
		return &messageAudio, err

	case MessageDocumentType:
		var messageDocument MessageDocument
		err := json.Unmarshal(*rawMsg, &messageDocument)
		return &messageDocument, err

	case MessagePhotoType:
		var messagePhoto MessagePhoto
		err := json.Unmarshal(*rawMsg, &messagePhoto)
		return &messagePhoto, err

	case MessageExpiredPhotoType:
		var messageExpiredPhoto MessageExpiredPhoto
		err := json.Unmarshal(*rawMsg, &messageExpiredPhoto)
		return &messageExpiredPhoto, err

	case MessageStickerType:
		var messageSticker MessageSticker
		err := json.Unmarshal(*rawMsg, &messageSticker)
		return &messageSticker, err

	case MessageVideoType:
		var messageVideo MessageVideo
		err := json.Unmarshal(*rawMsg, &messageVideo)
		return &messageVideo, err

	case MessageExpiredVideoType:
		var messageExpiredVideo MessageExpiredVideo
		err := json.Unmarshal(*rawMsg, &messageExpiredVideo)
		return &messageExpiredVideo, err

	case MessageVideoNoteType:
		var messageVideoNote MessageVideoNote
		err := json.Unmarshal(*rawMsg, &messageVideoNote)
		return &messageVideoNote, err

	case MessageVoiceNoteType:
		var messageVoiceNote MessageVoiceNote
		err := json.Unmarshal(*rawMsg, &messageVoiceNote)
		return &messageVoiceNote, err

	case MessageLocationType:
		var messageLocation MessageLocation
		err := json.Unmarshal(*rawMsg, &messageLocation)
		return &messageLocation, err

	case MessageVenueType:
		var messageVenue MessageVenue
		err := json.Unmarshal(*rawMsg, &messageVenue)
		return &messageVenue, err

	case MessageContactType:
		var messageContact MessageContact
		err := json.Unmarshal(*rawMsg, &messageContact)
		return &messageContact, err

	case MessageAnimatedEmojiType:
		var messageAnimatedEmoji MessageAnimatedEmoji
		err := json.Unmarshal(*rawMsg, &messageAnimatedEmoji)
		return &messageAnimatedEmoji, err

	case MessageDiceType:
		var messageDice MessageDice
		err := json.Unmarshal(*rawMsg, &messageDice)
		return &messageDice, err

	case MessageGameType:
		var messageGame MessageGame
		err := json.Unmarshal(*rawMsg, &messageGame)
		return &messageGame, err

	case MessagePollType:
		var messagePoll MessagePoll
		err := json.Unmarshal(*rawMsg, &messagePoll)
		return &messagePoll, err

	case MessageInvoiceType:
		var messageInvoice MessageInvoice
		err := json.Unmarshal(*rawMsg, &messageInvoice)
		return &messageInvoice, err

	case MessageCallType:
		var messageCall MessageCall
		err := json.Unmarshal(*rawMsg, &messageCall)
		return &messageCall, err

	case MessageVideoChatScheduledType:
		var messageVideoChatScheduled MessageVideoChatScheduled
		err := json.Unmarshal(*rawMsg, &messageVideoChatScheduled)
		return &messageVideoChatScheduled, err

	case MessageVideoChatStartedType:
		var messageVideoChatStarted MessageVideoChatStarted
		err := json.Unmarshal(*rawMsg, &messageVideoChatStarted)
		return &messageVideoChatStarted, err

	case MessageVideoChatEndedType:
		var messageVideoChatEnded MessageVideoChatEnded
		err := json.Unmarshal(*rawMsg, &messageVideoChatEnded)
		return &messageVideoChatEnded, err

	case MessageInviteVideoChatParticipantsType:
		var messageInviteVideoChatParticipants MessageInviteVideoChatParticipants
		err := json.Unmarshal(*rawMsg, &messageInviteVideoChatParticipants)
		return &messageInviteVideoChatParticipants, err

	case MessageBasicGroupChatCreateType:
		var messageBasicGroupChatCreate MessageBasicGroupChatCreate
		err := json.Unmarshal(*rawMsg, &messageBasicGroupChatCreate)
		return &messageBasicGroupChatCreate, err

	case MessageSupergroupChatCreateType:
		var messageSupergroupChatCreate MessageSupergroupChatCreate
		err := json.Unmarshal(*rawMsg, &messageSupergroupChatCreate)
		return &messageSupergroupChatCreate, err

	case MessageChatChangeTitleType:
		var messageChatChangeTitle MessageChatChangeTitle
		err := json.Unmarshal(*rawMsg, &messageChatChangeTitle)
		return &messageChatChangeTitle, err

	case MessageChatChangePhotoType:
		var messageChatChangePhoto MessageChatChangePhoto
		err := json.Unmarshal(*rawMsg, &messageChatChangePhoto)
		return &messageChatChangePhoto, err

	case MessageChatDeletePhotoType:
		var messageChatDeletePhoto MessageChatDeletePhoto
		err := json.Unmarshal(*rawMsg, &messageChatDeletePhoto)
		return &messageChatDeletePhoto, err

	case MessageChatAddMembersType:
		var messageChatAddMembers MessageChatAddMembers
		err := json.Unmarshal(*rawMsg, &messageChatAddMembers)
		return &messageChatAddMembers, err

	case MessageChatJoinByLinkType:
		var messageChatJoinByLink MessageChatJoinByLink
		err := json.Unmarshal(*rawMsg, &messageChatJoinByLink)
		return &messageChatJoinByLink, err

	case MessageChatJoinByRequestType:
		var messageChatJoinByRequest MessageChatJoinByRequest
		err := json.Unmarshal(*rawMsg, &messageChatJoinByRequest)
		return &messageChatJoinByRequest, err

	case MessageChatDeleteMemberType:
		var messageChatDeleteMember MessageChatDeleteMember
		err := json.Unmarshal(*rawMsg, &messageChatDeleteMember)
		return &messageChatDeleteMember, err

	case MessageChatUpgradeToType:
		var messageChatUpgradeTo MessageChatUpgradeTo
		err := json.Unmarshal(*rawMsg, &messageChatUpgradeTo)
		return &messageChatUpgradeTo, err

	case MessageChatUpgradeFromType:
		var messageChatUpgradeFrom MessageChatUpgradeFrom
		err := json.Unmarshal(*rawMsg, &messageChatUpgradeFrom)
		return &messageChatUpgradeFrom, err

	case MessagePinMessageType:
		var messagePinMessage MessagePinMessage
		err := json.Unmarshal(*rawMsg, &messagePinMessage)
		return &messagePinMessage, err

	case MessageScreenshotTakenType:
		var messageScreenshotTaken MessageScreenshotTaken
		err := json.Unmarshal(*rawMsg, &messageScreenshotTaken)
		return &messageScreenshotTaken, err

	case MessageChatSetThemeType:
		var messageChatSetTheme MessageChatSetTheme
		err := json.Unmarshal(*rawMsg, &messageChatSetTheme)
		return &messageChatSetTheme, err

	case MessageChatSetTTLType:
		var messageChatSetTTL MessageChatSetTTL
		err := json.Unmarshal(*rawMsg, &messageChatSetTTL)
		return &messageChatSetTTL, err

	case MessageCustomServiceActionType:
		var messageCustomServiceAction MessageCustomServiceAction
		err := json.Unmarshal(*rawMsg, &messageCustomServiceAction)
		return &messageCustomServiceAction, err

	case MessageGameScoreType:
		var messageGameScore MessageGameScore
		err := json.Unmarshal(*rawMsg, &messageGameScore)
		return &messageGameScore, err

	case MessagePaymentSuccessfulType:
		var messagePaymentSuccessful MessagePaymentSuccessful
		err := json.Unmarshal(*rawMsg, &messagePaymentSuccessful)
		return &messagePaymentSuccessful, err

	case MessagePaymentSuccessfulBotType:
		var messagePaymentSuccessfulBot MessagePaymentSuccessfulBot
		err := json.Unmarshal(*rawMsg, &messagePaymentSuccessfulBot)
		return &messagePaymentSuccessfulBot, err

	case MessageContactRegisteredType:
		var messageContactRegistered MessageContactRegistered
		err := json.Unmarshal(*rawMsg, &messageContactRegistered)
		return &messageContactRegistered, err

	case MessageWebsiteConnectedType:
		var messageWebsiteConnected MessageWebsiteConnected
		err := json.Unmarshal(*rawMsg, &messageWebsiteConnected)
		return &messageWebsiteConnected, err

	case MessagePassportDataSentType:
		var messagePassportDataSent MessagePassportDataSent
		err := json.Unmarshal(*rawMsg, &messagePassportDataSent)
		return &messagePassportDataSent, err

	case MessagePassportDataReceivedType:
		var messagePassportDataReceived MessagePassportDataReceived
		err := json.Unmarshal(*rawMsg, &messagePassportDataReceived)
		return &messagePassportDataReceived, err

	case MessageProximityAlertTriggeredType:
		var messageProximityAlertTriggered MessageProximityAlertTriggered
		err := json.Unmarshal(*rawMsg, &messageProximityAlertTriggered)
		return &messageProximityAlertTriggered, err

	case MessageUnsupportedType:
		var messageUnsupported MessageUnsupported
		err := json.Unmarshal(*rawMsg, &messageUnsupported)
		return &messageUnsupported, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalMessageContentSlice(rawMsg *json.RawMessage) ([]MessageContent, error) {
	objects := make([]MessageContent, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch MessageContentEnum(objMap["@type"].(string)) {
		case MessageTextType:
			var messageText MessageText
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageText)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageText)
		case MessageAnimationType:
			var messageAnimation MessageAnimation
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageAnimation)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageAnimation)
		case MessageAudioType:
			var messageAudio MessageAudio
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageAudio)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageAudio)
		case MessageDocumentType:
			var messageDocument MessageDocument
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageDocument)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageDocument)
		case MessagePhotoType:
			var messagePhoto MessagePhoto
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messagePhoto)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messagePhoto)
		case MessageExpiredPhotoType:
			var messageExpiredPhoto MessageExpiredPhoto
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageExpiredPhoto)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageExpiredPhoto)
		case MessageStickerType:
			var messageSticker MessageSticker
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageSticker)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageSticker)
		case MessageVideoType:
			var messageVideo MessageVideo
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageVideo)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageVideo)
		case MessageExpiredVideoType:
			var messageExpiredVideo MessageExpiredVideo
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageExpiredVideo)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageExpiredVideo)
		case MessageVideoNoteType:
			var messageVideoNote MessageVideoNote
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageVideoNote)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageVideoNote)
		case MessageVoiceNoteType:
			var messageVoiceNote MessageVoiceNote
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageVoiceNote)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageVoiceNote)
		case MessageLocationType:
			var messageLocation MessageLocation
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageLocation)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageLocation)
		case MessageVenueType:
			var messageVenue MessageVenue
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageVenue)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageVenue)
		case MessageContactType:
			var messageContact MessageContact
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageContact)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageContact)
		case MessageAnimatedEmojiType:
			var messageAnimatedEmoji MessageAnimatedEmoji
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageAnimatedEmoji)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageAnimatedEmoji)
		case MessageDiceType:
			var messageDice MessageDice
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageDice)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageDice)
		case MessageGameType:
			var messageGame MessageGame
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageGame)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageGame)
		case MessagePollType:
			var messagePoll MessagePoll
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messagePoll)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messagePoll)
		case MessageInvoiceType:
			var messageInvoice MessageInvoice
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageInvoice)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageInvoice)
		case MessageCallType:
			var messageCall MessageCall
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageCall)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageCall)
		case MessageVideoChatScheduledType:
			var messageVideoChatScheduled MessageVideoChatScheduled
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageVideoChatScheduled)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageVideoChatScheduled)
		case MessageVideoChatStartedType:
			var messageVideoChatStarted MessageVideoChatStarted
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageVideoChatStarted)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageVideoChatStarted)
		case MessageVideoChatEndedType:
			var messageVideoChatEnded MessageVideoChatEnded
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageVideoChatEnded)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageVideoChatEnded)
		case MessageInviteVideoChatParticipantsType:
			var messageInviteVideoChatParticipants MessageInviteVideoChatParticipants
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageInviteVideoChatParticipants)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageInviteVideoChatParticipants)
		case MessageBasicGroupChatCreateType:
			var messageBasicGroupChatCreate MessageBasicGroupChatCreate
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageBasicGroupChatCreate)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageBasicGroupChatCreate)
		case MessageSupergroupChatCreateType:
			var messageSupergroupChatCreate MessageSupergroupChatCreate
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageSupergroupChatCreate)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageSupergroupChatCreate)
		case MessageChatChangeTitleType:
			var messageChatChangeTitle MessageChatChangeTitle
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageChatChangeTitle)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageChatChangeTitle)
		case MessageChatChangePhotoType:
			var messageChatChangePhoto MessageChatChangePhoto
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageChatChangePhoto)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageChatChangePhoto)
		case MessageChatDeletePhotoType:
			var messageChatDeletePhoto MessageChatDeletePhoto
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageChatDeletePhoto)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageChatDeletePhoto)
		case MessageChatAddMembersType:
			var messageChatAddMembers MessageChatAddMembers
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageChatAddMembers)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageChatAddMembers)
		case MessageChatJoinByLinkType:
			var messageChatJoinByLink MessageChatJoinByLink
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageChatJoinByLink)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageChatJoinByLink)
		case MessageChatJoinByRequestType:
			var messageChatJoinByRequest MessageChatJoinByRequest
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageChatJoinByRequest)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageChatJoinByRequest)
		case MessageChatDeleteMemberType:
			var messageChatDeleteMember MessageChatDeleteMember
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageChatDeleteMember)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageChatDeleteMember)
		case MessageChatUpgradeToType:
			var messageChatUpgradeTo MessageChatUpgradeTo
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageChatUpgradeTo)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageChatUpgradeTo)
		case MessageChatUpgradeFromType:
			var messageChatUpgradeFrom MessageChatUpgradeFrom
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageChatUpgradeFrom)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageChatUpgradeFrom)
		case MessagePinMessageType:
			var messagePinMessage MessagePinMessage
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messagePinMessage)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messagePinMessage)
		case MessageScreenshotTakenType:
			var messageScreenshotTaken MessageScreenshotTaken
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageScreenshotTaken)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageScreenshotTaken)
		case MessageChatSetThemeType:
			var messageChatSetTheme MessageChatSetTheme
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageChatSetTheme)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageChatSetTheme)
		case MessageChatSetTTLType:
			var messageChatSetTTL MessageChatSetTTL
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageChatSetTTL)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageChatSetTTL)
		case MessageCustomServiceActionType:
			var messageCustomServiceAction MessageCustomServiceAction
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageCustomServiceAction)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageCustomServiceAction)
		case MessageGameScoreType:
			var messageGameScore MessageGameScore
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageGameScore)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageGameScore)
		case MessagePaymentSuccessfulType:
			var messagePaymentSuccessful MessagePaymentSuccessful
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messagePaymentSuccessful)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messagePaymentSuccessful)
		case MessagePaymentSuccessfulBotType:
			var messagePaymentSuccessfulBot MessagePaymentSuccessfulBot
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messagePaymentSuccessfulBot)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messagePaymentSuccessfulBot)
		case MessageContactRegisteredType:
			var messageContactRegistered MessageContactRegistered
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageContactRegistered)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageContactRegistered)
		case MessageWebsiteConnectedType:
			var messageWebsiteConnected MessageWebsiteConnected
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageWebsiteConnected)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageWebsiteConnected)
		case MessagePassportDataSentType:
			var messagePassportDataSent MessagePassportDataSent
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messagePassportDataSent)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messagePassportDataSent)
		case MessagePassportDataReceivedType:
			var messagePassportDataReceived MessagePassportDataReceived
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messagePassportDataReceived)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messagePassportDataReceived)
		case MessageProximityAlertTriggeredType:
			var messageProximityAlertTriggered MessageProximityAlertTriggered
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageProximityAlertTriggered)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageProximityAlertTriggered)
		case MessageUnsupportedType:
			var messageUnsupported MessageUnsupported
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageUnsupported)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageUnsupported)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// TextEntityType Represents a part of the text which must be formatted differently
type TextEntityType interface {
	GetTextEntityTypeEnum() TextEntityTypeEnum
}

// TextEntityTypeEnum Alias for abstract TextEntityType 'Sub-Classes', used as constant-enum here
type TextEntityTypeEnum string

// TextEntityType enums
const (
	TextEntityTypeMentionType        TextEntityTypeEnum = "textEntityTypeMention"
	TextEntityTypeHashtagType        TextEntityTypeEnum = "textEntityTypeHashtag"
	TextEntityTypeCashtagType        TextEntityTypeEnum = "textEntityTypeCashtag"
	TextEntityTypeBotCommandType     TextEntityTypeEnum = "textEntityTypeBotCommand"
	TextEntityTypeURLType            TextEntityTypeEnum = "textEntityTypeUrl"
	TextEntityTypeEmailAddressType   TextEntityTypeEnum = "textEntityTypeEmailAddress"
	TextEntityTypePhoneNumberType    TextEntityTypeEnum = "textEntityTypePhoneNumber"
	TextEntityTypeBankCardNumberType TextEntityTypeEnum = "textEntityTypeBankCardNumber"
	TextEntityTypeBoldType           TextEntityTypeEnum = "textEntityTypeBold"
	TextEntityTypeItalicType         TextEntityTypeEnum = "textEntityTypeItalic"
	TextEntityTypeUnderlineType      TextEntityTypeEnum = "textEntityTypeUnderline"
	TextEntityTypeStrikethroughType  TextEntityTypeEnum = "textEntityTypeStrikethrough"
	TextEntityTypeCodeType           TextEntityTypeEnum = "textEntityTypeCode"
	TextEntityTypePreType            TextEntityTypeEnum = "textEntityTypePre"
	TextEntityTypePreCodeType        TextEntityTypeEnum = "textEntityTypePreCode"
	TextEntityTypeTextURLType        TextEntityTypeEnum = "textEntityTypeTextUrl"
	TextEntityTypeMentionNameType    TextEntityTypeEnum = "textEntityTypeMentionName"
	TextEntityTypeMediaTimestampType TextEntityTypeEnum = "textEntityTypeMediaTimestamp"
)

func unmarshalTextEntityType(rawMsg *json.RawMessage) (TextEntityType, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch TextEntityTypeEnum(objMap["@type"].(string)) {
	case TextEntityTypeMentionType:
		var textEntityTypeMention TextEntityTypeMention
		err := json.Unmarshal(*rawMsg, &textEntityTypeMention)
		return &textEntityTypeMention, err

	case TextEntityTypeHashtagType:
		var textEntityTypeHashtag TextEntityTypeHashtag
		err := json.Unmarshal(*rawMsg, &textEntityTypeHashtag)
		return &textEntityTypeHashtag, err

	case TextEntityTypeCashtagType:
		var textEntityTypeCashtag TextEntityTypeCashtag
		err := json.Unmarshal(*rawMsg, &textEntityTypeCashtag)
		return &textEntityTypeCashtag, err

	case TextEntityTypeBotCommandType:
		var textEntityTypeBotCommand TextEntityTypeBotCommand
		err := json.Unmarshal(*rawMsg, &textEntityTypeBotCommand)
		return &textEntityTypeBotCommand, err

	case TextEntityTypeURLType:
		var textEntityTypeURL TextEntityTypeURL
		err := json.Unmarshal(*rawMsg, &textEntityTypeURL)
		return &textEntityTypeURL, err

	case TextEntityTypeEmailAddressType:
		var textEntityTypeEmailAddress TextEntityTypeEmailAddress
		err := json.Unmarshal(*rawMsg, &textEntityTypeEmailAddress)
		return &textEntityTypeEmailAddress, err

	case TextEntityTypePhoneNumberType:
		var textEntityTypePhoneNumber TextEntityTypePhoneNumber
		err := json.Unmarshal(*rawMsg, &textEntityTypePhoneNumber)
		return &textEntityTypePhoneNumber, err

	case TextEntityTypeBankCardNumberType:
		var textEntityTypeBankCardNumber TextEntityTypeBankCardNumber
		err := json.Unmarshal(*rawMsg, &textEntityTypeBankCardNumber)
		return &textEntityTypeBankCardNumber, err

	case TextEntityTypeBoldType:
		var textEntityTypeBold TextEntityTypeBold
		err := json.Unmarshal(*rawMsg, &textEntityTypeBold)
		return &textEntityTypeBold, err

	case TextEntityTypeItalicType:
		var textEntityTypeItalic TextEntityTypeItalic
		err := json.Unmarshal(*rawMsg, &textEntityTypeItalic)
		return &textEntityTypeItalic, err

	case TextEntityTypeUnderlineType:
		var textEntityTypeUnderline TextEntityTypeUnderline
		err := json.Unmarshal(*rawMsg, &textEntityTypeUnderline)
		return &textEntityTypeUnderline, err

	case TextEntityTypeStrikethroughType:
		var textEntityTypeStrikethrough TextEntityTypeStrikethrough
		err := json.Unmarshal(*rawMsg, &textEntityTypeStrikethrough)
		return &textEntityTypeStrikethrough, err

	case TextEntityTypeCodeType:
		var textEntityTypeCode TextEntityTypeCode
		err := json.Unmarshal(*rawMsg, &textEntityTypeCode)
		return &textEntityTypeCode, err

	case TextEntityTypePreType:
		var textEntityTypePre TextEntityTypePre
		err := json.Unmarshal(*rawMsg, &textEntityTypePre)
		return &textEntityTypePre, err

	case TextEntityTypePreCodeType:
		var textEntityTypePreCode TextEntityTypePreCode
		err := json.Unmarshal(*rawMsg, &textEntityTypePreCode)
		return &textEntityTypePreCode, err

	case TextEntityTypeTextURLType:
		var textEntityTypeTextURL TextEntityTypeTextURL
		err := json.Unmarshal(*rawMsg, &textEntityTypeTextURL)
		return &textEntityTypeTextURL, err

	case TextEntityTypeMentionNameType:
		var textEntityTypeMentionName TextEntityTypeMentionName
		err := json.Unmarshal(*rawMsg, &textEntityTypeMentionName)
		return &textEntityTypeMentionName, err

	case TextEntityTypeMediaTimestampType:
		var textEntityTypeMediaTimestamp TextEntityTypeMediaTimestamp
		err := json.Unmarshal(*rawMsg, &textEntityTypeMediaTimestamp)
		return &textEntityTypeMediaTimestamp, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalTextEntityTypeSlice(rawMsg *json.RawMessage) ([]TextEntityType, error) {
	objects := make([]TextEntityType, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch TextEntityTypeEnum(objMap["@type"].(string)) {
		case TextEntityTypeMentionType:
			var textEntityTypeMention TextEntityTypeMention
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &textEntityTypeMention)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &textEntityTypeMention)
		case TextEntityTypeHashtagType:
			var textEntityTypeHashtag TextEntityTypeHashtag
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &textEntityTypeHashtag)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &textEntityTypeHashtag)
		case TextEntityTypeCashtagType:
			var textEntityTypeCashtag TextEntityTypeCashtag
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &textEntityTypeCashtag)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &textEntityTypeCashtag)
		case TextEntityTypeBotCommandType:
			var textEntityTypeBotCommand TextEntityTypeBotCommand
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &textEntityTypeBotCommand)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &textEntityTypeBotCommand)
		case TextEntityTypeURLType:
			var textEntityTypeURL TextEntityTypeURL
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &textEntityTypeURL)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &textEntityTypeURL)
		case TextEntityTypeEmailAddressType:
			var textEntityTypeEmailAddress TextEntityTypeEmailAddress
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &textEntityTypeEmailAddress)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &textEntityTypeEmailAddress)
		case TextEntityTypePhoneNumberType:
			var textEntityTypePhoneNumber TextEntityTypePhoneNumber
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &textEntityTypePhoneNumber)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &textEntityTypePhoneNumber)
		case TextEntityTypeBankCardNumberType:
			var textEntityTypeBankCardNumber TextEntityTypeBankCardNumber
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &textEntityTypeBankCardNumber)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &textEntityTypeBankCardNumber)
		case TextEntityTypeBoldType:
			var textEntityTypeBold TextEntityTypeBold
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &textEntityTypeBold)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &textEntityTypeBold)
		case TextEntityTypeItalicType:
			var textEntityTypeItalic TextEntityTypeItalic
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &textEntityTypeItalic)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &textEntityTypeItalic)
		case TextEntityTypeUnderlineType:
			var textEntityTypeUnderline TextEntityTypeUnderline
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &textEntityTypeUnderline)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &textEntityTypeUnderline)
		case TextEntityTypeStrikethroughType:
			var textEntityTypeStrikethrough TextEntityTypeStrikethrough
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &textEntityTypeStrikethrough)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &textEntityTypeStrikethrough)
		case TextEntityTypeCodeType:
			var textEntityTypeCode TextEntityTypeCode
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &textEntityTypeCode)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &textEntityTypeCode)
		case TextEntityTypePreType:
			var textEntityTypePre TextEntityTypePre
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &textEntityTypePre)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &textEntityTypePre)
		case TextEntityTypePreCodeType:
			var textEntityTypePreCode TextEntityTypePreCode
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &textEntityTypePreCode)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &textEntityTypePreCode)
		case TextEntityTypeTextURLType:
			var textEntityTypeTextURL TextEntityTypeTextURL
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &textEntityTypeTextURL)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &textEntityTypeTextURL)
		case TextEntityTypeMentionNameType:
			var textEntityTypeMentionName TextEntityTypeMentionName
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &textEntityTypeMentionName)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &textEntityTypeMentionName)
		case TextEntityTypeMediaTimestampType:
			var textEntityTypeMediaTimestamp TextEntityTypeMediaTimestamp
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &textEntityTypeMediaTimestamp)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &textEntityTypeMediaTimestamp)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// MessageSchedulingState Contains information about the time when a scheduled message will be sent
type MessageSchedulingState interface {
	GetMessageSchedulingStateEnum() MessageSchedulingStateEnum
}

// MessageSchedulingStateEnum Alias for abstract MessageSchedulingState 'Sub-Classes', used as constant-enum here
type MessageSchedulingStateEnum string

// MessageSchedulingState enums
const (
	MessageSchedulingStateSendAtDateType     MessageSchedulingStateEnum = "messageSchedulingStateSendAtDate"
	MessageSchedulingStateSendWhenOnlineType MessageSchedulingStateEnum = "messageSchedulingStateSendWhenOnline"
)

func unmarshalMessageSchedulingState(rawMsg *json.RawMessage) (MessageSchedulingState, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch MessageSchedulingStateEnum(objMap["@type"].(string)) {
	case MessageSchedulingStateSendAtDateType:
		var messageSchedulingStateSendAtDate MessageSchedulingStateSendAtDate
		err := json.Unmarshal(*rawMsg, &messageSchedulingStateSendAtDate)
		return &messageSchedulingStateSendAtDate, err

	case MessageSchedulingStateSendWhenOnlineType:
		var messageSchedulingStateSendWhenOnline MessageSchedulingStateSendWhenOnline
		err := json.Unmarshal(*rawMsg, &messageSchedulingStateSendWhenOnline)
		return &messageSchedulingStateSendWhenOnline, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalMessageSchedulingStateSlice(rawMsg *json.RawMessage) ([]MessageSchedulingState, error) {
	objects := make([]MessageSchedulingState, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch MessageSchedulingStateEnum(objMap["@type"].(string)) {
		case MessageSchedulingStateSendAtDateType:
			var messageSchedulingStateSendAtDate MessageSchedulingStateSendAtDate
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageSchedulingStateSendAtDate)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageSchedulingStateSendAtDate)
		case MessageSchedulingStateSendWhenOnlineType:
			var messageSchedulingStateSendWhenOnline MessageSchedulingStateSendWhenOnline
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageSchedulingStateSendWhenOnline)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageSchedulingStateSendWhenOnline)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// InputMessageContent The content of a message to send
type InputMessageContent interface {
	GetInputMessageContentEnum() InputMessageContentEnum
}

// InputMessageContentEnum Alias for abstract InputMessageContent 'Sub-Classes', used as constant-enum here
type InputMessageContentEnum string

// InputMessageContent enums
const (
	InputMessageTextType      InputMessageContentEnum = "inputMessageText"
	InputMessageAnimationType InputMessageContentEnum = "inputMessageAnimation"
	InputMessageAudioType     InputMessageContentEnum = "inputMessageAudio"
	InputMessageDocumentType  InputMessageContentEnum = "inputMessageDocument"
	InputMessagePhotoType     InputMessageContentEnum = "inputMessagePhoto"
	InputMessageStickerType   InputMessageContentEnum = "inputMessageSticker"
	InputMessageVideoType     InputMessageContentEnum = "inputMessageVideo"
	InputMessageVideoNoteType InputMessageContentEnum = "inputMessageVideoNote"
	InputMessageVoiceNoteType InputMessageContentEnum = "inputMessageVoiceNote"
	InputMessageLocationType  InputMessageContentEnum = "inputMessageLocation"
	InputMessageVenueType     InputMessageContentEnum = "inputMessageVenue"
	InputMessageContactType   InputMessageContentEnum = "inputMessageContact"
	InputMessageDiceType      InputMessageContentEnum = "inputMessageDice"
	InputMessageGameType      InputMessageContentEnum = "inputMessageGame"
	InputMessageInvoiceType   InputMessageContentEnum = "inputMessageInvoice"
	InputMessagePollType      InputMessageContentEnum = "inputMessagePoll"
	InputMessageForwardedType InputMessageContentEnum = "inputMessageForwarded"
)

func unmarshalInputMessageContent(rawMsg *json.RawMessage) (InputMessageContent, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch InputMessageContentEnum(objMap["@type"].(string)) {
	case InputMessageTextType:
		var inputMessageText InputMessageText
		err := json.Unmarshal(*rawMsg, &inputMessageText)
		return &inputMessageText, err

	case InputMessageAnimationType:
		var inputMessageAnimation InputMessageAnimation
		err := json.Unmarshal(*rawMsg, &inputMessageAnimation)
		return &inputMessageAnimation, err

	case InputMessageAudioType:
		var inputMessageAudio InputMessageAudio
		err := json.Unmarshal(*rawMsg, &inputMessageAudio)
		return &inputMessageAudio, err

	case InputMessageDocumentType:
		var inputMessageDocument InputMessageDocument
		err := json.Unmarshal(*rawMsg, &inputMessageDocument)
		return &inputMessageDocument, err

	case InputMessagePhotoType:
		var inputMessagePhoto InputMessagePhoto
		err := json.Unmarshal(*rawMsg, &inputMessagePhoto)
		return &inputMessagePhoto, err

	case InputMessageStickerType:
		var inputMessageSticker InputMessageSticker
		err := json.Unmarshal(*rawMsg, &inputMessageSticker)
		return &inputMessageSticker, err

	case InputMessageVideoType:
		var inputMessageVideo InputMessageVideo
		err := json.Unmarshal(*rawMsg, &inputMessageVideo)
		return &inputMessageVideo, err

	case InputMessageVideoNoteType:
		var inputMessageVideoNote InputMessageVideoNote
		err := json.Unmarshal(*rawMsg, &inputMessageVideoNote)
		return &inputMessageVideoNote, err

	case InputMessageVoiceNoteType:
		var inputMessageVoiceNote InputMessageVoiceNote
		err := json.Unmarshal(*rawMsg, &inputMessageVoiceNote)
		return &inputMessageVoiceNote, err

	case InputMessageLocationType:
		var inputMessageLocation InputMessageLocation
		err := json.Unmarshal(*rawMsg, &inputMessageLocation)
		return &inputMessageLocation, err

	case InputMessageVenueType:
		var inputMessageVenue InputMessageVenue
		err := json.Unmarshal(*rawMsg, &inputMessageVenue)
		return &inputMessageVenue, err

	case InputMessageContactType:
		var inputMessageContact InputMessageContact
		err := json.Unmarshal(*rawMsg, &inputMessageContact)
		return &inputMessageContact, err

	case InputMessageDiceType:
		var inputMessageDice InputMessageDice
		err := json.Unmarshal(*rawMsg, &inputMessageDice)
		return &inputMessageDice, err

	case InputMessageGameType:
		var inputMessageGame InputMessageGame
		err := json.Unmarshal(*rawMsg, &inputMessageGame)
		return &inputMessageGame, err

	case InputMessageInvoiceType:
		var inputMessageInvoice InputMessageInvoice
		err := json.Unmarshal(*rawMsg, &inputMessageInvoice)
		return &inputMessageInvoice, err

	case InputMessagePollType:
		var inputMessagePoll InputMessagePoll
		err := json.Unmarshal(*rawMsg, &inputMessagePoll)
		return &inputMessagePoll, err

	case InputMessageForwardedType:
		var inputMessageForwarded InputMessageForwarded
		err := json.Unmarshal(*rawMsg, &inputMessageForwarded)
		return &inputMessageForwarded, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalInputMessageContentSlice(rawMsg *json.RawMessage) ([]InputMessageContent, error) {
	objects := make([]InputMessageContent, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch InputMessageContentEnum(objMap["@type"].(string)) {
		case InputMessageTextType:
			var inputMessageText InputMessageText
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputMessageText)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputMessageText)
		case InputMessageAnimationType:
			var inputMessageAnimation InputMessageAnimation
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputMessageAnimation)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputMessageAnimation)
		case InputMessageAudioType:
			var inputMessageAudio InputMessageAudio
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputMessageAudio)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputMessageAudio)
		case InputMessageDocumentType:
			var inputMessageDocument InputMessageDocument
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputMessageDocument)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputMessageDocument)
		case InputMessagePhotoType:
			var inputMessagePhoto InputMessagePhoto
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputMessagePhoto)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputMessagePhoto)
		case InputMessageStickerType:
			var inputMessageSticker InputMessageSticker
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputMessageSticker)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputMessageSticker)
		case InputMessageVideoType:
			var inputMessageVideo InputMessageVideo
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputMessageVideo)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputMessageVideo)
		case InputMessageVideoNoteType:
			var inputMessageVideoNote InputMessageVideoNote
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputMessageVideoNote)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputMessageVideoNote)
		case InputMessageVoiceNoteType:
			var inputMessageVoiceNote InputMessageVoiceNote
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputMessageVoiceNote)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputMessageVoiceNote)
		case InputMessageLocationType:
			var inputMessageLocation InputMessageLocation
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputMessageLocation)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputMessageLocation)
		case InputMessageVenueType:
			var inputMessageVenue InputMessageVenue
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputMessageVenue)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputMessageVenue)
		case InputMessageContactType:
			var inputMessageContact InputMessageContact
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputMessageContact)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputMessageContact)
		case InputMessageDiceType:
			var inputMessageDice InputMessageDice
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputMessageDice)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputMessageDice)
		case InputMessageGameType:
			var inputMessageGame InputMessageGame
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputMessageGame)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputMessageGame)
		case InputMessageInvoiceType:
			var inputMessageInvoice InputMessageInvoice
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputMessageInvoice)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputMessageInvoice)
		case InputMessagePollType:
			var inputMessagePoll InputMessagePoll
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputMessagePoll)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputMessagePoll)
		case InputMessageForwardedType:
			var inputMessageForwarded InputMessageForwarded
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputMessageForwarded)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputMessageForwarded)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// SearchMessagesFilter Represents a filter for message search results
type SearchMessagesFilter interface {
	GetSearchMessagesFilterEnum() SearchMessagesFilterEnum
}

// SearchMessagesFilterEnum Alias for abstract SearchMessagesFilter 'Sub-Classes', used as constant-enum here
type SearchMessagesFilterEnum string

// SearchMessagesFilter enums
const (
	SearchMessagesFilterEmptyType             SearchMessagesFilterEnum = "searchMessagesFilterEmpty"
	SearchMessagesFilterAnimationType         SearchMessagesFilterEnum = "searchMessagesFilterAnimation"
	SearchMessagesFilterAudioType             SearchMessagesFilterEnum = "searchMessagesFilterAudio"
	SearchMessagesFilterDocumentType          SearchMessagesFilterEnum = "searchMessagesFilterDocument"
	SearchMessagesFilterPhotoType             SearchMessagesFilterEnum = "searchMessagesFilterPhoto"
	SearchMessagesFilterVideoType             SearchMessagesFilterEnum = "searchMessagesFilterVideo"
	SearchMessagesFilterVoiceNoteType         SearchMessagesFilterEnum = "searchMessagesFilterVoiceNote"
	SearchMessagesFilterPhotoAndVideoType     SearchMessagesFilterEnum = "searchMessagesFilterPhotoAndVideo"
	SearchMessagesFilterURLType               SearchMessagesFilterEnum = "searchMessagesFilterUrl"
	SearchMessagesFilterChatPhotoType         SearchMessagesFilterEnum = "searchMessagesFilterChatPhoto"
	SearchMessagesFilterVideoNoteType         SearchMessagesFilterEnum = "searchMessagesFilterVideoNote"
	SearchMessagesFilterVoiceAndVideoNoteType SearchMessagesFilterEnum = "searchMessagesFilterVoiceAndVideoNote"
	SearchMessagesFilterMentionType           SearchMessagesFilterEnum = "searchMessagesFilterMention"
	SearchMessagesFilterUnreadMentionType     SearchMessagesFilterEnum = "searchMessagesFilterUnreadMention"
	SearchMessagesFilterFailedToSendType      SearchMessagesFilterEnum = "searchMessagesFilterFailedToSend"
	SearchMessagesFilterPinnedType            SearchMessagesFilterEnum = "searchMessagesFilterPinned"
)

func unmarshalSearchMessagesFilter(rawMsg *json.RawMessage) (SearchMessagesFilter, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch SearchMessagesFilterEnum(objMap["@type"].(string)) {
	case SearchMessagesFilterEmptyType:
		var searchMessagesFilterEmpty SearchMessagesFilterEmpty
		err := json.Unmarshal(*rawMsg, &searchMessagesFilterEmpty)
		return &searchMessagesFilterEmpty, err

	case SearchMessagesFilterAnimationType:
		var searchMessagesFilterAnimation SearchMessagesFilterAnimation
		err := json.Unmarshal(*rawMsg, &searchMessagesFilterAnimation)
		return &searchMessagesFilterAnimation, err

	case SearchMessagesFilterAudioType:
		var searchMessagesFilterAudio SearchMessagesFilterAudio
		err := json.Unmarshal(*rawMsg, &searchMessagesFilterAudio)
		return &searchMessagesFilterAudio, err

	case SearchMessagesFilterDocumentType:
		var searchMessagesFilterDocument SearchMessagesFilterDocument
		err := json.Unmarshal(*rawMsg, &searchMessagesFilterDocument)
		return &searchMessagesFilterDocument, err

	case SearchMessagesFilterPhotoType:
		var searchMessagesFilterPhoto SearchMessagesFilterPhoto
		err := json.Unmarshal(*rawMsg, &searchMessagesFilterPhoto)
		return &searchMessagesFilterPhoto, err

	case SearchMessagesFilterVideoType:
		var searchMessagesFilterVideo SearchMessagesFilterVideo
		err := json.Unmarshal(*rawMsg, &searchMessagesFilterVideo)
		return &searchMessagesFilterVideo, err

	case SearchMessagesFilterVoiceNoteType:
		var searchMessagesFilterVoiceNote SearchMessagesFilterVoiceNote
		err := json.Unmarshal(*rawMsg, &searchMessagesFilterVoiceNote)
		return &searchMessagesFilterVoiceNote, err

	case SearchMessagesFilterPhotoAndVideoType:
		var searchMessagesFilterPhotoAndVideo SearchMessagesFilterPhotoAndVideo
		err := json.Unmarshal(*rawMsg, &searchMessagesFilterPhotoAndVideo)
		return &searchMessagesFilterPhotoAndVideo, err

	case SearchMessagesFilterURLType:
		var searchMessagesFilterURL SearchMessagesFilterURL
		err := json.Unmarshal(*rawMsg, &searchMessagesFilterURL)
		return &searchMessagesFilterURL, err

	case SearchMessagesFilterChatPhotoType:
		var searchMessagesFilterChatPhoto SearchMessagesFilterChatPhoto
		err := json.Unmarshal(*rawMsg, &searchMessagesFilterChatPhoto)
		return &searchMessagesFilterChatPhoto, err

	case SearchMessagesFilterVideoNoteType:
		var searchMessagesFilterVideoNote SearchMessagesFilterVideoNote
		err := json.Unmarshal(*rawMsg, &searchMessagesFilterVideoNote)
		return &searchMessagesFilterVideoNote, err

	case SearchMessagesFilterVoiceAndVideoNoteType:
		var searchMessagesFilterVoiceAndVideoNote SearchMessagesFilterVoiceAndVideoNote
		err := json.Unmarshal(*rawMsg, &searchMessagesFilterVoiceAndVideoNote)
		return &searchMessagesFilterVoiceAndVideoNote, err

	case SearchMessagesFilterMentionType:
		var searchMessagesFilterMention SearchMessagesFilterMention
		err := json.Unmarshal(*rawMsg, &searchMessagesFilterMention)
		return &searchMessagesFilterMention, err

	case SearchMessagesFilterUnreadMentionType:
		var searchMessagesFilterUnreadMention SearchMessagesFilterUnreadMention
		err := json.Unmarshal(*rawMsg, &searchMessagesFilterUnreadMention)
		return &searchMessagesFilterUnreadMention, err

	case SearchMessagesFilterFailedToSendType:
		var searchMessagesFilterFailedToSend SearchMessagesFilterFailedToSend
		err := json.Unmarshal(*rawMsg, &searchMessagesFilterFailedToSend)
		return &searchMessagesFilterFailedToSend, err

	case SearchMessagesFilterPinnedType:
		var searchMessagesFilterPinned SearchMessagesFilterPinned
		err := json.Unmarshal(*rawMsg, &searchMessagesFilterPinned)
		return &searchMessagesFilterPinned, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalSearchMessagesFilterSlice(rawMsg *json.RawMessage) ([]SearchMessagesFilter, error) {
	objects := make([]SearchMessagesFilter, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch SearchMessagesFilterEnum(objMap["@type"].(string)) {
		case SearchMessagesFilterEmptyType:
			var searchMessagesFilterEmpty SearchMessagesFilterEmpty
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &searchMessagesFilterEmpty)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &searchMessagesFilterEmpty)
		case SearchMessagesFilterAnimationType:
			var searchMessagesFilterAnimation SearchMessagesFilterAnimation
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &searchMessagesFilterAnimation)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &searchMessagesFilterAnimation)
		case SearchMessagesFilterAudioType:
			var searchMessagesFilterAudio SearchMessagesFilterAudio
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &searchMessagesFilterAudio)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &searchMessagesFilterAudio)
		case SearchMessagesFilterDocumentType:
			var searchMessagesFilterDocument SearchMessagesFilterDocument
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &searchMessagesFilterDocument)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &searchMessagesFilterDocument)
		case SearchMessagesFilterPhotoType:
			var searchMessagesFilterPhoto SearchMessagesFilterPhoto
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &searchMessagesFilterPhoto)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &searchMessagesFilterPhoto)
		case SearchMessagesFilterVideoType:
			var searchMessagesFilterVideo SearchMessagesFilterVideo
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &searchMessagesFilterVideo)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &searchMessagesFilterVideo)
		case SearchMessagesFilterVoiceNoteType:
			var searchMessagesFilterVoiceNote SearchMessagesFilterVoiceNote
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &searchMessagesFilterVoiceNote)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &searchMessagesFilterVoiceNote)
		case SearchMessagesFilterPhotoAndVideoType:
			var searchMessagesFilterPhotoAndVideo SearchMessagesFilterPhotoAndVideo
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &searchMessagesFilterPhotoAndVideo)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &searchMessagesFilterPhotoAndVideo)
		case SearchMessagesFilterURLType:
			var searchMessagesFilterURL SearchMessagesFilterURL
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &searchMessagesFilterURL)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &searchMessagesFilterURL)
		case SearchMessagesFilterChatPhotoType:
			var searchMessagesFilterChatPhoto SearchMessagesFilterChatPhoto
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &searchMessagesFilterChatPhoto)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &searchMessagesFilterChatPhoto)
		case SearchMessagesFilterVideoNoteType:
			var searchMessagesFilterVideoNote SearchMessagesFilterVideoNote
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &searchMessagesFilterVideoNote)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &searchMessagesFilterVideoNote)
		case SearchMessagesFilterVoiceAndVideoNoteType:
			var searchMessagesFilterVoiceAndVideoNote SearchMessagesFilterVoiceAndVideoNote
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &searchMessagesFilterVoiceAndVideoNote)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &searchMessagesFilterVoiceAndVideoNote)
		case SearchMessagesFilterMentionType:
			var searchMessagesFilterMention SearchMessagesFilterMention
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &searchMessagesFilterMention)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &searchMessagesFilterMention)
		case SearchMessagesFilterUnreadMentionType:
			var searchMessagesFilterUnreadMention SearchMessagesFilterUnreadMention
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &searchMessagesFilterUnreadMention)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &searchMessagesFilterUnreadMention)
		case SearchMessagesFilterFailedToSendType:
			var searchMessagesFilterFailedToSend SearchMessagesFilterFailedToSend
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &searchMessagesFilterFailedToSend)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &searchMessagesFilterFailedToSend)
		case SearchMessagesFilterPinnedType:
			var searchMessagesFilterPinned SearchMessagesFilterPinned
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &searchMessagesFilterPinned)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &searchMessagesFilterPinned)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// ChatAction Describes the different types of activity in a chat
type ChatAction interface {
	GetChatActionEnum() ChatActionEnum
}

// ChatActionEnum Alias for abstract ChatAction 'Sub-Classes', used as constant-enum here
type ChatActionEnum string

// ChatAction enums
const (
	ChatActionTypingType             ChatActionEnum = "chatActionTyping"
	ChatActionRecordingVideoType     ChatActionEnum = "chatActionRecordingVideo"
	ChatActionUploadingVideoType     ChatActionEnum = "chatActionUploadingVideo"
	ChatActionRecordingVoiceNoteType ChatActionEnum = "chatActionRecordingVoiceNote"
	ChatActionUploadingVoiceNoteType ChatActionEnum = "chatActionUploadingVoiceNote"
	ChatActionUploadingPhotoType     ChatActionEnum = "chatActionUploadingPhoto"
	ChatActionUploadingDocumentType  ChatActionEnum = "chatActionUploadingDocument"
	ChatActionChoosingStickerType    ChatActionEnum = "chatActionChoosingSticker"
	ChatActionChoosingLocationType   ChatActionEnum = "chatActionChoosingLocation"
	ChatActionChoosingContactType    ChatActionEnum = "chatActionChoosingContact"
	ChatActionStartPlayingGameType   ChatActionEnum = "chatActionStartPlayingGame"
	ChatActionRecordingVideoNoteType ChatActionEnum = "chatActionRecordingVideoNote"
	ChatActionUploadingVideoNoteType ChatActionEnum = "chatActionUploadingVideoNote"
	ChatActionWatchingAnimationsType ChatActionEnum = "chatActionWatchingAnimations"
	ChatActionCancelType             ChatActionEnum = "chatActionCancel"
)

func unmarshalChatAction(rawMsg *json.RawMessage) (ChatAction, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch ChatActionEnum(objMap["@type"].(string)) {
	case ChatActionTypingType:
		var chatActionTyping ChatActionTyping
		err := json.Unmarshal(*rawMsg, &chatActionTyping)
		return &chatActionTyping, err

	case ChatActionRecordingVideoType:
		var chatActionRecordingVideo ChatActionRecordingVideo
		err := json.Unmarshal(*rawMsg, &chatActionRecordingVideo)
		return &chatActionRecordingVideo, err

	case ChatActionUploadingVideoType:
		var chatActionUploadingVideo ChatActionUploadingVideo
		err := json.Unmarshal(*rawMsg, &chatActionUploadingVideo)
		return &chatActionUploadingVideo, err

	case ChatActionRecordingVoiceNoteType:
		var chatActionRecordingVoiceNote ChatActionRecordingVoiceNote
		err := json.Unmarshal(*rawMsg, &chatActionRecordingVoiceNote)
		return &chatActionRecordingVoiceNote, err

	case ChatActionUploadingVoiceNoteType:
		var chatActionUploadingVoiceNote ChatActionUploadingVoiceNote
		err := json.Unmarshal(*rawMsg, &chatActionUploadingVoiceNote)
		return &chatActionUploadingVoiceNote, err

	case ChatActionUploadingPhotoType:
		var chatActionUploadingPhoto ChatActionUploadingPhoto
		err := json.Unmarshal(*rawMsg, &chatActionUploadingPhoto)
		return &chatActionUploadingPhoto, err

	case ChatActionUploadingDocumentType:
		var chatActionUploadingDocument ChatActionUploadingDocument
		err := json.Unmarshal(*rawMsg, &chatActionUploadingDocument)
		return &chatActionUploadingDocument, err

	case ChatActionChoosingStickerType:
		var chatActionChoosingSticker ChatActionChoosingSticker
		err := json.Unmarshal(*rawMsg, &chatActionChoosingSticker)
		return &chatActionChoosingSticker, err

	case ChatActionChoosingLocationType:
		var chatActionChoosingLocation ChatActionChoosingLocation
		err := json.Unmarshal(*rawMsg, &chatActionChoosingLocation)
		return &chatActionChoosingLocation, err

	case ChatActionChoosingContactType:
		var chatActionChoosingContact ChatActionChoosingContact
		err := json.Unmarshal(*rawMsg, &chatActionChoosingContact)
		return &chatActionChoosingContact, err

	case ChatActionStartPlayingGameType:
		var chatActionStartPlayingGame ChatActionStartPlayingGame
		err := json.Unmarshal(*rawMsg, &chatActionStartPlayingGame)
		return &chatActionStartPlayingGame, err

	case ChatActionRecordingVideoNoteType:
		var chatActionRecordingVideoNote ChatActionRecordingVideoNote
		err := json.Unmarshal(*rawMsg, &chatActionRecordingVideoNote)
		return &chatActionRecordingVideoNote, err

	case ChatActionUploadingVideoNoteType:
		var chatActionUploadingVideoNote ChatActionUploadingVideoNote
		err := json.Unmarshal(*rawMsg, &chatActionUploadingVideoNote)
		return &chatActionUploadingVideoNote, err

	case ChatActionWatchingAnimationsType:
		var chatActionWatchingAnimations ChatActionWatchingAnimations
		err := json.Unmarshal(*rawMsg, &chatActionWatchingAnimations)
		return &chatActionWatchingAnimations, err

	case ChatActionCancelType:
		var chatActionCancel ChatActionCancel
		err := json.Unmarshal(*rawMsg, &chatActionCancel)
		return &chatActionCancel, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalChatActionSlice(rawMsg *json.RawMessage) ([]ChatAction, error) {
	objects := make([]ChatAction, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch ChatActionEnum(objMap["@type"].(string)) {
		case ChatActionTypingType:
			var chatActionTyping ChatActionTyping
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatActionTyping)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatActionTyping)
		case ChatActionRecordingVideoType:
			var chatActionRecordingVideo ChatActionRecordingVideo
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatActionRecordingVideo)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatActionRecordingVideo)
		case ChatActionUploadingVideoType:
			var chatActionUploadingVideo ChatActionUploadingVideo
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatActionUploadingVideo)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatActionUploadingVideo)
		case ChatActionRecordingVoiceNoteType:
			var chatActionRecordingVoiceNote ChatActionRecordingVoiceNote
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatActionRecordingVoiceNote)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatActionRecordingVoiceNote)
		case ChatActionUploadingVoiceNoteType:
			var chatActionUploadingVoiceNote ChatActionUploadingVoiceNote
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatActionUploadingVoiceNote)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatActionUploadingVoiceNote)
		case ChatActionUploadingPhotoType:
			var chatActionUploadingPhoto ChatActionUploadingPhoto
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatActionUploadingPhoto)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatActionUploadingPhoto)
		case ChatActionUploadingDocumentType:
			var chatActionUploadingDocument ChatActionUploadingDocument
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatActionUploadingDocument)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatActionUploadingDocument)
		case ChatActionChoosingStickerType:
			var chatActionChoosingSticker ChatActionChoosingSticker
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatActionChoosingSticker)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatActionChoosingSticker)
		case ChatActionChoosingLocationType:
			var chatActionChoosingLocation ChatActionChoosingLocation
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatActionChoosingLocation)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatActionChoosingLocation)
		case ChatActionChoosingContactType:
			var chatActionChoosingContact ChatActionChoosingContact
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatActionChoosingContact)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatActionChoosingContact)
		case ChatActionStartPlayingGameType:
			var chatActionStartPlayingGame ChatActionStartPlayingGame
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatActionStartPlayingGame)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatActionStartPlayingGame)
		case ChatActionRecordingVideoNoteType:
			var chatActionRecordingVideoNote ChatActionRecordingVideoNote
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatActionRecordingVideoNote)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatActionRecordingVideoNote)
		case ChatActionUploadingVideoNoteType:
			var chatActionUploadingVideoNote ChatActionUploadingVideoNote
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatActionUploadingVideoNote)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatActionUploadingVideoNote)
		case ChatActionWatchingAnimationsType:
			var chatActionWatchingAnimations ChatActionWatchingAnimations
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatActionWatchingAnimations)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatActionWatchingAnimations)
		case ChatActionCancelType:
			var chatActionCancel ChatActionCancel
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatActionCancel)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatActionCancel)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// UserStatus Describes the last time the user was online
type UserStatus interface {
	GetUserStatusEnum() UserStatusEnum
}

// UserStatusEnum Alias for abstract UserStatus 'Sub-Classes', used as constant-enum here
type UserStatusEnum string

// UserStatus enums
const (
	UserStatusEmptyType     UserStatusEnum = "userStatusEmpty"
	UserStatusOnlineType    UserStatusEnum = "userStatusOnline"
	UserStatusOfflineType   UserStatusEnum = "userStatusOffline"
	UserStatusRecentlyType  UserStatusEnum = "userStatusRecently"
	UserStatusLastWeekType  UserStatusEnum = "userStatusLastWeek"
	UserStatusLastMonthType UserStatusEnum = "userStatusLastMonth"
)

func unmarshalUserStatus(rawMsg *json.RawMessage) (UserStatus, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch UserStatusEnum(objMap["@type"].(string)) {
	case UserStatusEmptyType:
		var userStatusEmpty UserStatusEmpty
		err := json.Unmarshal(*rawMsg, &userStatusEmpty)
		return &userStatusEmpty, err

	case UserStatusOnlineType:
		var userStatusOnline UserStatusOnline
		err := json.Unmarshal(*rawMsg, &userStatusOnline)
		return &userStatusOnline, err

	case UserStatusOfflineType:
		var userStatusOffline UserStatusOffline
		err := json.Unmarshal(*rawMsg, &userStatusOffline)
		return &userStatusOffline, err

	case UserStatusRecentlyType:
		var userStatusRecently UserStatusRecently
		err := json.Unmarshal(*rawMsg, &userStatusRecently)
		return &userStatusRecently, err

	case UserStatusLastWeekType:
		var userStatusLastWeek UserStatusLastWeek
		err := json.Unmarshal(*rawMsg, &userStatusLastWeek)
		return &userStatusLastWeek, err

	case UserStatusLastMonthType:
		var userStatusLastMonth UserStatusLastMonth
		err := json.Unmarshal(*rawMsg, &userStatusLastMonth)
		return &userStatusLastMonth, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalUserStatusSlice(rawMsg *json.RawMessage) ([]UserStatus, error) {
	objects := make([]UserStatus, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch UserStatusEnum(objMap["@type"].(string)) {
		case UserStatusEmptyType:
			var userStatusEmpty UserStatusEmpty
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &userStatusEmpty)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &userStatusEmpty)
		case UserStatusOnlineType:
			var userStatusOnline UserStatusOnline
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &userStatusOnline)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &userStatusOnline)
		case UserStatusOfflineType:
			var userStatusOffline UserStatusOffline
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &userStatusOffline)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &userStatusOffline)
		case UserStatusRecentlyType:
			var userStatusRecently UserStatusRecently
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &userStatusRecently)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &userStatusRecently)
		case UserStatusLastWeekType:
			var userStatusLastWeek UserStatusLastWeek
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &userStatusLastWeek)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &userStatusLastWeek)
		case UserStatusLastMonthType:
			var userStatusLastMonth UserStatusLastMonth
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &userStatusLastMonth)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &userStatusLastMonth)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// CallDiscardReason Describes the reason why a call was discarded
type CallDiscardReason interface {
	GetCallDiscardReasonEnum() CallDiscardReasonEnum
}

// CallDiscardReasonEnum Alias for abstract CallDiscardReason 'Sub-Classes', used as constant-enum here
type CallDiscardReasonEnum string

// CallDiscardReason enums
const (
	CallDiscardReasonEmptyType        CallDiscardReasonEnum = "callDiscardReasonEmpty"
	CallDiscardReasonMissedType       CallDiscardReasonEnum = "callDiscardReasonMissed"
	CallDiscardReasonDeclinedType     CallDiscardReasonEnum = "callDiscardReasonDeclined"
	CallDiscardReasonDisconnectedType CallDiscardReasonEnum = "callDiscardReasonDisconnected"
	CallDiscardReasonHungUpType       CallDiscardReasonEnum = "callDiscardReasonHungUp"
)

func unmarshalCallDiscardReason(rawMsg *json.RawMessage) (CallDiscardReason, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch CallDiscardReasonEnum(objMap["@type"].(string)) {
	case CallDiscardReasonEmptyType:
		var callDiscardReasonEmpty CallDiscardReasonEmpty
		err := json.Unmarshal(*rawMsg, &callDiscardReasonEmpty)
		return &callDiscardReasonEmpty, err

	case CallDiscardReasonMissedType:
		var callDiscardReasonMissed CallDiscardReasonMissed
		err := json.Unmarshal(*rawMsg, &callDiscardReasonMissed)
		return &callDiscardReasonMissed, err

	case CallDiscardReasonDeclinedType:
		var callDiscardReasonDeclined CallDiscardReasonDeclined
		err := json.Unmarshal(*rawMsg, &callDiscardReasonDeclined)
		return &callDiscardReasonDeclined, err

	case CallDiscardReasonDisconnectedType:
		var callDiscardReasonDisconnected CallDiscardReasonDisconnected
		err := json.Unmarshal(*rawMsg, &callDiscardReasonDisconnected)
		return &callDiscardReasonDisconnected, err

	case CallDiscardReasonHungUpType:
		var callDiscardReasonHungUp CallDiscardReasonHungUp
		err := json.Unmarshal(*rawMsg, &callDiscardReasonHungUp)
		return &callDiscardReasonHungUp, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalCallDiscardReasonSlice(rawMsg *json.RawMessage) ([]CallDiscardReason, error) {
	objects := make([]CallDiscardReason, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch CallDiscardReasonEnum(objMap["@type"].(string)) {
		case CallDiscardReasonEmptyType:
			var callDiscardReasonEmpty CallDiscardReasonEmpty
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &callDiscardReasonEmpty)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &callDiscardReasonEmpty)
		case CallDiscardReasonMissedType:
			var callDiscardReasonMissed CallDiscardReasonMissed
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &callDiscardReasonMissed)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &callDiscardReasonMissed)
		case CallDiscardReasonDeclinedType:
			var callDiscardReasonDeclined CallDiscardReasonDeclined
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &callDiscardReasonDeclined)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &callDiscardReasonDeclined)
		case CallDiscardReasonDisconnectedType:
			var callDiscardReasonDisconnected CallDiscardReasonDisconnected
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &callDiscardReasonDisconnected)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &callDiscardReasonDisconnected)
		case CallDiscardReasonHungUpType:
			var callDiscardReasonHungUp CallDiscardReasonHungUp
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &callDiscardReasonHungUp)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &callDiscardReasonHungUp)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// CallServerType Describes the type of a call server
type CallServerType interface {
	GetCallServerTypeEnum() CallServerTypeEnum
}

// CallServerTypeEnum Alias for abstract CallServerType 'Sub-Classes', used as constant-enum here
type CallServerTypeEnum string

// CallServerType enums
const (
	CallServerTypeTelegramReflectorType CallServerTypeEnum = "callServerTypeTelegramReflector"
	CallServerTypeWebrtcType            CallServerTypeEnum = "callServerTypeWebrtc"
)

func unmarshalCallServerType(rawMsg *json.RawMessage) (CallServerType, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch CallServerTypeEnum(objMap["@type"].(string)) {
	case CallServerTypeTelegramReflectorType:
		var callServerTypeTelegramReflector CallServerTypeTelegramReflector
		err := json.Unmarshal(*rawMsg, &callServerTypeTelegramReflector)
		return &callServerTypeTelegramReflector, err

	case CallServerTypeWebrtcType:
		var callServerTypeWebrtc CallServerTypeWebrtc
		err := json.Unmarshal(*rawMsg, &callServerTypeWebrtc)
		return &callServerTypeWebrtc, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalCallServerTypeSlice(rawMsg *json.RawMessage) ([]CallServerType, error) {
	objects := make([]CallServerType, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch CallServerTypeEnum(objMap["@type"].(string)) {
		case CallServerTypeTelegramReflectorType:
			var callServerTypeTelegramReflector CallServerTypeTelegramReflector
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &callServerTypeTelegramReflector)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &callServerTypeTelegramReflector)
		case CallServerTypeWebrtcType:
			var callServerTypeWebrtc CallServerTypeWebrtc
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &callServerTypeWebrtc)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &callServerTypeWebrtc)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// CallState Describes the current call state
type CallState interface {
	GetCallStateEnum() CallStateEnum
}

// CallStateEnum Alias for abstract CallState 'Sub-Classes', used as constant-enum here
type CallStateEnum string

// CallState enums
const (
	CallStatePendingType        CallStateEnum = "callStatePending"
	CallStateExchangingKeysType CallStateEnum = "callStateExchangingKeys"
	CallStateReadyType          CallStateEnum = "callStateReady"
	CallStateHangingUpType      CallStateEnum = "callStateHangingUp"
	CallStateDiscardedType      CallStateEnum = "callStateDiscarded"
	CallStateErrorType          CallStateEnum = "callStateError"
)

func unmarshalCallState(rawMsg *json.RawMessage) (CallState, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch CallStateEnum(objMap["@type"].(string)) {
	case CallStatePendingType:
		var callStatePending CallStatePending
		err := json.Unmarshal(*rawMsg, &callStatePending)
		return &callStatePending, err

	case CallStateExchangingKeysType:
		var callStateExchangingKeys CallStateExchangingKeys
		err := json.Unmarshal(*rawMsg, &callStateExchangingKeys)
		return &callStateExchangingKeys, err

	case CallStateReadyType:
		var callStateReady CallStateReady
		err := json.Unmarshal(*rawMsg, &callStateReady)
		return &callStateReady, err

	case CallStateHangingUpType:
		var callStateHangingUp CallStateHangingUp
		err := json.Unmarshal(*rawMsg, &callStateHangingUp)
		return &callStateHangingUp, err

	case CallStateDiscardedType:
		var callStateDiscarded CallStateDiscarded
		err := json.Unmarshal(*rawMsg, &callStateDiscarded)
		return &callStateDiscarded, err

	case CallStateErrorType:
		var callStateError CallStateError
		err := json.Unmarshal(*rawMsg, &callStateError)
		return &callStateError, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalCallStateSlice(rawMsg *json.RawMessage) ([]CallState, error) {
	objects := make([]CallState, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch CallStateEnum(objMap["@type"].(string)) {
		case CallStatePendingType:
			var callStatePending CallStatePending
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &callStatePending)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &callStatePending)
		case CallStateExchangingKeysType:
			var callStateExchangingKeys CallStateExchangingKeys
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &callStateExchangingKeys)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &callStateExchangingKeys)
		case CallStateReadyType:
			var callStateReady CallStateReady
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &callStateReady)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &callStateReady)
		case CallStateHangingUpType:
			var callStateHangingUp CallStateHangingUp
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &callStateHangingUp)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &callStateHangingUp)
		case CallStateDiscardedType:
			var callStateDiscarded CallStateDiscarded
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &callStateDiscarded)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &callStateDiscarded)
		case CallStateErrorType:
			var callStateError CallStateError
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &callStateError)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &callStateError)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// GroupCallVideoQuality Describes the quality of a group call video
type GroupCallVideoQuality interface {
	GetGroupCallVideoQualityEnum() GroupCallVideoQualityEnum
}

// GroupCallVideoQualityEnum Alias for abstract GroupCallVideoQuality 'Sub-Classes', used as constant-enum here
type GroupCallVideoQualityEnum string

// GroupCallVideoQuality enums
const (
	GroupCallVideoQualityThumbnailType GroupCallVideoQualityEnum = "groupCallVideoQualityThumbnail"
	GroupCallVideoQualityMediumType    GroupCallVideoQualityEnum = "groupCallVideoQualityMedium"
	GroupCallVideoQualityFullType      GroupCallVideoQualityEnum = "groupCallVideoQualityFull"
)

func unmarshalGroupCallVideoQuality(rawMsg *json.RawMessage) (GroupCallVideoQuality, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch GroupCallVideoQualityEnum(objMap["@type"].(string)) {
	case GroupCallVideoQualityThumbnailType:
		var groupCallVideoQualityThumbnail GroupCallVideoQualityThumbnail
		err := json.Unmarshal(*rawMsg, &groupCallVideoQualityThumbnail)
		return &groupCallVideoQualityThumbnail, err

	case GroupCallVideoQualityMediumType:
		var groupCallVideoQualityMedium GroupCallVideoQualityMedium
		err := json.Unmarshal(*rawMsg, &groupCallVideoQualityMedium)
		return &groupCallVideoQualityMedium, err

	case GroupCallVideoQualityFullType:
		var groupCallVideoQualityFull GroupCallVideoQualityFull
		err := json.Unmarshal(*rawMsg, &groupCallVideoQualityFull)
		return &groupCallVideoQualityFull, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalGroupCallVideoQualitySlice(rawMsg *json.RawMessage) ([]GroupCallVideoQuality, error) {
	objects := make([]GroupCallVideoQuality, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch GroupCallVideoQualityEnum(objMap["@type"].(string)) {
		case GroupCallVideoQualityThumbnailType:
			var groupCallVideoQualityThumbnail GroupCallVideoQualityThumbnail
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &groupCallVideoQualityThumbnail)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &groupCallVideoQualityThumbnail)
		case GroupCallVideoQualityMediumType:
			var groupCallVideoQualityMedium GroupCallVideoQualityMedium
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &groupCallVideoQualityMedium)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &groupCallVideoQualityMedium)
		case GroupCallVideoQualityFullType:
			var groupCallVideoQualityFull GroupCallVideoQualityFull
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &groupCallVideoQualityFull)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &groupCallVideoQualityFull)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// CallProblem Describes the exact type of a problem with a call
type CallProblem interface {
	GetCallProblemEnum() CallProblemEnum
}

// CallProblemEnum Alias for abstract CallProblem 'Sub-Classes', used as constant-enum here
type CallProblemEnum string

// CallProblem enums
const (
	CallProblemEchoType            CallProblemEnum = "callProblemEcho"
	CallProblemNoiseType           CallProblemEnum = "callProblemNoise"
	CallProblemInterruptionsType   CallProblemEnum = "callProblemInterruptions"
	CallProblemDistortedSpeechType CallProblemEnum = "callProblemDistortedSpeech"
	CallProblemSilentLocalType     CallProblemEnum = "callProblemSilentLocal"
	CallProblemSilentRemoteType    CallProblemEnum = "callProblemSilentRemote"
	CallProblemDroppedType         CallProblemEnum = "callProblemDropped"
	CallProblemDistortedVideoType  CallProblemEnum = "callProblemDistortedVideo"
	CallProblemPixelatedVideoType  CallProblemEnum = "callProblemPixelatedVideo"
)

func unmarshalCallProblem(rawMsg *json.RawMessage) (CallProblem, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch CallProblemEnum(objMap["@type"].(string)) {
	case CallProblemEchoType:
		var callProblemEcho CallProblemEcho
		err := json.Unmarshal(*rawMsg, &callProblemEcho)
		return &callProblemEcho, err

	case CallProblemNoiseType:
		var callProblemNoise CallProblemNoise
		err := json.Unmarshal(*rawMsg, &callProblemNoise)
		return &callProblemNoise, err

	case CallProblemInterruptionsType:
		var callProblemInterruptions CallProblemInterruptions
		err := json.Unmarshal(*rawMsg, &callProblemInterruptions)
		return &callProblemInterruptions, err

	case CallProblemDistortedSpeechType:
		var callProblemDistortedSpeech CallProblemDistortedSpeech
		err := json.Unmarshal(*rawMsg, &callProblemDistortedSpeech)
		return &callProblemDistortedSpeech, err

	case CallProblemSilentLocalType:
		var callProblemSilentLocal CallProblemSilentLocal
		err := json.Unmarshal(*rawMsg, &callProblemSilentLocal)
		return &callProblemSilentLocal, err

	case CallProblemSilentRemoteType:
		var callProblemSilentRemote CallProblemSilentRemote
		err := json.Unmarshal(*rawMsg, &callProblemSilentRemote)
		return &callProblemSilentRemote, err

	case CallProblemDroppedType:
		var callProblemDropped CallProblemDropped
		err := json.Unmarshal(*rawMsg, &callProblemDropped)
		return &callProblemDropped, err

	case CallProblemDistortedVideoType:
		var callProblemDistortedVideo CallProblemDistortedVideo
		err := json.Unmarshal(*rawMsg, &callProblemDistortedVideo)
		return &callProblemDistortedVideo, err

	case CallProblemPixelatedVideoType:
		var callProblemPixelatedVideo CallProblemPixelatedVideo
		err := json.Unmarshal(*rawMsg, &callProblemPixelatedVideo)
		return &callProblemPixelatedVideo, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalCallProblemSlice(rawMsg *json.RawMessage) ([]CallProblem, error) {
	objects := make([]CallProblem, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch CallProblemEnum(objMap["@type"].(string)) {
		case CallProblemEchoType:
			var callProblemEcho CallProblemEcho
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &callProblemEcho)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &callProblemEcho)
		case CallProblemNoiseType:
			var callProblemNoise CallProblemNoise
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &callProblemNoise)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &callProblemNoise)
		case CallProblemInterruptionsType:
			var callProblemInterruptions CallProblemInterruptions
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &callProblemInterruptions)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &callProblemInterruptions)
		case CallProblemDistortedSpeechType:
			var callProblemDistortedSpeech CallProblemDistortedSpeech
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &callProblemDistortedSpeech)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &callProblemDistortedSpeech)
		case CallProblemSilentLocalType:
			var callProblemSilentLocal CallProblemSilentLocal
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &callProblemSilentLocal)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &callProblemSilentLocal)
		case CallProblemSilentRemoteType:
			var callProblemSilentRemote CallProblemSilentRemote
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &callProblemSilentRemote)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &callProblemSilentRemote)
		case CallProblemDroppedType:
			var callProblemDropped CallProblemDropped
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &callProblemDropped)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &callProblemDropped)
		case CallProblemDistortedVideoType:
			var callProblemDistortedVideo CallProblemDistortedVideo
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &callProblemDistortedVideo)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &callProblemDistortedVideo)
		case CallProblemPixelatedVideoType:
			var callProblemPixelatedVideo CallProblemPixelatedVideo
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &callProblemPixelatedVideo)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &callProblemPixelatedVideo)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// DiceStickers Contains animated stickers which must be used for dice animation rendering
type DiceStickers interface {
	GetDiceStickersEnum() DiceStickersEnum
}

// DiceStickersEnum Alias for abstract DiceStickers 'Sub-Classes', used as constant-enum here
type DiceStickersEnum string

// DiceStickers enums
const (
	DiceStickersRegularType     DiceStickersEnum = "diceStickersRegular"
	DiceStickersSlotMachineType DiceStickersEnum = "diceStickersSlotMachine"
)

func unmarshalDiceStickers(rawMsg *json.RawMessage) (DiceStickers, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch DiceStickersEnum(objMap["@type"].(string)) {
	case DiceStickersRegularType:
		var diceStickersRegular DiceStickersRegular
		err := json.Unmarshal(*rawMsg, &diceStickersRegular)
		return &diceStickersRegular, err

	case DiceStickersSlotMachineType:
		var diceStickersSlotMachine DiceStickersSlotMachine
		err := json.Unmarshal(*rawMsg, &diceStickersSlotMachine)
		return &diceStickersSlotMachine, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalDiceStickersSlice(rawMsg *json.RawMessage) ([]DiceStickers, error) {
	objects := make([]DiceStickers, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch DiceStickersEnum(objMap["@type"].(string)) {
		case DiceStickersRegularType:
			var diceStickersRegular DiceStickersRegular
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &diceStickersRegular)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &diceStickersRegular)
		case DiceStickersSlotMachineType:
			var diceStickersSlotMachine DiceStickersSlotMachine
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &diceStickersSlotMachine)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &diceStickersSlotMachine)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// InputInlineQueryResult Represents a single result of an inline query; for bots only
type InputInlineQueryResult interface {
	GetInputInlineQueryResultEnum() InputInlineQueryResultEnum
}

// InputInlineQueryResultEnum Alias for abstract InputInlineQueryResult 'Sub-Classes', used as constant-enum here
type InputInlineQueryResultEnum string

// InputInlineQueryResult enums
const (
	InputInlineQueryResultAnimationType InputInlineQueryResultEnum = "inputInlineQueryResultAnimation"
	InputInlineQueryResultArticleType   InputInlineQueryResultEnum = "inputInlineQueryResultArticle"
	InputInlineQueryResultAudioType     InputInlineQueryResultEnum = "inputInlineQueryResultAudio"
	InputInlineQueryResultContactType   InputInlineQueryResultEnum = "inputInlineQueryResultContact"
	InputInlineQueryResultDocumentType  InputInlineQueryResultEnum = "inputInlineQueryResultDocument"
	InputInlineQueryResultGameType      InputInlineQueryResultEnum = "inputInlineQueryResultGame"
	InputInlineQueryResultLocationType  InputInlineQueryResultEnum = "inputInlineQueryResultLocation"
	InputInlineQueryResultPhotoType     InputInlineQueryResultEnum = "inputInlineQueryResultPhoto"
	InputInlineQueryResultStickerType   InputInlineQueryResultEnum = "inputInlineQueryResultSticker"
	InputInlineQueryResultVenueType     InputInlineQueryResultEnum = "inputInlineQueryResultVenue"
	InputInlineQueryResultVideoType     InputInlineQueryResultEnum = "inputInlineQueryResultVideo"
	InputInlineQueryResultVoiceNoteType InputInlineQueryResultEnum = "inputInlineQueryResultVoiceNote"
)

func unmarshalInputInlineQueryResult(rawMsg *json.RawMessage) (InputInlineQueryResult, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch InputInlineQueryResultEnum(objMap["@type"].(string)) {
	case InputInlineQueryResultAnimationType:
		var inputInlineQueryResultAnimation InputInlineQueryResultAnimation
		err := json.Unmarshal(*rawMsg, &inputInlineQueryResultAnimation)
		return &inputInlineQueryResultAnimation, err

	case InputInlineQueryResultArticleType:
		var inputInlineQueryResultArticle InputInlineQueryResultArticle
		err := json.Unmarshal(*rawMsg, &inputInlineQueryResultArticle)
		return &inputInlineQueryResultArticle, err

	case InputInlineQueryResultAudioType:
		var inputInlineQueryResultAudio InputInlineQueryResultAudio
		err := json.Unmarshal(*rawMsg, &inputInlineQueryResultAudio)
		return &inputInlineQueryResultAudio, err

	case InputInlineQueryResultContactType:
		var inputInlineQueryResultContact InputInlineQueryResultContact
		err := json.Unmarshal(*rawMsg, &inputInlineQueryResultContact)
		return &inputInlineQueryResultContact, err

	case InputInlineQueryResultDocumentType:
		var inputInlineQueryResultDocument InputInlineQueryResultDocument
		err := json.Unmarshal(*rawMsg, &inputInlineQueryResultDocument)
		return &inputInlineQueryResultDocument, err

	case InputInlineQueryResultGameType:
		var inputInlineQueryResultGame InputInlineQueryResultGame
		err := json.Unmarshal(*rawMsg, &inputInlineQueryResultGame)
		return &inputInlineQueryResultGame, err

	case InputInlineQueryResultLocationType:
		var inputInlineQueryResultLocation InputInlineQueryResultLocation
		err := json.Unmarshal(*rawMsg, &inputInlineQueryResultLocation)
		return &inputInlineQueryResultLocation, err

	case InputInlineQueryResultPhotoType:
		var inputInlineQueryResultPhoto InputInlineQueryResultPhoto
		err := json.Unmarshal(*rawMsg, &inputInlineQueryResultPhoto)
		return &inputInlineQueryResultPhoto, err

	case InputInlineQueryResultStickerType:
		var inputInlineQueryResultSticker InputInlineQueryResultSticker
		err := json.Unmarshal(*rawMsg, &inputInlineQueryResultSticker)
		return &inputInlineQueryResultSticker, err

	case InputInlineQueryResultVenueType:
		var inputInlineQueryResultVenue InputInlineQueryResultVenue
		err := json.Unmarshal(*rawMsg, &inputInlineQueryResultVenue)
		return &inputInlineQueryResultVenue, err

	case InputInlineQueryResultVideoType:
		var inputInlineQueryResultVideo InputInlineQueryResultVideo
		err := json.Unmarshal(*rawMsg, &inputInlineQueryResultVideo)
		return &inputInlineQueryResultVideo, err

	case InputInlineQueryResultVoiceNoteType:
		var inputInlineQueryResultVoiceNote InputInlineQueryResultVoiceNote
		err := json.Unmarshal(*rawMsg, &inputInlineQueryResultVoiceNote)
		return &inputInlineQueryResultVoiceNote, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalInputInlineQueryResultSlice(rawMsg *json.RawMessage) ([]InputInlineQueryResult, error) {
	objects := make([]InputInlineQueryResult, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch InputInlineQueryResultEnum(objMap["@type"].(string)) {
		case InputInlineQueryResultAnimationType:
			var inputInlineQueryResultAnimation InputInlineQueryResultAnimation
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputInlineQueryResultAnimation)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputInlineQueryResultAnimation)
		case InputInlineQueryResultArticleType:
			var inputInlineQueryResultArticle InputInlineQueryResultArticle
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputInlineQueryResultArticle)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputInlineQueryResultArticle)
		case InputInlineQueryResultAudioType:
			var inputInlineQueryResultAudio InputInlineQueryResultAudio
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputInlineQueryResultAudio)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputInlineQueryResultAudio)
		case InputInlineQueryResultContactType:
			var inputInlineQueryResultContact InputInlineQueryResultContact
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputInlineQueryResultContact)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputInlineQueryResultContact)
		case InputInlineQueryResultDocumentType:
			var inputInlineQueryResultDocument InputInlineQueryResultDocument
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputInlineQueryResultDocument)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputInlineQueryResultDocument)
		case InputInlineQueryResultGameType:
			var inputInlineQueryResultGame InputInlineQueryResultGame
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputInlineQueryResultGame)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputInlineQueryResultGame)
		case InputInlineQueryResultLocationType:
			var inputInlineQueryResultLocation InputInlineQueryResultLocation
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputInlineQueryResultLocation)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputInlineQueryResultLocation)
		case InputInlineQueryResultPhotoType:
			var inputInlineQueryResultPhoto InputInlineQueryResultPhoto
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputInlineQueryResultPhoto)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputInlineQueryResultPhoto)
		case InputInlineQueryResultStickerType:
			var inputInlineQueryResultSticker InputInlineQueryResultSticker
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputInlineQueryResultSticker)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputInlineQueryResultSticker)
		case InputInlineQueryResultVenueType:
			var inputInlineQueryResultVenue InputInlineQueryResultVenue
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputInlineQueryResultVenue)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputInlineQueryResultVenue)
		case InputInlineQueryResultVideoType:
			var inputInlineQueryResultVideo InputInlineQueryResultVideo
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputInlineQueryResultVideo)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputInlineQueryResultVideo)
		case InputInlineQueryResultVoiceNoteType:
			var inputInlineQueryResultVoiceNote InputInlineQueryResultVoiceNote
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputInlineQueryResultVoiceNote)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputInlineQueryResultVoiceNote)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// InlineQueryResult Represents a single result of an inline query
type InlineQueryResult interface {
	GetInlineQueryResultEnum() InlineQueryResultEnum
}

// InlineQueryResultEnum Alias for abstract InlineQueryResult 'Sub-Classes', used as constant-enum here
type InlineQueryResultEnum string

// InlineQueryResult enums
const (
	InlineQueryResultArticleType   InlineQueryResultEnum = "inlineQueryResultArticle"
	InlineQueryResultContactType   InlineQueryResultEnum = "inlineQueryResultContact"
	InlineQueryResultLocationType  InlineQueryResultEnum = "inlineQueryResultLocation"
	InlineQueryResultVenueType     InlineQueryResultEnum = "inlineQueryResultVenue"
	InlineQueryResultGameType      InlineQueryResultEnum = "inlineQueryResultGame"
	InlineQueryResultAnimationType InlineQueryResultEnum = "inlineQueryResultAnimation"
	InlineQueryResultAudioType     InlineQueryResultEnum = "inlineQueryResultAudio"
	InlineQueryResultDocumentType  InlineQueryResultEnum = "inlineQueryResultDocument"
	InlineQueryResultPhotoType     InlineQueryResultEnum = "inlineQueryResultPhoto"
	InlineQueryResultStickerType   InlineQueryResultEnum = "inlineQueryResultSticker"
	InlineQueryResultVideoType     InlineQueryResultEnum = "inlineQueryResultVideo"
	InlineQueryResultVoiceNoteType InlineQueryResultEnum = "inlineQueryResultVoiceNote"
)

func unmarshalInlineQueryResult(rawMsg *json.RawMessage) (InlineQueryResult, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch InlineQueryResultEnum(objMap["@type"].(string)) {
	case InlineQueryResultArticleType:
		var inlineQueryResultArticle InlineQueryResultArticle
		err := json.Unmarshal(*rawMsg, &inlineQueryResultArticle)
		return &inlineQueryResultArticle, err

	case InlineQueryResultContactType:
		var inlineQueryResultContact InlineQueryResultContact
		err := json.Unmarshal(*rawMsg, &inlineQueryResultContact)
		return &inlineQueryResultContact, err

	case InlineQueryResultLocationType:
		var inlineQueryResultLocation InlineQueryResultLocation
		err := json.Unmarshal(*rawMsg, &inlineQueryResultLocation)
		return &inlineQueryResultLocation, err

	case InlineQueryResultVenueType:
		var inlineQueryResultVenue InlineQueryResultVenue
		err := json.Unmarshal(*rawMsg, &inlineQueryResultVenue)
		return &inlineQueryResultVenue, err

	case InlineQueryResultGameType:
		var inlineQueryResultGame InlineQueryResultGame
		err := json.Unmarshal(*rawMsg, &inlineQueryResultGame)
		return &inlineQueryResultGame, err

	case InlineQueryResultAnimationType:
		var inlineQueryResultAnimation InlineQueryResultAnimation
		err := json.Unmarshal(*rawMsg, &inlineQueryResultAnimation)
		return &inlineQueryResultAnimation, err

	case InlineQueryResultAudioType:
		var inlineQueryResultAudio InlineQueryResultAudio
		err := json.Unmarshal(*rawMsg, &inlineQueryResultAudio)
		return &inlineQueryResultAudio, err

	case InlineQueryResultDocumentType:
		var inlineQueryResultDocument InlineQueryResultDocument
		err := json.Unmarshal(*rawMsg, &inlineQueryResultDocument)
		return &inlineQueryResultDocument, err

	case InlineQueryResultPhotoType:
		var inlineQueryResultPhoto InlineQueryResultPhoto
		err := json.Unmarshal(*rawMsg, &inlineQueryResultPhoto)
		return &inlineQueryResultPhoto, err

	case InlineQueryResultStickerType:
		var inlineQueryResultSticker InlineQueryResultSticker
		err := json.Unmarshal(*rawMsg, &inlineQueryResultSticker)
		return &inlineQueryResultSticker, err

	case InlineQueryResultVideoType:
		var inlineQueryResultVideo InlineQueryResultVideo
		err := json.Unmarshal(*rawMsg, &inlineQueryResultVideo)
		return &inlineQueryResultVideo, err

	case InlineQueryResultVoiceNoteType:
		var inlineQueryResultVoiceNote InlineQueryResultVoiceNote
		err := json.Unmarshal(*rawMsg, &inlineQueryResultVoiceNote)
		return &inlineQueryResultVoiceNote, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalInlineQueryResultSlice(rawMsg *json.RawMessage) ([]InlineQueryResult, error) {
	objects := make([]InlineQueryResult, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch InlineQueryResultEnum(objMap["@type"].(string)) {
		case InlineQueryResultArticleType:
			var inlineQueryResultArticle InlineQueryResultArticle
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inlineQueryResultArticle)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inlineQueryResultArticle)
		case InlineQueryResultContactType:
			var inlineQueryResultContact InlineQueryResultContact
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inlineQueryResultContact)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inlineQueryResultContact)
		case InlineQueryResultLocationType:
			var inlineQueryResultLocation InlineQueryResultLocation
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inlineQueryResultLocation)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inlineQueryResultLocation)
		case InlineQueryResultVenueType:
			var inlineQueryResultVenue InlineQueryResultVenue
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inlineQueryResultVenue)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inlineQueryResultVenue)
		case InlineQueryResultGameType:
			var inlineQueryResultGame InlineQueryResultGame
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inlineQueryResultGame)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inlineQueryResultGame)
		case InlineQueryResultAnimationType:
			var inlineQueryResultAnimation InlineQueryResultAnimation
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inlineQueryResultAnimation)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inlineQueryResultAnimation)
		case InlineQueryResultAudioType:
			var inlineQueryResultAudio InlineQueryResultAudio
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inlineQueryResultAudio)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inlineQueryResultAudio)
		case InlineQueryResultDocumentType:
			var inlineQueryResultDocument InlineQueryResultDocument
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inlineQueryResultDocument)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inlineQueryResultDocument)
		case InlineQueryResultPhotoType:
			var inlineQueryResultPhoto InlineQueryResultPhoto
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inlineQueryResultPhoto)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inlineQueryResultPhoto)
		case InlineQueryResultStickerType:
			var inlineQueryResultSticker InlineQueryResultSticker
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inlineQueryResultSticker)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inlineQueryResultSticker)
		case InlineQueryResultVideoType:
			var inlineQueryResultVideo InlineQueryResultVideo
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inlineQueryResultVideo)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inlineQueryResultVideo)
		case InlineQueryResultVoiceNoteType:
			var inlineQueryResultVoiceNote InlineQueryResultVoiceNote
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inlineQueryResultVoiceNote)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inlineQueryResultVoiceNote)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// CallbackQueryPayload Represents a payload of a callback query
type CallbackQueryPayload interface {
	GetCallbackQueryPayloadEnum() CallbackQueryPayloadEnum
}

// CallbackQueryPayloadEnum Alias for abstract CallbackQueryPayload 'Sub-Classes', used as constant-enum here
type CallbackQueryPayloadEnum string

// CallbackQueryPayload enums
const (
	CallbackQueryPayloadDataType             CallbackQueryPayloadEnum = "callbackQueryPayloadData"
	CallbackQueryPayloadDataWithPasswordType CallbackQueryPayloadEnum = "callbackQueryPayloadDataWithPassword"
	CallbackQueryPayloadGameType             CallbackQueryPayloadEnum = "callbackQueryPayloadGame"
)

func unmarshalCallbackQueryPayload(rawMsg *json.RawMessage) (CallbackQueryPayload, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch CallbackQueryPayloadEnum(objMap["@type"].(string)) {
	case CallbackQueryPayloadDataType:
		var callbackQueryPayloadData CallbackQueryPayloadData
		err := json.Unmarshal(*rawMsg, &callbackQueryPayloadData)
		return &callbackQueryPayloadData, err

	case CallbackQueryPayloadDataWithPasswordType:
		var callbackQueryPayloadDataWithPassword CallbackQueryPayloadDataWithPassword
		err := json.Unmarshal(*rawMsg, &callbackQueryPayloadDataWithPassword)
		return &callbackQueryPayloadDataWithPassword, err

	case CallbackQueryPayloadGameType:
		var callbackQueryPayloadGame CallbackQueryPayloadGame
		err := json.Unmarshal(*rawMsg, &callbackQueryPayloadGame)
		return &callbackQueryPayloadGame, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalCallbackQueryPayloadSlice(rawMsg *json.RawMessage) ([]CallbackQueryPayload, error) {
	objects := make([]CallbackQueryPayload, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch CallbackQueryPayloadEnum(objMap["@type"].(string)) {
		case CallbackQueryPayloadDataType:
			var callbackQueryPayloadData CallbackQueryPayloadData
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &callbackQueryPayloadData)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &callbackQueryPayloadData)
		case CallbackQueryPayloadDataWithPasswordType:
			var callbackQueryPayloadDataWithPassword CallbackQueryPayloadDataWithPassword
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &callbackQueryPayloadDataWithPassword)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &callbackQueryPayloadDataWithPassword)
		case CallbackQueryPayloadGameType:
			var callbackQueryPayloadGame CallbackQueryPayloadGame
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &callbackQueryPayloadGame)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &callbackQueryPayloadGame)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// ChatEventAction Represents a chat event
type ChatEventAction interface {
	GetChatEventActionEnum() ChatEventActionEnum
}

// ChatEventActionEnum Alias for abstract ChatEventAction 'Sub-Classes', used as constant-enum here
type ChatEventActionEnum string

// ChatEventAction enums
const (
	ChatEventMessageEditedType                          ChatEventActionEnum = "chatEventMessageEdited"
	ChatEventMessageDeletedType                         ChatEventActionEnum = "chatEventMessageDeleted"
	ChatEventPollStoppedType                            ChatEventActionEnum = "chatEventPollStopped"
	ChatEventMessagePinnedType                          ChatEventActionEnum = "chatEventMessagePinned"
	ChatEventMessageUnpinnedType                        ChatEventActionEnum = "chatEventMessageUnpinned"
	ChatEventMemberJoinedType                           ChatEventActionEnum = "chatEventMemberJoined"
	ChatEventMemberJoinedByInviteLinkType               ChatEventActionEnum = "chatEventMemberJoinedByInviteLink"
	ChatEventMemberJoinedByRequestType                  ChatEventActionEnum = "chatEventMemberJoinedByRequest"
	ChatEventMemberLeftType                             ChatEventActionEnum = "chatEventMemberLeft"
	ChatEventMemberInvitedType                          ChatEventActionEnum = "chatEventMemberInvited"
	ChatEventMemberPromotedType                         ChatEventActionEnum = "chatEventMemberPromoted"
	ChatEventMemberRestrictedType                       ChatEventActionEnum = "chatEventMemberRestricted"
	ChatEventTitleChangedType                           ChatEventActionEnum = "chatEventTitleChanged"
	ChatEventPermissionsChangedType                     ChatEventActionEnum = "chatEventPermissionsChanged"
	ChatEventDescriptionChangedType                     ChatEventActionEnum = "chatEventDescriptionChanged"
	ChatEventUsernameChangedType                        ChatEventActionEnum = "chatEventUsernameChanged"
	ChatEventPhotoChangedType                           ChatEventActionEnum = "chatEventPhotoChanged"
	ChatEventInvitesToggledType                         ChatEventActionEnum = "chatEventInvitesToggled"
	ChatEventLinkedChatChangedType                      ChatEventActionEnum = "chatEventLinkedChatChanged"
	ChatEventSlowModeDelayChangedType                   ChatEventActionEnum = "chatEventSlowModeDelayChanged"
	ChatEventMessageTTLChangedType                      ChatEventActionEnum = "chatEventMessageTtlChanged"
	ChatEventSignMessagesToggledType                    ChatEventActionEnum = "chatEventSignMessagesToggled"
	ChatEventHasProtectedContentToggledType             ChatEventActionEnum = "chatEventHasProtectedContentToggled"
	ChatEventStickerSetChangedType                      ChatEventActionEnum = "chatEventStickerSetChanged"
	ChatEventLocationChangedType                        ChatEventActionEnum = "chatEventLocationChanged"
	ChatEventIsAllHistoryAvailableToggledType           ChatEventActionEnum = "chatEventIsAllHistoryAvailableToggled"
	ChatEventInviteLinkEditedType                       ChatEventActionEnum = "chatEventInviteLinkEdited"
	ChatEventInviteLinkRevokedType                      ChatEventActionEnum = "chatEventInviteLinkRevoked"
	ChatEventInviteLinkDeletedType                      ChatEventActionEnum = "chatEventInviteLinkDeleted"
	ChatEventVideoChatCreatedType                       ChatEventActionEnum = "chatEventVideoChatCreated"
	ChatEventVideoChatEndedType                         ChatEventActionEnum = "chatEventVideoChatEnded"
	ChatEventVideoChatParticipantIsMutedToggledType     ChatEventActionEnum = "chatEventVideoChatParticipantIsMutedToggled"
	ChatEventVideoChatParticipantVolumeLevelChangedType ChatEventActionEnum = "chatEventVideoChatParticipantVolumeLevelChanged"
	ChatEventVideoChatMuteNewParticipantsToggledType    ChatEventActionEnum = "chatEventVideoChatMuteNewParticipantsToggled"
)

func unmarshalChatEventAction(rawMsg *json.RawMessage) (ChatEventAction, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch ChatEventActionEnum(objMap["@type"].(string)) {
	case ChatEventMessageEditedType:
		var chatEventMessageEdited ChatEventMessageEdited
		err := json.Unmarshal(*rawMsg, &chatEventMessageEdited)
		return &chatEventMessageEdited, err

	case ChatEventMessageDeletedType:
		var chatEventMessageDeleted ChatEventMessageDeleted
		err := json.Unmarshal(*rawMsg, &chatEventMessageDeleted)
		return &chatEventMessageDeleted, err

	case ChatEventPollStoppedType:
		var chatEventPollStopped ChatEventPollStopped
		err := json.Unmarshal(*rawMsg, &chatEventPollStopped)
		return &chatEventPollStopped, err

	case ChatEventMessagePinnedType:
		var chatEventMessagePinned ChatEventMessagePinned
		err := json.Unmarshal(*rawMsg, &chatEventMessagePinned)
		return &chatEventMessagePinned, err

	case ChatEventMessageUnpinnedType:
		var chatEventMessageUnpinned ChatEventMessageUnpinned
		err := json.Unmarshal(*rawMsg, &chatEventMessageUnpinned)
		return &chatEventMessageUnpinned, err

	case ChatEventMemberJoinedType:
		var chatEventMemberJoined ChatEventMemberJoined
		err := json.Unmarshal(*rawMsg, &chatEventMemberJoined)
		return &chatEventMemberJoined, err

	case ChatEventMemberJoinedByInviteLinkType:
		var chatEventMemberJoinedByInviteLink ChatEventMemberJoinedByInviteLink
		err := json.Unmarshal(*rawMsg, &chatEventMemberJoinedByInviteLink)
		return &chatEventMemberJoinedByInviteLink, err

	case ChatEventMemberJoinedByRequestType:
		var chatEventMemberJoinedByRequest ChatEventMemberJoinedByRequest
		err := json.Unmarshal(*rawMsg, &chatEventMemberJoinedByRequest)
		return &chatEventMemberJoinedByRequest, err

	case ChatEventMemberLeftType:
		var chatEventMemberLeft ChatEventMemberLeft
		err := json.Unmarshal(*rawMsg, &chatEventMemberLeft)
		return &chatEventMemberLeft, err

	case ChatEventMemberInvitedType:
		var chatEventMemberInvited ChatEventMemberInvited
		err := json.Unmarshal(*rawMsg, &chatEventMemberInvited)
		return &chatEventMemberInvited, err

	case ChatEventMemberPromotedType:
		var chatEventMemberPromoted ChatEventMemberPromoted
		err := json.Unmarshal(*rawMsg, &chatEventMemberPromoted)
		return &chatEventMemberPromoted, err

	case ChatEventMemberRestrictedType:
		var chatEventMemberRestricted ChatEventMemberRestricted
		err := json.Unmarshal(*rawMsg, &chatEventMemberRestricted)
		return &chatEventMemberRestricted, err

	case ChatEventTitleChangedType:
		var chatEventTitleChanged ChatEventTitleChanged
		err := json.Unmarshal(*rawMsg, &chatEventTitleChanged)
		return &chatEventTitleChanged, err

	case ChatEventPermissionsChangedType:
		var chatEventPermissionsChanged ChatEventPermissionsChanged
		err := json.Unmarshal(*rawMsg, &chatEventPermissionsChanged)
		return &chatEventPermissionsChanged, err

	case ChatEventDescriptionChangedType:
		var chatEventDescriptionChanged ChatEventDescriptionChanged
		err := json.Unmarshal(*rawMsg, &chatEventDescriptionChanged)
		return &chatEventDescriptionChanged, err

	case ChatEventUsernameChangedType:
		var chatEventUsernameChanged ChatEventUsernameChanged
		err := json.Unmarshal(*rawMsg, &chatEventUsernameChanged)
		return &chatEventUsernameChanged, err

	case ChatEventPhotoChangedType:
		var chatEventPhotoChanged ChatEventPhotoChanged
		err := json.Unmarshal(*rawMsg, &chatEventPhotoChanged)
		return &chatEventPhotoChanged, err

	case ChatEventInvitesToggledType:
		var chatEventInvitesToggled ChatEventInvitesToggled
		err := json.Unmarshal(*rawMsg, &chatEventInvitesToggled)
		return &chatEventInvitesToggled, err

	case ChatEventLinkedChatChangedType:
		var chatEventLinkedChatChanged ChatEventLinkedChatChanged
		err := json.Unmarshal(*rawMsg, &chatEventLinkedChatChanged)
		return &chatEventLinkedChatChanged, err

	case ChatEventSlowModeDelayChangedType:
		var chatEventSlowModeDelayChanged ChatEventSlowModeDelayChanged
		err := json.Unmarshal(*rawMsg, &chatEventSlowModeDelayChanged)
		return &chatEventSlowModeDelayChanged, err

	case ChatEventMessageTTLChangedType:
		var chatEventMessageTTLChanged ChatEventMessageTTLChanged
		err := json.Unmarshal(*rawMsg, &chatEventMessageTTLChanged)
		return &chatEventMessageTTLChanged, err

	case ChatEventSignMessagesToggledType:
		var chatEventSignMessagesToggled ChatEventSignMessagesToggled
		err := json.Unmarshal(*rawMsg, &chatEventSignMessagesToggled)
		return &chatEventSignMessagesToggled, err

	case ChatEventHasProtectedContentToggledType:
		var chatEventHasProtectedContentToggled ChatEventHasProtectedContentToggled
		err := json.Unmarshal(*rawMsg, &chatEventHasProtectedContentToggled)
		return &chatEventHasProtectedContentToggled, err

	case ChatEventStickerSetChangedType:
		var chatEventStickerSetChanged ChatEventStickerSetChanged
		err := json.Unmarshal(*rawMsg, &chatEventStickerSetChanged)
		return &chatEventStickerSetChanged, err

	case ChatEventLocationChangedType:
		var chatEventLocationChanged ChatEventLocationChanged
		err := json.Unmarshal(*rawMsg, &chatEventLocationChanged)
		return &chatEventLocationChanged, err

	case ChatEventIsAllHistoryAvailableToggledType:
		var chatEventIsAllHistoryAvailableToggled ChatEventIsAllHistoryAvailableToggled
		err := json.Unmarshal(*rawMsg, &chatEventIsAllHistoryAvailableToggled)
		return &chatEventIsAllHistoryAvailableToggled, err

	case ChatEventInviteLinkEditedType:
		var chatEventInviteLinkEdited ChatEventInviteLinkEdited
		err := json.Unmarshal(*rawMsg, &chatEventInviteLinkEdited)
		return &chatEventInviteLinkEdited, err

	case ChatEventInviteLinkRevokedType:
		var chatEventInviteLinkRevoked ChatEventInviteLinkRevoked
		err := json.Unmarshal(*rawMsg, &chatEventInviteLinkRevoked)
		return &chatEventInviteLinkRevoked, err

	case ChatEventInviteLinkDeletedType:
		var chatEventInviteLinkDeleted ChatEventInviteLinkDeleted
		err := json.Unmarshal(*rawMsg, &chatEventInviteLinkDeleted)
		return &chatEventInviteLinkDeleted, err

	case ChatEventVideoChatCreatedType:
		var chatEventVideoChatCreated ChatEventVideoChatCreated
		err := json.Unmarshal(*rawMsg, &chatEventVideoChatCreated)
		return &chatEventVideoChatCreated, err

	case ChatEventVideoChatEndedType:
		var chatEventVideoChatEnded ChatEventVideoChatEnded
		err := json.Unmarshal(*rawMsg, &chatEventVideoChatEnded)
		return &chatEventVideoChatEnded, err

	case ChatEventVideoChatParticipantIsMutedToggledType:
		var chatEventVideoChatParticipantIsMutedToggled ChatEventVideoChatParticipantIsMutedToggled
		err := json.Unmarshal(*rawMsg, &chatEventVideoChatParticipantIsMutedToggled)
		return &chatEventVideoChatParticipantIsMutedToggled, err

	case ChatEventVideoChatParticipantVolumeLevelChangedType:
		var chatEventVideoChatParticipantVolumeLevelChanged ChatEventVideoChatParticipantVolumeLevelChanged
		err := json.Unmarshal(*rawMsg, &chatEventVideoChatParticipantVolumeLevelChanged)
		return &chatEventVideoChatParticipantVolumeLevelChanged, err

	case ChatEventVideoChatMuteNewParticipantsToggledType:
		var chatEventVideoChatMuteNewParticipantsToggled ChatEventVideoChatMuteNewParticipantsToggled
		err := json.Unmarshal(*rawMsg, &chatEventVideoChatMuteNewParticipantsToggled)
		return &chatEventVideoChatMuteNewParticipantsToggled, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalChatEventActionSlice(rawMsg *json.RawMessage) ([]ChatEventAction, error) {
	objects := make([]ChatEventAction, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch ChatEventActionEnum(objMap["@type"].(string)) {
		case ChatEventMessageEditedType:
			var chatEventMessageEdited ChatEventMessageEdited
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatEventMessageEdited)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatEventMessageEdited)
		case ChatEventMessageDeletedType:
			var chatEventMessageDeleted ChatEventMessageDeleted
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatEventMessageDeleted)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatEventMessageDeleted)
		case ChatEventPollStoppedType:
			var chatEventPollStopped ChatEventPollStopped
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatEventPollStopped)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatEventPollStopped)
		case ChatEventMessagePinnedType:
			var chatEventMessagePinned ChatEventMessagePinned
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatEventMessagePinned)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatEventMessagePinned)
		case ChatEventMessageUnpinnedType:
			var chatEventMessageUnpinned ChatEventMessageUnpinned
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatEventMessageUnpinned)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatEventMessageUnpinned)
		case ChatEventMemberJoinedType:
			var chatEventMemberJoined ChatEventMemberJoined
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatEventMemberJoined)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatEventMemberJoined)
		case ChatEventMemberJoinedByInviteLinkType:
			var chatEventMemberJoinedByInviteLink ChatEventMemberJoinedByInviteLink
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatEventMemberJoinedByInviteLink)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatEventMemberJoinedByInviteLink)
		case ChatEventMemberJoinedByRequestType:
			var chatEventMemberJoinedByRequest ChatEventMemberJoinedByRequest
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatEventMemberJoinedByRequest)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatEventMemberJoinedByRequest)
		case ChatEventMemberLeftType:
			var chatEventMemberLeft ChatEventMemberLeft
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatEventMemberLeft)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatEventMemberLeft)
		case ChatEventMemberInvitedType:
			var chatEventMemberInvited ChatEventMemberInvited
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatEventMemberInvited)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatEventMemberInvited)
		case ChatEventMemberPromotedType:
			var chatEventMemberPromoted ChatEventMemberPromoted
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatEventMemberPromoted)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatEventMemberPromoted)
		case ChatEventMemberRestrictedType:
			var chatEventMemberRestricted ChatEventMemberRestricted
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatEventMemberRestricted)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatEventMemberRestricted)
		case ChatEventTitleChangedType:
			var chatEventTitleChanged ChatEventTitleChanged
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatEventTitleChanged)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatEventTitleChanged)
		case ChatEventPermissionsChangedType:
			var chatEventPermissionsChanged ChatEventPermissionsChanged
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatEventPermissionsChanged)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatEventPermissionsChanged)
		case ChatEventDescriptionChangedType:
			var chatEventDescriptionChanged ChatEventDescriptionChanged
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatEventDescriptionChanged)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatEventDescriptionChanged)
		case ChatEventUsernameChangedType:
			var chatEventUsernameChanged ChatEventUsernameChanged
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatEventUsernameChanged)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatEventUsernameChanged)
		case ChatEventPhotoChangedType:
			var chatEventPhotoChanged ChatEventPhotoChanged
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatEventPhotoChanged)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatEventPhotoChanged)
		case ChatEventInvitesToggledType:
			var chatEventInvitesToggled ChatEventInvitesToggled
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatEventInvitesToggled)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatEventInvitesToggled)
		case ChatEventLinkedChatChangedType:
			var chatEventLinkedChatChanged ChatEventLinkedChatChanged
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatEventLinkedChatChanged)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatEventLinkedChatChanged)
		case ChatEventSlowModeDelayChangedType:
			var chatEventSlowModeDelayChanged ChatEventSlowModeDelayChanged
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatEventSlowModeDelayChanged)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatEventSlowModeDelayChanged)
		case ChatEventMessageTTLChangedType:
			var chatEventMessageTTLChanged ChatEventMessageTTLChanged
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatEventMessageTTLChanged)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatEventMessageTTLChanged)
		case ChatEventSignMessagesToggledType:
			var chatEventSignMessagesToggled ChatEventSignMessagesToggled
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatEventSignMessagesToggled)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatEventSignMessagesToggled)
		case ChatEventHasProtectedContentToggledType:
			var chatEventHasProtectedContentToggled ChatEventHasProtectedContentToggled
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatEventHasProtectedContentToggled)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatEventHasProtectedContentToggled)
		case ChatEventStickerSetChangedType:
			var chatEventStickerSetChanged ChatEventStickerSetChanged
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatEventStickerSetChanged)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatEventStickerSetChanged)
		case ChatEventLocationChangedType:
			var chatEventLocationChanged ChatEventLocationChanged
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatEventLocationChanged)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatEventLocationChanged)
		case ChatEventIsAllHistoryAvailableToggledType:
			var chatEventIsAllHistoryAvailableToggled ChatEventIsAllHistoryAvailableToggled
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatEventIsAllHistoryAvailableToggled)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatEventIsAllHistoryAvailableToggled)
		case ChatEventInviteLinkEditedType:
			var chatEventInviteLinkEdited ChatEventInviteLinkEdited
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatEventInviteLinkEdited)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatEventInviteLinkEdited)
		case ChatEventInviteLinkRevokedType:
			var chatEventInviteLinkRevoked ChatEventInviteLinkRevoked
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatEventInviteLinkRevoked)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatEventInviteLinkRevoked)
		case ChatEventInviteLinkDeletedType:
			var chatEventInviteLinkDeleted ChatEventInviteLinkDeleted
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatEventInviteLinkDeleted)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatEventInviteLinkDeleted)
		case ChatEventVideoChatCreatedType:
			var chatEventVideoChatCreated ChatEventVideoChatCreated
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatEventVideoChatCreated)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatEventVideoChatCreated)
		case ChatEventVideoChatEndedType:
			var chatEventVideoChatEnded ChatEventVideoChatEnded
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatEventVideoChatEnded)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatEventVideoChatEnded)
		case ChatEventVideoChatParticipantIsMutedToggledType:
			var chatEventVideoChatParticipantIsMutedToggled ChatEventVideoChatParticipantIsMutedToggled
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatEventVideoChatParticipantIsMutedToggled)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatEventVideoChatParticipantIsMutedToggled)
		case ChatEventVideoChatParticipantVolumeLevelChangedType:
			var chatEventVideoChatParticipantVolumeLevelChanged ChatEventVideoChatParticipantVolumeLevelChanged
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatEventVideoChatParticipantVolumeLevelChanged)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatEventVideoChatParticipantVolumeLevelChanged)
		case ChatEventVideoChatMuteNewParticipantsToggledType:
			var chatEventVideoChatMuteNewParticipantsToggled ChatEventVideoChatMuteNewParticipantsToggled
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatEventVideoChatMuteNewParticipantsToggled)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatEventVideoChatMuteNewParticipantsToggled)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// LanguagePackStringValue Represents the value of a string in a language pack
type LanguagePackStringValue interface {
	GetLanguagePackStringValueEnum() LanguagePackStringValueEnum
}

// LanguagePackStringValueEnum Alias for abstract LanguagePackStringValue 'Sub-Classes', used as constant-enum here
type LanguagePackStringValueEnum string

// LanguagePackStringValue enums
const (
	LanguagePackStringValueOrdinaryType   LanguagePackStringValueEnum = "languagePackStringValueOrdinary"
	LanguagePackStringValuePluralizedType LanguagePackStringValueEnum = "languagePackStringValuePluralized"
	LanguagePackStringValueDeletedType    LanguagePackStringValueEnum = "languagePackStringValueDeleted"
)

func unmarshalLanguagePackStringValue(rawMsg *json.RawMessage) (LanguagePackStringValue, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch LanguagePackStringValueEnum(objMap["@type"].(string)) {
	case LanguagePackStringValueOrdinaryType:
		var languagePackStringValueOrdinary LanguagePackStringValueOrdinary
		err := json.Unmarshal(*rawMsg, &languagePackStringValueOrdinary)
		return &languagePackStringValueOrdinary, err

	case LanguagePackStringValuePluralizedType:
		var languagePackStringValuePluralized LanguagePackStringValuePluralized
		err := json.Unmarshal(*rawMsg, &languagePackStringValuePluralized)
		return &languagePackStringValuePluralized, err

	case LanguagePackStringValueDeletedType:
		var languagePackStringValueDeleted LanguagePackStringValueDeleted
		err := json.Unmarshal(*rawMsg, &languagePackStringValueDeleted)
		return &languagePackStringValueDeleted, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalLanguagePackStringValueSlice(rawMsg *json.RawMessage) ([]LanguagePackStringValue, error) {
	objects := make([]LanguagePackStringValue, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch LanguagePackStringValueEnum(objMap["@type"].(string)) {
		case LanguagePackStringValueOrdinaryType:
			var languagePackStringValueOrdinary LanguagePackStringValueOrdinary
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &languagePackStringValueOrdinary)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &languagePackStringValueOrdinary)
		case LanguagePackStringValuePluralizedType:
			var languagePackStringValuePluralized LanguagePackStringValuePluralized
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &languagePackStringValuePluralized)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &languagePackStringValuePluralized)
		case LanguagePackStringValueDeletedType:
			var languagePackStringValueDeleted LanguagePackStringValueDeleted
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &languagePackStringValueDeleted)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &languagePackStringValueDeleted)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// DeviceToken Represents a data needed to subscribe for push notifications through registerDevice method. To use specific push notification service, the correct application platform must be specified and a valid server authentication data must be uploaded at https://my.telegram.org
type DeviceToken interface {
	GetDeviceTokenEnum() DeviceTokenEnum
}

// DeviceTokenEnum Alias for abstract DeviceToken 'Sub-Classes', used as constant-enum here
type DeviceTokenEnum string

// DeviceToken enums
const (
	DeviceTokenFirebaseCloudMessagingType DeviceTokenEnum = "deviceTokenFirebaseCloudMessaging"
	DeviceTokenApplePushType              DeviceTokenEnum = "deviceTokenApplePush"
	DeviceTokenApplePushVoIPType          DeviceTokenEnum = "deviceTokenApplePushVoIP"
	DeviceTokenWindowsPushType            DeviceTokenEnum = "deviceTokenWindowsPush"
	DeviceTokenMicrosoftPushType          DeviceTokenEnum = "deviceTokenMicrosoftPush"
	DeviceTokenMicrosoftPushVoIPType      DeviceTokenEnum = "deviceTokenMicrosoftPushVoIP"
	DeviceTokenWebPushType                DeviceTokenEnum = "deviceTokenWebPush"
	DeviceTokenSimplePushType             DeviceTokenEnum = "deviceTokenSimplePush"
	DeviceTokenUbuntuPushType             DeviceTokenEnum = "deviceTokenUbuntuPush"
	DeviceTokenBlackBerryPushType         DeviceTokenEnum = "deviceTokenBlackBerryPush"
	DeviceTokenTizenPushType              DeviceTokenEnum = "deviceTokenTizenPush"
)

func unmarshalDeviceToken(rawMsg *json.RawMessage) (DeviceToken, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch DeviceTokenEnum(objMap["@type"].(string)) {
	case DeviceTokenFirebaseCloudMessagingType:
		var deviceTokenFirebaseCloudMessaging DeviceTokenFirebaseCloudMessaging
		err := json.Unmarshal(*rawMsg, &deviceTokenFirebaseCloudMessaging)
		return &deviceTokenFirebaseCloudMessaging, err

	case DeviceTokenApplePushType:
		var deviceTokenApplePush DeviceTokenApplePush
		err := json.Unmarshal(*rawMsg, &deviceTokenApplePush)
		return &deviceTokenApplePush, err

	case DeviceTokenApplePushVoIPType:
		var deviceTokenApplePushVoIP DeviceTokenApplePushVoIP
		err := json.Unmarshal(*rawMsg, &deviceTokenApplePushVoIP)
		return &deviceTokenApplePushVoIP, err

	case DeviceTokenWindowsPushType:
		var deviceTokenWindowsPush DeviceTokenWindowsPush
		err := json.Unmarshal(*rawMsg, &deviceTokenWindowsPush)
		return &deviceTokenWindowsPush, err

	case DeviceTokenMicrosoftPushType:
		var deviceTokenMicrosoftPush DeviceTokenMicrosoftPush
		err := json.Unmarshal(*rawMsg, &deviceTokenMicrosoftPush)
		return &deviceTokenMicrosoftPush, err

	case DeviceTokenMicrosoftPushVoIPType:
		var deviceTokenMicrosoftPushVoIP DeviceTokenMicrosoftPushVoIP
		err := json.Unmarshal(*rawMsg, &deviceTokenMicrosoftPushVoIP)
		return &deviceTokenMicrosoftPushVoIP, err

	case DeviceTokenWebPushType:
		var deviceTokenWebPush DeviceTokenWebPush
		err := json.Unmarshal(*rawMsg, &deviceTokenWebPush)
		return &deviceTokenWebPush, err

	case DeviceTokenSimplePushType:
		var deviceTokenSimplePush DeviceTokenSimplePush
		err := json.Unmarshal(*rawMsg, &deviceTokenSimplePush)
		return &deviceTokenSimplePush, err

	case DeviceTokenUbuntuPushType:
		var deviceTokenUbuntuPush DeviceTokenUbuntuPush
		err := json.Unmarshal(*rawMsg, &deviceTokenUbuntuPush)
		return &deviceTokenUbuntuPush, err

	case DeviceTokenBlackBerryPushType:
		var deviceTokenBlackBerryPush DeviceTokenBlackBerryPush
		err := json.Unmarshal(*rawMsg, &deviceTokenBlackBerryPush)
		return &deviceTokenBlackBerryPush, err

	case DeviceTokenTizenPushType:
		var deviceTokenTizenPush DeviceTokenTizenPush
		err := json.Unmarshal(*rawMsg, &deviceTokenTizenPush)
		return &deviceTokenTizenPush, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalDeviceTokenSlice(rawMsg *json.RawMessage) ([]DeviceToken, error) {
	objects := make([]DeviceToken, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch DeviceTokenEnum(objMap["@type"].(string)) {
		case DeviceTokenFirebaseCloudMessagingType:
			var deviceTokenFirebaseCloudMessaging DeviceTokenFirebaseCloudMessaging
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &deviceTokenFirebaseCloudMessaging)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &deviceTokenFirebaseCloudMessaging)
		case DeviceTokenApplePushType:
			var deviceTokenApplePush DeviceTokenApplePush
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &deviceTokenApplePush)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &deviceTokenApplePush)
		case DeviceTokenApplePushVoIPType:
			var deviceTokenApplePushVoIP DeviceTokenApplePushVoIP
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &deviceTokenApplePushVoIP)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &deviceTokenApplePushVoIP)
		case DeviceTokenWindowsPushType:
			var deviceTokenWindowsPush DeviceTokenWindowsPush
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &deviceTokenWindowsPush)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &deviceTokenWindowsPush)
		case DeviceTokenMicrosoftPushType:
			var deviceTokenMicrosoftPush DeviceTokenMicrosoftPush
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &deviceTokenMicrosoftPush)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &deviceTokenMicrosoftPush)
		case DeviceTokenMicrosoftPushVoIPType:
			var deviceTokenMicrosoftPushVoIP DeviceTokenMicrosoftPushVoIP
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &deviceTokenMicrosoftPushVoIP)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &deviceTokenMicrosoftPushVoIP)
		case DeviceTokenWebPushType:
			var deviceTokenWebPush DeviceTokenWebPush
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &deviceTokenWebPush)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &deviceTokenWebPush)
		case DeviceTokenSimplePushType:
			var deviceTokenSimplePush DeviceTokenSimplePush
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &deviceTokenSimplePush)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &deviceTokenSimplePush)
		case DeviceTokenUbuntuPushType:
			var deviceTokenUbuntuPush DeviceTokenUbuntuPush
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &deviceTokenUbuntuPush)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &deviceTokenUbuntuPush)
		case DeviceTokenBlackBerryPushType:
			var deviceTokenBlackBerryPush DeviceTokenBlackBerryPush
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &deviceTokenBlackBerryPush)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &deviceTokenBlackBerryPush)
		case DeviceTokenTizenPushType:
			var deviceTokenTizenPush DeviceTokenTizenPush
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &deviceTokenTizenPush)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &deviceTokenTizenPush)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// BackgroundFill Describes a fill of a background
type BackgroundFill interface {
	GetBackgroundFillEnum() BackgroundFillEnum
}

// BackgroundFillEnum Alias for abstract BackgroundFill 'Sub-Classes', used as constant-enum here
type BackgroundFillEnum string

// BackgroundFill enums
const (
	BackgroundFillSolidType            BackgroundFillEnum = "backgroundFillSolid"
	BackgroundFillGradientType         BackgroundFillEnum = "backgroundFillGradient"
	BackgroundFillFreeformGradientType BackgroundFillEnum = "backgroundFillFreeformGradient"
)

func unmarshalBackgroundFill(rawMsg *json.RawMessage) (BackgroundFill, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch BackgroundFillEnum(objMap["@type"].(string)) {
	case BackgroundFillSolidType:
		var backgroundFillSolid BackgroundFillSolid
		err := json.Unmarshal(*rawMsg, &backgroundFillSolid)
		return &backgroundFillSolid, err

	case BackgroundFillGradientType:
		var backgroundFillGradient BackgroundFillGradient
		err := json.Unmarshal(*rawMsg, &backgroundFillGradient)
		return &backgroundFillGradient, err

	case BackgroundFillFreeformGradientType:
		var backgroundFillFreeformGradient BackgroundFillFreeformGradient
		err := json.Unmarshal(*rawMsg, &backgroundFillFreeformGradient)
		return &backgroundFillFreeformGradient, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalBackgroundFillSlice(rawMsg *json.RawMessage) ([]BackgroundFill, error) {
	objects := make([]BackgroundFill, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch BackgroundFillEnum(objMap["@type"].(string)) {
		case BackgroundFillSolidType:
			var backgroundFillSolid BackgroundFillSolid
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &backgroundFillSolid)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &backgroundFillSolid)
		case BackgroundFillGradientType:
			var backgroundFillGradient BackgroundFillGradient
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &backgroundFillGradient)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &backgroundFillGradient)
		case BackgroundFillFreeformGradientType:
			var backgroundFillFreeformGradient BackgroundFillFreeformGradient
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &backgroundFillFreeformGradient)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &backgroundFillFreeformGradient)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// BackgroundType Describes the type of a background
type BackgroundType interface {
	GetBackgroundTypeEnum() BackgroundTypeEnum
}

// BackgroundTypeEnum Alias for abstract BackgroundType 'Sub-Classes', used as constant-enum here
type BackgroundTypeEnum string

// BackgroundType enums
const (
	BackgroundTypeWallpaperType BackgroundTypeEnum = "backgroundTypeWallpaper"
	BackgroundTypePatternType   BackgroundTypeEnum = "backgroundTypePattern"
	BackgroundTypeFillType      BackgroundTypeEnum = "backgroundTypeFill"
)

func unmarshalBackgroundType(rawMsg *json.RawMessage) (BackgroundType, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch BackgroundTypeEnum(objMap["@type"].(string)) {
	case BackgroundTypeWallpaperType:
		var backgroundTypeWallpaper BackgroundTypeWallpaper
		err := json.Unmarshal(*rawMsg, &backgroundTypeWallpaper)
		return &backgroundTypeWallpaper, err

	case BackgroundTypePatternType:
		var backgroundTypePattern BackgroundTypePattern
		err := json.Unmarshal(*rawMsg, &backgroundTypePattern)
		return &backgroundTypePattern, err

	case BackgroundTypeFillType:
		var backgroundTypeFill BackgroundTypeFill
		err := json.Unmarshal(*rawMsg, &backgroundTypeFill)
		return &backgroundTypeFill, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalBackgroundTypeSlice(rawMsg *json.RawMessage) ([]BackgroundType, error) {
	objects := make([]BackgroundType, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch BackgroundTypeEnum(objMap["@type"].(string)) {
		case BackgroundTypeWallpaperType:
			var backgroundTypeWallpaper BackgroundTypeWallpaper
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &backgroundTypeWallpaper)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &backgroundTypeWallpaper)
		case BackgroundTypePatternType:
			var backgroundTypePattern BackgroundTypePattern
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &backgroundTypePattern)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &backgroundTypePattern)
		case BackgroundTypeFillType:
			var backgroundTypeFill BackgroundTypeFill
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &backgroundTypeFill)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &backgroundTypeFill)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// InputBackground Contains information about background to set
type InputBackground interface {
	GetInputBackgroundEnum() InputBackgroundEnum
}

// InputBackgroundEnum Alias for abstract InputBackground 'Sub-Classes', used as constant-enum here
type InputBackgroundEnum string

// InputBackground enums
const (
	InputBackgroundLocalType  InputBackgroundEnum = "inputBackgroundLocal"
	InputBackgroundRemoteType InputBackgroundEnum = "inputBackgroundRemote"
)

func unmarshalInputBackground(rawMsg *json.RawMessage) (InputBackground, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch InputBackgroundEnum(objMap["@type"].(string)) {
	case InputBackgroundLocalType:
		var inputBackgroundLocal InputBackgroundLocal
		err := json.Unmarshal(*rawMsg, &inputBackgroundLocal)
		return &inputBackgroundLocal, err

	case InputBackgroundRemoteType:
		var inputBackgroundRemote InputBackgroundRemote
		err := json.Unmarshal(*rawMsg, &inputBackgroundRemote)
		return &inputBackgroundRemote, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalInputBackgroundSlice(rawMsg *json.RawMessage) ([]InputBackground, error) {
	objects := make([]InputBackground, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch InputBackgroundEnum(objMap["@type"].(string)) {
		case InputBackgroundLocalType:
			var inputBackgroundLocal InputBackgroundLocal
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputBackgroundLocal)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputBackgroundLocal)
		case InputBackgroundRemoteType:
			var inputBackgroundRemote InputBackgroundRemote
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputBackgroundRemote)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputBackgroundRemote)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// CanTransferOwnershipResult Represents result of checking whether the current session can be used to transfer a chat ownership to another user
type CanTransferOwnershipResult interface {
	GetCanTransferOwnershipResultEnum() CanTransferOwnershipResultEnum
}

// CanTransferOwnershipResultEnum Alias for abstract CanTransferOwnershipResult 'Sub-Classes', used as constant-enum here
type CanTransferOwnershipResultEnum string

// CanTransferOwnershipResult enums
const (
	CanTransferOwnershipResultOkType               CanTransferOwnershipResultEnum = "canTransferOwnershipResultOk"
	CanTransferOwnershipResultPasswordNeededType   CanTransferOwnershipResultEnum = "canTransferOwnershipResultPasswordNeeded"
	CanTransferOwnershipResultPasswordTooFreshType CanTransferOwnershipResultEnum = "canTransferOwnershipResultPasswordTooFresh"
	CanTransferOwnershipResultSessionTooFreshType  CanTransferOwnershipResultEnum = "canTransferOwnershipResultSessionTooFresh"
)

func unmarshalCanTransferOwnershipResult(rawMsg *json.RawMessage) (CanTransferOwnershipResult, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch CanTransferOwnershipResultEnum(objMap["@type"].(string)) {
	case CanTransferOwnershipResultOkType:
		var canTransferOwnershipResultOk CanTransferOwnershipResultOk
		err := json.Unmarshal(*rawMsg, &canTransferOwnershipResultOk)
		return &canTransferOwnershipResultOk, err

	case CanTransferOwnershipResultPasswordNeededType:
		var canTransferOwnershipResultPasswordNeeded CanTransferOwnershipResultPasswordNeeded
		err := json.Unmarshal(*rawMsg, &canTransferOwnershipResultPasswordNeeded)
		return &canTransferOwnershipResultPasswordNeeded, err

	case CanTransferOwnershipResultPasswordTooFreshType:
		var canTransferOwnershipResultPasswordTooFresh CanTransferOwnershipResultPasswordTooFresh
		err := json.Unmarshal(*rawMsg, &canTransferOwnershipResultPasswordTooFresh)
		return &canTransferOwnershipResultPasswordTooFresh, err

	case CanTransferOwnershipResultSessionTooFreshType:
		var canTransferOwnershipResultSessionTooFresh CanTransferOwnershipResultSessionTooFresh
		err := json.Unmarshal(*rawMsg, &canTransferOwnershipResultSessionTooFresh)
		return &canTransferOwnershipResultSessionTooFresh, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalCanTransferOwnershipResultSlice(rawMsg *json.RawMessage) ([]CanTransferOwnershipResult, error) {
	objects := make([]CanTransferOwnershipResult, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch CanTransferOwnershipResultEnum(objMap["@type"].(string)) {
		case CanTransferOwnershipResultOkType:
			var canTransferOwnershipResultOk CanTransferOwnershipResultOk
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &canTransferOwnershipResultOk)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &canTransferOwnershipResultOk)
		case CanTransferOwnershipResultPasswordNeededType:
			var canTransferOwnershipResultPasswordNeeded CanTransferOwnershipResultPasswordNeeded
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &canTransferOwnershipResultPasswordNeeded)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &canTransferOwnershipResultPasswordNeeded)
		case CanTransferOwnershipResultPasswordTooFreshType:
			var canTransferOwnershipResultPasswordTooFresh CanTransferOwnershipResultPasswordTooFresh
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &canTransferOwnershipResultPasswordTooFresh)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &canTransferOwnershipResultPasswordTooFresh)
		case CanTransferOwnershipResultSessionTooFreshType:
			var canTransferOwnershipResultSessionTooFresh CanTransferOwnershipResultSessionTooFresh
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &canTransferOwnershipResultSessionTooFresh)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &canTransferOwnershipResultSessionTooFresh)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// CheckChatUsernameResult Represents result of checking whether a username can be set for a chat
type CheckChatUsernameResult interface {
	GetCheckChatUsernameResultEnum() CheckChatUsernameResultEnum
}

// CheckChatUsernameResultEnum Alias for abstract CheckChatUsernameResult 'Sub-Classes', used as constant-enum here
type CheckChatUsernameResultEnum string

// CheckChatUsernameResult enums
const (
	CheckChatUsernameResultOkType                      CheckChatUsernameResultEnum = "checkChatUsernameResultOk"
	CheckChatUsernameResultUsernameInvalidType         CheckChatUsernameResultEnum = "checkChatUsernameResultUsernameInvalid"
	CheckChatUsernameResultUsernameOccupiedType        CheckChatUsernameResultEnum = "checkChatUsernameResultUsernameOccupied"
	CheckChatUsernameResultPublicChatsTooMuchType      CheckChatUsernameResultEnum = "checkChatUsernameResultPublicChatsTooMuch"
	CheckChatUsernameResultPublicGroupsUnavailableType CheckChatUsernameResultEnum = "checkChatUsernameResultPublicGroupsUnavailable"
)

func unmarshalCheckChatUsernameResult(rawMsg *json.RawMessage) (CheckChatUsernameResult, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch CheckChatUsernameResultEnum(objMap["@type"].(string)) {
	case CheckChatUsernameResultOkType:
		var checkChatUsernameResultOk CheckChatUsernameResultOk
		err := json.Unmarshal(*rawMsg, &checkChatUsernameResultOk)
		return &checkChatUsernameResultOk, err

	case CheckChatUsernameResultUsernameInvalidType:
		var checkChatUsernameResultUsernameInvalid CheckChatUsernameResultUsernameInvalid
		err := json.Unmarshal(*rawMsg, &checkChatUsernameResultUsernameInvalid)
		return &checkChatUsernameResultUsernameInvalid, err

	case CheckChatUsernameResultUsernameOccupiedType:
		var checkChatUsernameResultUsernameOccupied CheckChatUsernameResultUsernameOccupied
		err := json.Unmarshal(*rawMsg, &checkChatUsernameResultUsernameOccupied)
		return &checkChatUsernameResultUsernameOccupied, err

	case CheckChatUsernameResultPublicChatsTooMuchType:
		var checkChatUsernameResultPublicChatsTooMuch CheckChatUsernameResultPublicChatsTooMuch
		err := json.Unmarshal(*rawMsg, &checkChatUsernameResultPublicChatsTooMuch)
		return &checkChatUsernameResultPublicChatsTooMuch, err

	case CheckChatUsernameResultPublicGroupsUnavailableType:
		var checkChatUsernameResultPublicGroupsUnavailable CheckChatUsernameResultPublicGroupsUnavailable
		err := json.Unmarshal(*rawMsg, &checkChatUsernameResultPublicGroupsUnavailable)
		return &checkChatUsernameResultPublicGroupsUnavailable, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalCheckChatUsernameResultSlice(rawMsg *json.RawMessage) ([]CheckChatUsernameResult, error) {
	objects := make([]CheckChatUsernameResult, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch CheckChatUsernameResultEnum(objMap["@type"].(string)) {
		case CheckChatUsernameResultOkType:
			var checkChatUsernameResultOk CheckChatUsernameResultOk
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &checkChatUsernameResultOk)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &checkChatUsernameResultOk)
		case CheckChatUsernameResultUsernameInvalidType:
			var checkChatUsernameResultUsernameInvalid CheckChatUsernameResultUsernameInvalid
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &checkChatUsernameResultUsernameInvalid)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &checkChatUsernameResultUsernameInvalid)
		case CheckChatUsernameResultUsernameOccupiedType:
			var checkChatUsernameResultUsernameOccupied CheckChatUsernameResultUsernameOccupied
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &checkChatUsernameResultUsernameOccupied)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &checkChatUsernameResultUsernameOccupied)
		case CheckChatUsernameResultPublicChatsTooMuchType:
			var checkChatUsernameResultPublicChatsTooMuch CheckChatUsernameResultPublicChatsTooMuch
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &checkChatUsernameResultPublicChatsTooMuch)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &checkChatUsernameResultPublicChatsTooMuch)
		case CheckChatUsernameResultPublicGroupsUnavailableType:
			var checkChatUsernameResultPublicGroupsUnavailable CheckChatUsernameResultPublicGroupsUnavailable
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &checkChatUsernameResultPublicGroupsUnavailable)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &checkChatUsernameResultPublicGroupsUnavailable)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// CheckStickerSetNameResult Represents result of checking whether a name can be used for a new sticker set
type CheckStickerSetNameResult interface {
	GetCheckStickerSetNameResultEnum() CheckStickerSetNameResultEnum
}

// CheckStickerSetNameResultEnum Alias for abstract CheckStickerSetNameResult 'Sub-Classes', used as constant-enum here
type CheckStickerSetNameResultEnum string

// CheckStickerSetNameResult enums
const (
	CheckStickerSetNameResultOkType           CheckStickerSetNameResultEnum = "checkStickerSetNameResultOk"
	CheckStickerSetNameResultNameInvalidType  CheckStickerSetNameResultEnum = "checkStickerSetNameResultNameInvalid"
	CheckStickerSetNameResultNameOccupiedType CheckStickerSetNameResultEnum = "checkStickerSetNameResultNameOccupied"
)

func unmarshalCheckStickerSetNameResult(rawMsg *json.RawMessage) (CheckStickerSetNameResult, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch CheckStickerSetNameResultEnum(objMap["@type"].(string)) {
	case CheckStickerSetNameResultOkType:
		var checkStickerSetNameResultOk CheckStickerSetNameResultOk
		err := json.Unmarshal(*rawMsg, &checkStickerSetNameResultOk)
		return &checkStickerSetNameResultOk, err

	case CheckStickerSetNameResultNameInvalidType:
		var checkStickerSetNameResultNameInvalid CheckStickerSetNameResultNameInvalid
		err := json.Unmarshal(*rawMsg, &checkStickerSetNameResultNameInvalid)
		return &checkStickerSetNameResultNameInvalid, err

	case CheckStickerSetNameResultNameOccupiedType:
		var checkStickerSetNameResultNameOccupied CheckStickerSetNameResultNameOccupied
		err := json.Unmarshal(*rawMsg, &checkStickerSetNameResultNameOccupied)
		return &checkStickerSetNameResultNameOccupied, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalCheckStickerSetNameResultSlice(rawMsg *json.RawMessage) ([]CheckStickerSetNameResult, error) {
	objects := make([]CheckStickerSetNameResult, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch CheckStickerSetNameResultEnum(objMap["@type"].(string)) {
		case CheckStickerSetNameResultOkType:
			var checkStickerSetNameResultOk CheckStickerSetNameResultOk
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &checkStickerSetNameResultOk)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &checkStickerSetNameResultOk)
		case CheckStickerSetNameResultNameInvalidType:
			var checkStickerSetNameResultNameInvalid CheckStickerSetNameResultNameInvalid
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &checkStickerSetNameResultNameInvalid)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &checkStickerSetNameResultNameInvalid)
		case CheckStickerSetNameResultNameOccupiedType:
			var checkStickerSetNameResultNameOccupied CheckStickerSetNameResultNameOccupied
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &checkStickerSetNameResultNameOccupied)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &checkStickerSetNameResultNameOccupied)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// ResetPasswordResult Represents result of 2-step verification password reset
type ResetPasswordResult interface {
	GetResetPasswordResultEnum() ResetPasswordResultEnum
}

// ResetPasswordResultEnum Alias for abstract ResetPasswordResult 'Sub-Classes', used as constant-enum here
type ResetPasswordResultEnum string

// ResetPasswordResult enums
const (
	ResetPasswordResultOkType       ResetPasswordResultEnum = "resetPasswordResultOk"
	ResetPasswordResultPendingType  ResetPasswordResultEnum = "resetPasswordResultPending"
	ResetPasswordResultDeclinedType ResetPasswordResultEnum = "resetPasswordResultDeclined"
)

func unmarshalResetPasswordResult(rawMsg *json.RawMessage) (ResetPasswordResult, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch ResetPasswordResultEnum(objMap["@type"].(string)) {
	case ResetPasswordResultOkType:
		var resetPasswordResultOk ResetPasswordResultOk
		err := json.Unmarshal(*rawMsg, &resetPasswordResultOk)
		return &resetPasswordResultOk, err

	case ResetPasswordResultPendingType:
		var resetPasswordResultPending ResetPasswordResultPending
		err := json.Unmarshal(*rawMsg, &resetPasswordResultPending)
		return &resetPasswordResultPending, err

	case ResetPasswordResultDeclinedType:
		var resetPasswordResultDeclined ResetPasswordResultDeclined
		err := json.Unmarshal(*rawMsg, &resetPasswordResultDeclined)
		return &resetPasswordResultDeclined, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalResetPasswordResultSlice(rawMsg *json.RawMessage) ([]ResetPasswordResult, error) {
	objects := make([]ResetPasswordResult, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch ResetPasswordResultEnum(objMap["@type"].(string)) {
		case ResetPasswordResultOkType:
			var resetPasswordResultOk ResetPasswordResultOk
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &resetPasswordResultOk)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &resetPasswordResultOk)
		case ResetPasswordResultPendingType:
			var resetPasswordResultPending ResetPasswordResultPending
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &resetPasswordResultPending)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &resetPasswordResultPending)
		case ResetPasswordResultDeclinedType:
			var resetPasswordResultDeclined ResetPasswordResultDeclined
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &resetPasswordResultDeclined)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &resetPasswordResultDeclined)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// MessageFileType Contains information about a file with messages exported from another app
type MessageFileType interface {
	GetMessageFileTypeEnum() MessageFileTypeEnum
}

// MessageFileTypeEnum Alias for abstract MessageFileType 'Sub-Classes', used as constant-enum here
type MessageFileTypeEnum string

// MessageFileType enums
const (
	MessageFileTypePrivateType MessageFileTypeEnum = "messageFileTypePrivate"
	MessageFileTypeGroupType   MessageFileTypeEnum = "messageFileTypeGroup"
	MessageFileTypeUnknownType MessageFileTypeEnum = "messageFileTypeUnknown"
)

func unmarshalMessageFileType(rawMsg *json.RawMessage) (MessageFileType, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch MessageFileTypeEnum(objMap["@type"].(string)) {
	case MessageFileTypePrivateType:
		var messageFileTypePrivate MessageFileTypePrivate
		err := json.Unmarshal(*rawMsg, &messageFileTypePrivate)
		return &messageFileTypePrivate, err

	case MessageFileTypeGroupType:
		var messageFileTypeGroup MessageFileTypeGroup
		err := json.Unmarshal(*rawMsg, &messageFileTypeGroup)
		return &messageFileTypeGroup, err

	case MessageFileTypeUnknownType:
		var messageFileTypeUnknown MessageFileTypeUnknown
		err := json.Unmarshal(*rawMsg, &messageFileTypeUnknown)
		return &messageFileTypeUnknown, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalMessageFileTypeSlice(rawMsg *json.RawMessage) ([]MessageFileType, error) {
	objects := make([]MessageFileType, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch MessageFileTypeEnum(objMap["@type"].(string)) {
		case MessageFileTypePrivateType:
			var messageFileTypePrivate MessageFileTypePrivate
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageFileTypePrivate)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageFileTypePrivate)
		case MessageFileTypeGroupType:
			var messageFileTypeGroup MessageFileTypeGroup
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageFileTypeGroup)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageFileTypeGroup)
		case MessageFileTypeUnknownType:
			var messageFileTypeUnknown MessageFileTypeUnknown
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &messageFileTypeUnknown)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &messageFileTypeUnknown)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// PushMessageContent Contains content of a push message notification
type PushMessageContent interface {
	GetPushMessageContentEnum() PushMessageContentEnum
}

// PushMessageContentEnum Alias for abstract PushMessageContent 'Sub-Classes', used as constant-enum here
type PushMessageContentEnum string

// PushMessageContent enums
const (
	PushMessageContentHiddenType               PushMessageContentEnum = "pushMessageContentHidden"
	PushMessageContentAnimationType            PushMessageContentEnum = "pushMessageContentAnimation"
	PushMessageContentAudioType                PushMessageContentEnum = "pushMessageContentAudio"
	PushMessageContentContactType              PushMessageContentEnum = "pushMessageContentContact"
	PushMessageContentContactRegisteredType    PushMessageContentEnum = "pushMessageContentContactRegistered"
	PushMessageContentDocumentType             PushMessageContentEnum = "pushMessageContentDocument"
	PushMessageContentGameType                 PushMessageContentEnum = "pushMessageContentGame"
	PushMessageContentGameScoreType            PushMessageContentEnum = "pushMessageContentGameScore"
	PushMessageContentInvoiceType              PushMessageContentEnum = "pushMessageContentInvoice"
	PushMessageContentLocationType             PushMessageContentEnum = "pushMessageContentLocation"
	PushMessageContentPhotoType                PushMessageContentEnum = "pushMessageContentPhoto"
	PushMessageContentPollType                 PushMessageContentEnum = "pushMessageContentPoll"
	PushMessageContentScreenshotTakenType      PushMessageContentEnum = "pushMessageContentScreenshotTaken"
	PushMessageContentStickerType              PushMessageContentEnum = "pushMessageContentSticker"
	PushMessageContentTextType                 PushMessageContentEnum = "pushMessageContentText"
	PushMessageContentVideoType                PushMessageContentEnum = "pushMessageContentVideo"
	PushMessageContentVideoNoteType            PushMessageContentEnum = "pushMessageContentVideoNote"
	PushMessageContentVoiceNoteType            PushMessageContentEnum = "pushMessageContentVoiceNote"
	PushMessageContentBasicGroupChatCreateType PushMessageContentEnum = "pushMessageContentBasicGroupChatCreate"
	PushMessageContentChatAddMembersType       PushMessageContentEnum = "pushMessageContentChatAddMembers"
	PushMessageContentChatChangePhotoType      PushMessageContentEnum = "pushMessageContentChatChangePhoto"
	PushMessageContentChatChangeTitleType      PushMessageContentEnum = "pushMessageContentChatChangeTitle"
	PushMessageContentChatSetThemeType         PushMessageContentEnum = "pushMessageContentChatSetTheme"
	PushMessageContentChatDeleteMemberType     PushMessageContentEnum = "pushMessageContentChatDeleteMember"
	PushMessageContentChatJoinByLinkType       PushMessageContentEnum = "pushMessageContentChatJoinByLink"
	PushMessageContentChatJoinByRequestType    PushMessageContentEnum = "pushMessageContentChatJoinByRequest"
	PushMessageContentMessageForwardsType      PushMessageContentEnum = "pushMessageContentMessageForwards"
	PushMessageContentMediaAlbumType           PushMessageContentEnum = "pushMessageContentMediaAlbum"
)

func unmarshalPushMessageContent(rawMsg *json.RawMessage) (PushMessageContent, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch PushMessageContentEnum(objMap["@type"].(string)) {
	case PushMessageContentHiddenType:
		var pushMessageContentHidden PushMessageContentHidden
		err := json.Unmarshal(*rawMsg, &pushMessageContentHidden)
		return &pushMessageContentHidden, err

	case PushMessageContentAnimationType:
		var pushMessageContentAnimation PushMessageContentAnimation
		err := json.Unmarshal(*rawMsg, &pushMessageContentAnimation)
		return &pushMessageContentAnimation, err

	case PushMessageContentAudioType:
		var pushMessageContentAudio PushMessageContentAudio
		err := json.Unmarshal(*rawMsg, &pushMessageContentAudio)
		return &pushMessageContentAudio, err

	case PushMessageContentContactType:
		var pushMessageContentContact PushMessageContentContact
		err := json.Unmarshal(*rawMsg, &pushMessageContentContact)
		return &pushMessageContentContact, err

	case PushMessageContentContactRegisteredType:
		var pushMessageContentContactRegistered PushMessageContentContactRegistered
		err := json.Unmarshal(*rawMsg, &pushMessageContentContactRegistered)
		return &pushMessageContentContactRegistered, err

	case PushMessageContentDocumentType:
		var pushMessageContentDocument PushMessageContentDocument
		err := json.Unmarshal(*rawMsg, &pushMessageContentDocument)
		return &pushMessageContentDocument, err

	case PushMessageContentGameType:
		var pushMessageContentGame PushMessageContentGame
		err := json.Unmarshal(*rawMsg, &pushMessageContentGame)
		return &pushMessageContentGame, err

	case PushMessageContentGameScoreType:
		var pushMessageContentGameScore PushMessageContentGameScore
		err := json.Unmarshal(*rawMsg, &pushMessageContentGameScore)
		return &pushMessageContentGameScore, err

	case PushMessageContentInvoiceType:
		var pushMessageContentInvoice PushMessageContentInvoice
		err := json.Unmarshal(*rawMsg, &pushMessageContentInvoice)
		return &pushMessageContentInvoice, err

	case PushMessageContentLocationType:
		var pushMessageContentLocation PushMessageContentLocation
		err := json.Unmarshal(*rawMsg, &pushMessageContentLocation)
		return &pushMessageContentLocation, err

	case PushMessageContentPhotoType:
		var pushMessageContentPhoto PushMessageContentPhoto
		err := json.Unmarshal(*rawMsg, &pushMessageContentPhoto)
		return &pushMessageContentPhoto, err

	case PushMessageContentPollType:
		var pushMessageContentPoll PushMessageContentPoll
		err := json.Unmarshal(*rawMsg, &pushMessageContentPoll)
		return &pushMessageContentPoll, err

	case PushMessageContentScreenshotTakenType:
		var pushMessageContentScreenshotTaken PushMessageContentScreenshotTaken
		err := json.Unmarshal(*rawMsg, &pushMessageContentScreenshotTaken)
		return &pushMessageContentScreenshotTaken, err

	case PushMessageContentStickerType:
		var pushMessageContentSticker PushMessageContentSticker
		err := json.Unmarshal(*rawMsg, &pushMessageContentSticker)
		return &pushMessageContentSticker, err

	case PushMessageContentTextType:
		var pushMessageContentText PushMessageContentText
		err := json.Unmarshal(*rawMsg, &pushMessageContentText)
		return &pushMessageContentText, err

	case PushMessageContentVideoType:
		var pushMessageContentVideo PushMessageContentVideo
		err := json.Unmarshal(*rawMsg, &pushMessageContentVideo)
		return &pushMessageContentVideo, err

	case PushMessageContentVideoNoteType:
		var pushMessageContentVideoNote PushMessageContentVideoNote
		err := json.Unmarshal(*rawMsg, &pushMessageContentVideoNote)
		return &pushMessageContentVideoNote, err

	case PushMessageContentVoiceNoteType:
		var pushMessageContentVoiceNote PushMessageContentVoiceNote
		err := json.Unmarshal(*rawMsg, &pushMessageContentVoiceNote)
		return &pushMessageContentVoiceNote, err

	case PushMessageContentBasicGroupChatCreateType:
		var pushMessageContentBasicGroupChatCreate PushMessageContentBasicGroupChatCreate
		err := json.Unmarshal(*rawMsg, &pushMessageContentBasicGroupChatCreate)
		return &pushMessageContentBasicGroupChatCreate, err

	case PushMessageContentChatAddMembersType:
		var pushMessageContentChatAddMembers PushMessageContentChatAddMembers
		err := json.Unmarshal(*rawMsg, &pushMessageContentChatAddMembers)
		return &pushMessageContentChatAddMembers, err

	case PushMessageContentChatChangePhotoType:
		var pushMessageContentChatChangePhoto PushMessageContentChatChangePhoto
		err := json.Unmarshal(*rawMsg, &pushMessageContentChatChangePhoto)
		return &pushMessageContentChatChangePhoto, err

	case PushMessageContentChatChangeTitleType:
		var pushMessageContentChatChangeTitle PushMessageContentChatChangeTitle
		err := json.Unmarshal(*rawMsg, &pushMessageContentChatChangeTitle)
		return &pushMessageContentChatChangeTitle, err

	case PushMessageContentChatSetThemeType:
		var pushMessageContentChatSetTheme PushMessageContentChatSetTheme
		err := json.Unmarshal(*rawMsg, &pushMessageContentChatSetTheme)
		return &pushMessageContentChatSetTheme, err

	case PushMessageContentChatDeleteMemberType:
		var pushMessageContentChatDeleteMember PushMessageContentChatDeleteMember
		err := json.Unmarshal(*rawMsg, &pushMessageContentChatDeleteMember)
		return &pushMessageContentChatDeleteMember, err

	case PushMessageContentChatJoinByLinkType:
		var pushMessageContentChatJoinByLink PushMessageContentChatJoinByLink
		err := json.Unmarshal(*rawMsg, &pushMessageContentChatJoinByLink)
		return &pushMessageContentChatJoinByLink, err

	case PushMessageContentChatJoinByRequestType:
		var pushMessageContentChatJoinByRequest PushMessageContentChatJoinByRequest
		err := json.Unmarshal(*rawMsg, &pushMessageContentChatJoinByRequest)
		return &pushMessageContentChatJoinByRequest, err

	case PushMessageContentMessageForwardsType:
		var pushMessageContentMessageForwards PushMessageContentMessageForwards
		err := json.Unmarshal(*rawMsg, &pushMessageContentMessageForwards)
		return &pushMessageContentMessageForwards, err

	case PushMessageContentMediaAlbumType:
		var pushMessageContentMediaAlbum PushMessageContentMediaAlbum
		err := json.Unmarshal(*rawMsg, &pushMessageContentMediaAlbum)
		return &pushMessageContentMediaAlbum, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalPushMessageContentSlice(rawMsg *json.RawMessage) ([]PushMessageContent, error) {
	objects := make([]PushMessageContent, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch PushMessageContentEnum(objMap["@type"].(string)) {
		case PushMessageContentHiddenType:
			var pushMessageContentHidden PushMessageContentHidden
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pushMessageContentHidden)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pushMessageContentHidden)
		case PushMessageContentAnimationType:
			var pushMessageContentAnimation PushMessageContentAnimation
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pushMessageContentAnimation)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pushMessageContentAnimation)
		case PushMessageContentAudioType:
			var pushMessageContentAudio PushMessageContentAudio
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pushMessageContentAudio)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pushMessageContentAudio)
		case PushMessageContentContactType:
			var pushMessageContentContact PushMessageContentContact
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pushMessageContentContact)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pushMessageContentContact)
		case PushMessageContentContactRegisteredType:
			var pushMessageContentContactRegistered PushMessageContentContactRegistered
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pushMessageContentContactRegistered)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pushMessageContentContactRegistered)
		case PushMessageContentDocumentType:
			var pushMessageContentDocument PushMessageContentDocument
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pushMessageContentDocument)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pushMessageContentDocument)
		case PushMessageContentGameType:
			var pushMessageContentGame PushMessageContentGame
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pushMessageContentGame)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pushMessageContentGame)
		case PushMessageContentGameScoreType:
			var pushMessageContentGameScore PushMessageContentGameScore
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pushMessageContentGameScore)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pushMessageContentGameScore)
		case PushMessageContentInvoiceType:
			var pushMessageContentInvoice PushMessageContentInvoice
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pushMessageContentInvoice)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pushMessageContentInvoice)
		case PushMessageContentLocationType:
			var pushMessageContentLocation PushMessageContentLocation
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pushMessageContentLocation)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pushMessageContentLocation)
		case PushMessageContentPhotoType:
			var pushMessageContentPhoto PushMessageContentPhoto
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pushMessageContentPhoto)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pushMessageContentPhoto)
		case PushMessageContentPollType:
			var pushMessageContentPoll PushMessageContentPoll
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pushMessageContentPoll)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pushMessageContentPoll)
		case PushMessageContentScreenshotTakenType:
			var pushMessageContentScreenshotTaken PushMessageContentScreenshotTaken
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pushMessageContentScreenshotTaken)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pushMessageContentScreenshotTaken)
		case PushMessageContentStickerType:
			var pushMessageContentSticker PushMessageContentSticker
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pushMessageContentSticker)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pushMessageContentSticker)
		case PushMessageContentTextType:
			var pushMessageContentText PushMessageContentText
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pushMessageContentText)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pushMessageContentText)
		case PushMessageContentVideoType:
			var pushMessageContentVideo PushMessageContentVideo
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pushMessageContentVideo)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pushMessageContentVideo)
		case PushMessageContentVideoNoteType:
			var pushMessageContentVideoNote PushMessageContentVideoNote
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pushMessageContentVideoNote)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pushMessageContentVideoNote)
		case PushMessageContentVoiceNoteType:
			var pushMessageContentVoiceNote PushMessageContentVoiceNote
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pushMessageContentVoiceNote)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pushMessageContentVoiceNote)
		case PushMessageContentBasicGroupChatCreateType:
			var pushMessageContentBasicGroupChatCreate PushMessageContentBasicGroupChatCreate
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pushMessageContentBasicGroupChatCreate)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pushMessageContentBasicGroupChatCreate)
		case PushMessageContentChatAddMembersType:
			var pushMessageContentChatAddMembers PushMessageContentChatAddMembers
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pushMessageContentChatAddMembers)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pushMessageContentChatAddMembers)
		case PushMessageContentChatChangePhotoType:
			var pushMessageContentChatChangePhoto PushMessageContentChatChangePhoto
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pushMessageContentChatChangePhoto)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pushMessageContentChatChangePhoto)
		case PushMessageContentChatChangeTitleType:
			var pushMessageContentChatChangeTitle PushMessageContentChatChangeTitle
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pushMessageContentChatChangeTitle)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pushMessageContentChatChangeTitle)
		case PushMessageContentChatSetThemeType:
			var pushMessageContentChatSetTheme PushMessageContentChatSetTheme
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pushMessageContentChatSetTheme)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pushMessageContentChatSetTheme)
		case PushMessageContentChatDeleteMemberType:
			var pushMessageContentChatDeleteMember PushMessageContentChatDeleteMember
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pushMessageContentChatDeleteMember)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pushMessageContentChatDeleteMember)
		case PushMessageContentChatJoinByLinkType:
			var pushMessageContentChatJoinByLink PushMessageContentChatJoinByLink
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pushMessageContentChatJoinByLink)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pushMessageContentChatJoinByLink)
		case PushMessageContentChatJoinByRequestType:
			var pushMessageContentChatJoinByRequest PushMessageContentChatJoinByRequest
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pushMessageContentChatJoinByRequest)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pushMessageContentChatJoinByRequest)
		case PushMessageContentMessageForwardsType:
			var pushMessageContentMessageForwards PushMessageContentMessageForwards
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pushMessageContentMessageForwards)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pushMessageContentMessageForwards)
		case PushMessageContentMediaAlbumType:
			var pushMessageContentMediaAlbum PushMessageContentMediaAlbum
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &pushMessageContentMediaAlbum)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &pushMessageContentMediaAlbum)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// NotificationType Contains detailed information about a notification
type NotificationType interface {
	GetNotificationTypeEnum() NotificationTypeEnum
}

// NotificationTypeEnum Alias for abstract NotificationType 'Sub-Classes', used as constant-enum here
type NotificationTypeEnum string

// NotificationType enums
const (
	NotificationTypeNewMessageType     NotificationTypeEnum = "notificationTypeNewMessage"
	NotificationTypeNewSecretChatType  NotificationTypeEnum = "notificationTypeNewSecretChat"
	NotificationTypeNewCallType        NotificationTypeEnum = "notificationTypeNewCall"
	NotificationTypeNewPushMessageType NotificationTypeEnum = "notificationTypeNewPushMessage"
)

func unmarshalNotificationType(rawMsg *json.RawMessage) (NotificationType, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch NotificationTypeEnum(objMap["@type"].(string)) {
	case NotificationTypeNewMessageType:
		var notificationTypeNewMessage NotificationTypeNewMessage
		err := json.Unmarshal(*rawMsg, &notificationTypeNewMessage)
		return &notificationTypeNewMessage, err

	case NotificationTypeNewSecretChatType:
		var notificationTypeNewSecretChat NotificationTypeNewSecretChat
		err := json.Unmarshal(*rawMsg, &notificationTypeNewSecretChat)
		return &notificationTypeNewSecretChat, err

	case NotificationTypeNewCallType:
		var notificationTypeNewCall NotificationTypeNewCall
		err := json.Unmarshal(*rawMsg, &notificationTypeNewCall)
		return &notificationTypeNewCall, err

	case NotificationTypeNewPushMessageType:
		var notificationTypeNewPushMessage NotificationTypeNewPushMessage
		err := json.Unmarshal(*rawMsg, &notificationTypeNewPushMessage)
		return &notificationTypeNewPushMessage, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalNotificationTypeSlice(rawMsg *json.RawMessage) ([]NotificationType, error) {
	objects := make([]NotificationType, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch NotificationTypeEnum(objMap["@type"].(string)) {
		case NotificationTypeNewMessageType:
			var notificationTypeNewMessage NotificationTypeNewMessage
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &notificationTypeNewMessage)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &notificationTypeNewMessage)
		case NotificationTypeNewSecretChatType:
			var notificationTypeNewSecretChat NotificationTypeNewSecretChat
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &notificationTypeNewSecretChat)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &notificationTypeNewSecretChat)
		case NotificationTypeNewCallType:
			var notificationTypeNewCall NotificationTypeNewCall
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &notificationTypeNewCall)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &notificationTypeNewCall)
		case NotificationTypeNewPushMessageType:
			var notificationTypeNewPushMessage NotificationTypeNewPushMessage
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &notificationTypeNewPushMessage)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &notificationTypeNewPushMessage)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// NotificationGroupType Describes the type of notifications in a notification group
type NotificationGroupType interface {
	GetNotificationGroupTypeEnum() NotificationGroupTypeEnum
}

// NotificationGroupTypeEnum Alias for abstract NotificationGroupType 'Sub-Classes', used as constant-enum here
type NotificationGroupTypeEnum string

// NotificationGroupType enums
const (
	NotificationGroupTypeMessagesType   NotificationGroupTypeEnum = "notificationGroupTypeMessages"
	NotificationGroupTypeMentionsType   NotificationGroupTypeEnum = "notificationGroupTypeMentions"
	NotificationGroupTypeSecretChatType NotificationGroupTypeEnum = "notificationGroupTypeSecretChat"
	NotificationGroupTypeCallsType      NotificationGroupTypeEnum = "notificationGroupTypeCalls"
)

func unmarshalNotificationGroupType(rawMsg *json.RawMessage) (NotificationGroupType, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch NotificationGroupTypeEnum(objMap["@type"].(string)) {
	case NotificationGroupTypeMessagesType:
		var notificationGroupTypeMessages NotificationGroupTypeMessages
		err := json.Unmarshal(*rawMsg, &notificationGroupTypeMessages)
		return &notificationGroupTypeMessages, err

	case NotificationGroupTypeMentionsType:
		var notificationGroupTypeMentions NotificationGroupTypeMentions
		err := json.Unmarshal(*rawMsg, &notificationGroupTypeMentions)
		return &notificationGroupTypeMentions, err

	case NotificationGroupTypeSecretChatType:
		var notificationGroupTypeSecretChat NotificationGroupTypeSecretChat
		err := json.Unmarshal(*rawMsg, &notificationGroupTypeSecretChat)
		return &notificationGroupTypeSecretChat, err

	case NotificationGroupTypeCallsType:
		var notificationGroupTypeCalls NotificationGroupTypeCalls
		err := json.Unmarshal(*rawMsg, &notificationGroupTypeCalls)
		return &notificationGroupTypeCalls, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalNotificationGroupTypeSlice(rawMsg *json.RawMessage) ([]NotificationGroupType, error) {
	objects := make([]NotificationGroupType, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch NotificationGroupTypeEnum(objMap["@type"].(string)) {
		case NotificationGroupTypeMessagesType:
			var notificationGroupTypeMessages NotificationGroupTypeMessages
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &notificationGroupTypeMessages)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &notificationGroupTypeMessages)
		case NotificationGroupTypeMentionsType:
			var notificationGroupTypeMentions NotificationGroupTypeMentions
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &notificationGroupTypeMentions)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &notificationGroupTypeMentions)
		case NotificationGroupTypeSecretChatType:
			var notificationGroupTypeSecretChat NotificationGroupTypeSecretChat
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &notificationGroupTypeSecretChat)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &notificationGroupTypeSecretChat)
		case NotificationGroupTypeCallsType:
			var notificationGroupTypeCalls NotificationGroupTypeCalls
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &notificationGroupTypeCalls)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &notificationGroupTypeCalls)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// OptionValue Represents the value of an option
type OptionValue interface {
	GetOptionValueEnum() OptionValueEnum
}

// OptionValueEnum Alias for abstract OptionValue 'Sub-Classes', used as constant-enum here
type OptionValueEnum string

// OptionValue enums
const (
	OptionValueBooleanType OptionValueEnum = "optionValueBoolean"
	OptionValueEmptyType   OptionValueEnum = "optionValueEmpty"
	OptionValueIntegerType OptionValueEnum = "optionValueInteger"
	OptionValueStringType  OptionValueEnum = "optionValueString"
)

func unmarshalOptionValue(rawMsg *json.RawMessage) (OptionValue, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch OptionValueEnum(objMap["@type"].(string)) {
	case OptionValueBooleanType:
		var optionValueBoolean OptionValueBoolean
		err := json.Unmarshal(*rawMsg, &optionValueBoolean)
		return &optionValueBoolean, err

	case OptionValueEmptyType:
		var optionValueEmpty OptionValueEmpty
		err := json.Unmarshal(*rawMsg, &optionValueEmpty)
		return &optionValueEmpty, err

	case OptionValueIntegerType:
		var optionValueInteger OptionValueInteger
		err := json.Unmarshal(*rawMsg, &optionValueInteger)
		return &optionValueInteger, err

	case OptionValueStringType:
		var optionValueString OptionValueString
		err := json.Unmarshal(*rawMsg, &optionValueString)
		return &optionValueString, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalOptionValueSlice(rawMsg *json.RawMessage) ([]OptionValue, error) {
	objects := make([]OptionValue, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch OptionValueEnum(objMap["@type"].(string)) {
		case OptionValueBooleanType:
			var optionValueBoolean OptionValueBoolean
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &optionValueBoolean)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &optionValueBoolean)
		case OptionValueEmptyType:
			var optionValueEmpty OptionValueEmpty
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &optionValueEmpty)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &optionValueEmpty)
		case OptionValueIntegerType:
			var optionValueInteger OptionValueInteger
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &optionValueInteger)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &optionValueInteger)
		case OptionValueStringType:
			var optionValueString OptionValueString
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &optionValueString)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &optionValueString)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// JsonValue Represents a JSON value
type JsonValue interface {
	GetJsonValueEnum() JsonValueEnum
}

// JsonValueEnum Alias for abstract JsonValue 'Sub-Classes', used as constant-enum here
type JsonValueEnum string

// JsonValue enums
const (
	JsonValueNullType    JsonValueEnum = "jsonValueNull"
	JsonValueBooleanType JsonValueEnum = "jsonValueBoolean"
	JsonValueNumberType  JsonValueEnum = "jsonValueNumber"
	JsonValueStringType  JsonValueEnum = "jsonValueString"
	JsonValueArrayType   JsonValueEnum = "jsonValueArray"
	JsonValueObjectType  JsonValueEnum = "jsonValueObject"
)

func unmarshalJsonValue(rawMsg *json.RawMessage) (JsonValue, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch JsonValueEnum(objMap["@type"].(string)) {
	case JsonValueNullType:
		var jsonValueNull JsonValueNull
		err := json.Unmarshal(*rawMsg, &jsonValueNull)
		return &jsonValueNull, err

	case JsonValueBooleanType:
		var jsonValueBoolean JsonValueBoolean
		err := json.Unmarshal(*rawMsg, &jsonValueBoolean)
		return &jsonValueBoolean, err

	case JsonValueNumberType:
		var jsonValueNumber JsonValueNumber
		err := json.Unmarshal(*rawMsg, &jsonValueNumber)
		return &jsonValueNumber, err

	case JsonValueStringType:
		var jsonValueString JsonValueString
		err := json.Unmarshal(*rawMsg, &jsonValueString)
		return &jsonValueString, err

	case JsonValueArrayType:
		var jsonValueArray JsonValueArray
		err := json.Unmarshal(*rawMsg, &jsonValueArray)
		return &jsonValueArray, err

	case JsonValueObjectType:
		var jsonValueObject JsonValueObject
		err := json.Unmarshal(*rawMsg, &jsonValueObject)
		return &jsonValueObject, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalJsonValueSlice(rawMsg *json.RawMessage) ([]JsonValue, error) {
	objects := make([]JsonValue, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch JsonValueEnum(objMap["@type"].(string)) {
		case JsonValueNullType:
			var jsonValueNull JsonValueNull
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &jsonValueNull)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &jsonValueNull)
		case JsonValueBooleanType:
			var jsonValueBoolean JsonValueBoolean
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &jsonValueBoolean)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &jsonValueBoolean)
		case JsonValueNumberType:
			var jsonValueNumber JsonValueNumber
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &jsonValueNumber)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &jsonValueNumber)
		case JsonValueStringType:
			var jsonValueString JsonValueString
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &jsonValueString)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &jsonValueString)
		case JsonValueArrayType:
			var jsonValueArray JsonValueArray
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &jsonValueArray)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &jsonValueArray)
		case JsonValueObjectType:
			var jsonValueObject JsonValueObject
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &jsonValueObject)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &jsonValueObject)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// UserPrivacySettingRule Represents a single rule for managing privacy settings
type UserPrivacySettingRule interface {
	GetUserPrivacySettingRuleEnum() UserPrivacySettingRuleEnum
}

// UserPrivacySettingRuleEnum Alias for abstract UserPrivacySettingRule 'Sub-Classes', used as constant-enum here
type UserPrivacySettingRuleEnum string

// UserPrivacySettingRule enums
const (
	UserPrivacySettingRuleAllowAllType            UserPrivacySettingRuleEnum = "userPrivacySettingRuleAllowAll"
	UserPrivacySettingRuleAllowContactsType       UserPrivacySettingRuleEnum = "userPrivacySettingRuleAllowContacts"
	UserPrivacySettingRuleAllowUsersType          UserPrivacySettingRuleEnum = "userPrivacySettingRuleAllowUsers"
	UserPrivacySettingRuleAllowChatMembersType    UserPrivacySettingRuleEnum = "userPrivacySettingRuleAllowChatMembers"
	UserPrivacySettingRuleRestrictAllType         UserPrivacySettingRuleEnum = "userPrivacySettingRuleRestrictAll"
	UserPrivacySettingRuleRestrictContactsType    UserPrivacySettingRuleEnum = "userPrivacySettingRuleRestrictContacts"
	UserPrivacySettingRuleRestrictUsersType       UserPrivacySettingRuleEnum = "userPrivacySettingRuleRestrictUsers"
	UserPrivacySettingRuleRestrictChatMembersType UserPrivacySettingRuleEnum = "userPrivacySettingRuleRestrictChatMembers"
)

func unmarshalUserPrivacySettingRule(rawMsg *json.RawMessage) (UserPrivacySettingRule, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch UserPrivacySettingRuleEnum(objMap["@type"].(string)) {
	case UserPrivacySettingRuleAllowAllType:
		var userPrivacySettingRuleAllowAll UserPrivacySettingRuleAllowAll
		err := json.Unmarshal(*rawMsg, &userPrivacySettingRuleAllowAll)
		return &userPrivacySettingRuleAllowAll, err

	case UserPrivacySettingRuleAllowContactsType:
		var userPrivacySettingRuleAllowContacts UserPrivacySettingRuleAllowContacts
		err := json.Unmarshal(*rawMsg, &userPrivacySettingRuleAllowContacts)
		return &userPrivacySettingRuleAllowContacts, err

	case UserPrivacySettingRuleAllowUsersType:
		var userPrivacySettingRuleAllowUsers UserPrivacySettingRuleAllowUsers
		err := json.Unmarshal(*rawMsg, &userPrivacySettingRuleAllowUsers)
		return &userPrivacySettingRuleAllowUsers, err

	case UserPrivacySettingRuleAllowChatMembersType:
		var userPrivacySettingRuleAllowChatMembers UserPrivacySettingRuleAllowChatMembers
		err := json.Unmarshal(*rawMsg, &userPrivacySettingRuleAllowChatMembers)
		return &userPrivacySettingRuleAllowChatMembers, err

	case UserPrivacySettingRuleRestrictAllType:
		var userPrivacySettingRuleRestrictAll UserPrivacySettingRuleRestrictAll
		err := json.Unmarshal(*rawMsg, &userPrivacySettingRuleRestrictAll)
		return &userPrivacySettingRuleRestrictAll, err

	case UserPrivacySettingRuleRestrictContactsType:
		var userPrivacySettingRuleRestrictContacts UserPrivacySettingRuleRestrictContacts
		err := json.Unmarshal(*rawMsg, &userPrivacySettingRuleRestrictContacts)
		return &userPrivacySettingRuleRestrictContacts, err

	case UserPrivacySettingRuleRestrictUsersType:
		var userPrivacySettingRuleRestrictUsers UserPrivacySettingRuleRestrictUsers
		err := json.Unmarshal(*rawMsg, &userPrivacySettingRuleRestrictUsers)
		return &userPrivacySettingRuleRestrictUsers, err

	case UserPrivacySettingRuleRestrictChatMembersType:
		var userPrivacySettingRuleRestrictChatMembers UserPrivacySettingRuleRestrictChatMembers
		err := json.Unmarshal(*rawMsg, &userPrivacySettingRuleRestrictChatMembers)
		return &userPrivacySettingRuleRestrictChatMembers, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalUserPrivacySettingRuleSlice(rawMsg *json.RawMessage) ([]UserPrivacySettingRule, error) {
	objects := make([]UserPrivacySettingRule, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch UserPrivacySettingRuleEnum(objMap["@type"].(string)) {
		case UserPrivacySettingRuleAllowAllType:
			var userPrivacySettingRuleAllowAll UserPrivacySettingRuleAllowAll
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &userPrivacySettingRuleAllowAll)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &userPrivacySettingRuleAllowAll)
		case UserPrivacySettingRuleAllowContactsType:
			var userPrivacySettingRuleAllowContacts UserPrivacySettingRuleAllowContacts
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &userPrivacySettingRuleAllowContacts)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &userPrivacySettingRuleAllowContacts)
		case UserPrivacySettingRuleAllowUsersType:
			var userPrivacySettingRuleAllowUsers UserPrivacySettingRuleAllowUsers
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &userPrivacySettingRuleAllowUsers)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &userPrivacySettingRuleAllowUsers)
		case UserPrivacySettingRuleAllowChatMembersType:
			var userPrivacySettingRuleAllowChatMembers UserPrivacySettingRuleAllowChatMembers
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &userPrivacySettingRuleAllowChatMembers)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &userPrivacySettingRuleAllowChatMembers)
		case UserPrivacySettingRuleRestrictAllType:
			var userPrivacySettingRuleRestrictAll UserPrivacySettingRuleRestrictAll
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &userPrivacySettingRuleRestrictAll)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &userPrivacySettingRuleRestrictAll)
		case UserPrivacySettingRuleRestrictContactsType:
			var userPrivacySettingRuleRestrictContacts UserPrivacySettingRuleRestrictContacts
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &userPrivacySettingRuleRestrictContacts)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &userPrivacySettingRuleRestrictContacts)
		case UserPrivacySettingRuleRestrictUsersType:
			var userPrivacySettingRuleRestrictUsers UserPrivacySettingRuleRestrictUsers
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &userPrivacySettingRuleRestrictUsers)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &userPrivacySettingRuleRestrictUsers)
		case UserPrivacySettingRuleRestrictChatMembersType:
			var userPrivacySettingRuleRestrictChatMembers UserPrivacySettingRuleRestrictChatMembers
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &userPrivacySettingRuleRestrictChatMembers)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &userPrivacySettingRuleRestrictChatMembers)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// UserPrivacySetting Describes available user privacy settings
type UserPrivacySetting interface {
	GetUserPrivacySettingEnum() UserPrivacySettingEnum
}

// UserPrivacySettingEnum Alias for abstract UserPrivacySetting 'Sub-Classes', used as constant-enum here
type UserPrivacySettingEnum string

// UserPrivacySetting enums
const (
	UserPrivacySettingShowStatusType                  UserPrivacySettingEnum = "userPrivacySettingShowStatus"
	UserPrivacySettingShowProfilePhotoType            UserPrivacySettingEnum = "userPrivacySettingShowProfilePhoto"
	UserPrivacySettingShowLinkInForwardedMessagesType UserPrivacySettingEnum = "userPrivacySettingShowLinkInForwardedMessages"
	UserPrivacySettingShowPhoneNumberType             UserPrivacySettingEnum = "userPrivacySettingShowPhoneNumber"
	UserPrivacySettingAllowChatInvitesType            UserPrivacySettingEnum = "userPrivacySettingAllowChatInvites"
	UserPrivacySettingAllowCallsType                  UserPrivacySettingEnum = "userPrivacySettingAllowCalls"
	UserPrivacySettingAllowPeerToPeerCallsType        UserPrivacySettingEnum = "userPrivacySettingAllowPeerToPeerCalls"
	UserPrivacySettingAllowFindingByPhoneNumberType   UserPrivacySettingEnum = "userPrivacySettingAllowFindingByPhoneNumber"
)

func unmarshalUserPrivacySetting(rawMsg *json.RawMessage) (UserPrivacySetting, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch UserPrivacySettingEnum(objMap["@type"].(string)) {
	case UserPrivacySettingShowStatusType:
		var userPrivacySettingShowStatus UserPrivacySettingShowStatus
		err := json.Unmarshal(*rawMsg, &userPrivacySettingShowStatus)
		return &userPrivacySettingShowStatus, err

	case UserPrivacySettingShowProfilePhotoType:
		var userPrivacySettingShowProfilePhoto UserPrivacySettingShowProfilePhoto
		err := json.Unmarshal(*rawMsg, &userPrivacySettingShowProfilePhoto)
		return &userPrivacySettingShowProfilePhoto, err

	case UserPrivacySettingShowLinkInForwardedMessagesType:
		var userPrivacySettingShowLinkInForwardedMessages UserPrivacySettingShowLinkInForwardedMessages
		err := json.Unmarshal(*rawMsg, &userPrivacySettingShowLinkInForwardedMessages)
		return &userPrivacySettingShowLinkInForwardedMessages, err

	case UserPrivacySettingShowPhoneNumberType:
		var userPrivacySettingShowPhoneNumber UserPrivacySettingShowPhoneNumber
		err := json.Unmarshal(*rawMsg, &userPrivacySettingShowPhoneNumber)
		return &userPrivacySettingShowPhoneNumber, err

	case UserPrivacySettingAllowChatInvitesType:
		var userPrivacySettingAllowChatInvites UserPrivacySettingAllowChatInvites
		err := json.Unmarshal(*rawMsg, &userPrivacySettingAllowChatInvites)
		return &userPrivacySettingAllowChatInvites, err

	case UserPrivacySettingAllowCallsType:
		var userPrivacySettingAllowCalls UserPrivacySettingAllowCalls
		err := json.Unmarshal(*rawMsg, &userPrivacySettingAllowCalls)
		return &userPrivacySettingAllowCalls, err

	case UserPrivacySettingAllowPeerToPeerCallsType:
		var userPrivacySettingAllowPeerToPeerCalls UserPrivacySettingAllowPeerToPeerCalls
		err := json.Unmarshal(*rawMsg, &userPrivacySettingAllowPeerToPeerCalls)
		return &userPrivacySettingAllowPeerToPeerCalls, err

	case UserPrivacySettingAllowFindingByPhoneNumberType:
		var userPrivacySettingAllowFindingByPhoneNumber UserPrivacySettingAllowFindingByPhoneNumber
		err := json.Unmarshal(*rawMsg, &userPrivacySettingAllowFindingByPhoneNumber)
		return &userPrivacySettingAllowFindingByPhoneNumber, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalUserPrivacySettingSlice(rawMsg *json.RawMessage) ([]UserPrivacySetting, error) {
	objects := make([]UserPrivacySetting, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch UserPrivacySettingEnum(objMap["@type"].(string)) {
		case UserPrivacySettingShowStatusType:
			var userPrivacySettingShowStatus UserPrivacySettingShowStatus
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &userPrivacySettingShowStatus)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &userPrivacySettingShowStatus)
		case UserPrivacySettingShowProfilePhotoType:
			var userPrivacySettingShowProfilePhoto UserPrivacySettingShowProfilePhoto
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &userPrivacySettingShowProfilePhoto)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &userPrivacySettingShowProfilePhoto)
		case UserPrivacySettingShowLinkInForwardedMessagesType:
			var userPrivacySettingShowLinkInForwardedMessages UserPrivacySettingShowLinkInForwardedMessages
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &userPrivacySettingShowLinkInForwardedMessages)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &userPrivacySettingShowLinkInForwardedMessages)
		case UserPrivacySettingShowPhoneNumberType:
			var userPrivacySettingShowPhoneNumber UserPrivacySettingShowPhoneNumber
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &userPrivacySettingShowPhoneNumber)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &userPrivacySettingShowPhoneNumber)
		case UserPrivacySettingAllowChatInvitesType:
			var userPrivacySettingAllowChatInvites UserPrivacySettingAllowChatInvites
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &userPrivacySettingAllowChatInvites)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &userPrivacySettingAllowChatInvites)
		case UserPrivacySettingAllowCallsType:
			var userPrivacySettingAllowCalls UserPrivacySettingAllowCalls
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &userPrivacySettingAllowCalls)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &userPrivacySettingAllowCalls)
		case UserPrivacySettingAllowPeerToPeerCallsType:
			var userPrivacySettingAllowPeerToPeerCalls UserPrivacySettingAllowPeerToPeerCalls
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &userPrivacySettingAllowPeerToPeerCalls)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &userPrivacySettingAllowPeerToPeerCalls)
		case UserPrivacySettingAllowFindingByPhoneNumberType:
			var userPrivacySettingAllowFindingByPhoneNumber UserPrivacySettingAllowFindingByPhoneNumber
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &userPrivacySettingAllowFindingByPhoneNumber)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &userPrivacySettingAllowFindingByPhoneNumber)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// ChatReportReason Describes the reason why a chat is reported
type ChatReportReason interface {
	GetChatReportReasonEnum() ChatReportReasonEnum
}

// ChatReportReasonEnum Alias for abstract ChatReportReason 'Sub-Classes', used as constant-enum here
type ChatReportReasonEnum string

// ChatReportReason enums
const (
	ChatReportReasonSpamType              ChatReportReasonEnum = "chatReportReasonSpam"
	ChatReportReasonViolenceType          ChatReportReasonEnum = "chatReportReasonViolence"
	ChatReportReasonPornographyType       ChatReportReasonEnum = "chatReportReasonPornography"
	ChatReportReasonChildAbuseType        ChatReportReasonEnum = "chatReportReasonChildAbuse"
	ChatReportReasonCopyrightType         ChatReportReasonEnum = "chatReportReasonCopyright"
	ChatReportReasonUnrelatedLocationType ChatReportReasonEnum = "chatReportReasonUnrelatedLocation"
	ChatReportReasonFakeType              ChatReportReasonEnum = "chatReportReasonFake"
	ChatReportReasonCustomType            ChatReportReasonEnum = "chatReportReasonCustom"
)

func unmarshalChatReportReason(rawMsg *json.RawMessage) (ChatReportReason, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch ChatReportReasonEnum(objMap["@type"].(string)) {
	case ChatReportReasonSpamType:
		var chatReportReasonSpam ChatReportReasonSpam
		err := json.Unmarshal(*rawMsg, &chatReportReasonSpam)
		return &chatReportReasonSpam, err

	case ChatReportReasonViolenceType:
		var chatReportReasonViolence ChatReportReasonViolence
		err := json.Unmarshal(*rawMsg, &chatReportReasonViolence)
		return &chatReportReasonViolence, err

	case ChatReportReasonPornographyType:
		var chatReportReasonPornography ChatReportReasonPornography
		err := json.Unmarshal(*rawMsg, &chatReportReasonPornography)
		return &chatReportReasonPornography, err

	case ChatReportReasonChildAbuseType:
		var chatReportReasonChildAbuse ChatReportReasonChildAbuse
		err := json.Unmarshal(*rawMsg, &chatReportReasonChildAbuse)
		return &chatReportReasonChildAbuse, err

	case ChatReportReasonCopyrightType:
		var chatReportReasonCopyright ChatReportReasonCopyright
		err := json.Unmarshal(*rawMsg, &chatReportReasonCopyright)
		return &chatReportReasonCopyright, err

	case ChatReportReasonUnrelatedLocationType:
		var chatReportReasonUnrelatedLocation ChatReportReasonUnrelatedLocation
		err := json.Unmarshal(*rawMsg, &chatReportReasonUnrelatedLocation)
		return &chatReportReasonUnrelatedLocation, err

	case ChatReportReasonFakeType:
		var chatReportReasonFake ChatReportReasonFake
		err := json.Unmarshal(*rawMsg, &chatReportReasonFake)
		return &chatReportReasonFake, err

	case ChatReportReasonCustomType:
		var chatReportReasonCustom ChatReportReasonCustom
		err := json.Unmarshal(*rawMsg, &chatReportReasonCustom)
		return &chatReportReasonCustom, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalChatReportReasonSlice(rawMsg *json.RawMessage) ([]ChatReportReason, error) {
	objects := make([]ChatReportReason, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch ChatReportReasonEnum(objMap["@type"].(string)) {
		case ChatReportReasonSpamType:
			var chatReportReasonSpam ChatReportReasonSpam
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatReportReasonSpam)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatReportReasonSpam)
		case ChatReportReasonViolenceType:
			var chatReportReasonViolence ChatReportReasonViolence
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatReportReasonViolence)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatReportReasonViolence)
		case ChatReportReasonPornographyType:
			var chatReportReasonPornography ChatReportReasonPornography
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatReportReasonPornography)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatReportReasonPornography)
		case ChatReportReasonChildAbuseType:
			var chatReportReasonChildAbuse ChatReportReasonChildAbuse
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatReportReasonChildAbuse)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatReportReasonChildAbuse)
		case ChatReportReasonCopyrightType:
			var chatReportReasonCopyright ChatReportReasonCopyright
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatReportReasonCopyright)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatReportReasonCopyright)
		case ChatReportReasonUnrelatedLocationType:
			var chatReportReasonUnrelatedLocation ChatReportReasonUnrelatedLocation
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatReportReasonUnrelatedLocation)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatReportReasonUnrelatedLocation)
		case ChatReportReasonFakeType:
			var chatReportReasonFake ChatReportReasonFake
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatReportReasonFake)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatReportReasonFake)
		case ChatReportReasonCustomType:
			var chatReportReasonCustom ChatReportReasonCustom
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatReportReasonCustom)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatReportReasonCustom)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// InternalLinkType Describes an internal https://t.me or tg: link, which must be processed by the app in a special way
type InternalLinkType interface {
	GetInternalLinkTypeEnum() InternalLinkTypeEnum
}

// InternalLinkTypeEnum Alias for abstract InternalLinkType 'Sub-Classes', used as constant-enum here
type InternalLinkTypeEnum string

// InternalLinkType enums
const (
	InternalLinkTypeActiveSessionsType          InternalLinkTypeEnum = "internalLinkTypeActiveSessions"
	InternalLinkTypeAuthenticationCodeType      InternalLinkTypeEnum = "internalLinkTypeAuthenticationCode"
	InternalLinkTypeBackgroundType              InternalLinkTypeEnum = "internalLinkTypeBackground"
	InternalLinkTypeBotStartType                InternalLinkTypeEnum = "internalLinkTypeBotStart"
	InternalLinkTypeBotStartInGroupType         InternalLinkTypeEnum = "internalLinkTypeBotStartInGroup"
	InternalLinkTypeChangePhoneNumberType       InternalLinkTypeEnum = "internalLinkTypeChangePhoneNumber"
	InternalLinkTypeChatInviteType              InternalLinkTypeEnum = "internalLinkTypeChatInvite"
	InternalLinkTypeFilterSettingsType          InternalLinkTypeEnum = "internalLinkTypeFilterSettings"
	InternalLinkTypeGameType                    InternalLinkTypeEnum = "internalLinkTypeGame"
	InternalLinkTypeLanguagePackType            InternalLinkTypeEnum = "internalLinkTypeLanguagePack"
	InternalLinkTypeMessageType                 InternalLinkTypeEnum = "internalLinkTypeMessage"
	InternalLinkTypeMessageDraftType            InternalLinkTypeEnum = "internalLinkTypeMessageDraft"
	InternalLinkTypePassportDataRequestType     InternalLinkTypeEnum = "internalLinkTypePassportDataRequest"
	InternalLinkTypePhoneNumberConfirmationType InternalLinkTypeEnum = "internalLinkTypePhoneNumberConfirmation"
	InternalLinkTypeProxyType                   InternalLinkTypeEnum = "internalLinkTypeProxy"
	InternalLinkTypePublicChatType              InternalLinkTypeEnum = "internalLinkTypePublicChat"
	InternalLinkTypeQrCodeAuthenticationType    InternalLinkTypeEnum = "internalLinkTypeQrCodeAuthentication"
	InternalLinkTypeSettingsType                InternalLinkTypeEnum = "internalLinkTypeSettings"
	InternalLinkTypeStickerSetType              InternalLinkTypeEnum = "internalLinkTypeStickerSet"
	InternalLinkTypeThemeType                   InternalLinkTypeEnum = "internalLinkTypeTheme"
	InternalLinkTypeThemeSettingsType           InternalLinkTypeEnum = "internalLinkTypeThemeSettings"
	InternalLinkTypeUnknownDeepLinkType         InternalLinkTypeEnum = "internalLinkTypeUnknownDeepLink"
	InternalLinkTypeUnsupportedProxyType        InternalLinkTypeEnum = "internalLinkTypeUnsupportedProxy"
	InternalLinkTypeVideoChatType               InternalLinkTypeEnum = "internalLinkTypeVideoChat"
)

func unmarshalInternalLinkType(rawMsg *json.RawMessage) (InternalLinkType, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch InternalLinkTypeEnum(objMap["@type"].(string)) {
	case InternalLinkTypeActiveSessionsType:
		var internalLinkTypeActiveSessions InternalLinkTypeActiveSessions
		err := json.Unmarshal(*rawMsg, &internalLinkTypeActiveSessions)
		return &internalLinkTypeActiveSessions, err

	case InternalLinkTypeAuthenticationCodeType:
		var internalLinkTypeAuthenticationCode InternalLinkTypeAuthenticationCode
		err := json.Unmarshal(*rawMsg, &internalLinkTypeAuthenticationCode)
		return &internalLinkTypeAuthenticationCode, err

	case InternalLinkTypeBackgroundType:
		var internalLinkTypeBackground InternalLinkTypeBackground
		err := json.Unmarshal(*rawMsg, &internalLinkTypeBackground)
		return &internalLinkTypeBackground, err

	case InternalLinkTypeBotStartType:
		var internalLinkTypeBotStart InternalLinkTypeBotStart
		err := json.Unmarshal(*rawMsg, &internalLinkTypeBotStart)
		return &internalLinkTypeBotStart, err

	case InternalLinkTypeBotStartInGroupType:
		var internalLinkTypeBotStartInGroup InternalLinkTypeBotStartInGroup
		err := json.Unmarshal(*rawMsg, &internalLinkTypeBotStartInGroup)
		return &internalLinkTypeBotStartInGroup, err

	case InternalLinkTypeChangePhoneNumberType:
		var internalLinkTypeChangePhoneNumber InternalLinkTypeChangePhoneNumber
		err := json.Unmarshal(*rawMsg, &internalLinkTypeChangePhoneNumber)
		return &internalLinkTypeChangePhoneNumber, err

	case InternalLinkTypeChatInviteType:
		var internalLinkTypeChatInvite InternalLinkTypeChatInvite
		err := json.Unmarshal(*rawMsg, &internalLinkTypeChatInvite)
		return &internalLinkTypeChatInvite, err

	case InternalLinkTypeFilterSettingsType:
		var internalLinkTypeFilterSettings InternalLinkTypeFilterSettings
		err := json.Unmarshal(*rawMsg, &internalLinkTypeFilterSettings)
		return &internalLinkTypeFilterSettings, err

	case InternalLinkTypeGameType:
		var internalLinkTypeGame InternalLinkTypeGame
		err := json.Unmarshal(*rawMsg, &internalLinkTypeGame)
		return &internalLinkTypeGame, err

	case InternalLinkTypeLanguagePackType:
		var internalLinkTypeLanguagePack InternalLinkTypeLanguagePack
		err := json.Unmarshal(*rawMsg, &internalLinkTypeLanguagePack)
		return &internalLinkTypeLanguagePack, err

	case InternalLinkTypeMessageType:
		var internalLinkTypeMessage InternalLinkTypeMessage
		err := json.Unmarshal(*rawMsg, &internalLinkTypeMessage)
		return &internalLinkTypeMessage, err

	case InternalLinkTypeMessageDraftType:
		var internalLinkTypeMessageDraft InternalLinkTypeMessageDraft
		err := json.Unmarshal(*rawMsg, &internalLinkTypeMessageDraft)
		return &internalLinkTypeMessageDraft, err

	case InternalLinkTypePassportDataRequestType:
		var internalLinkTypePassportDataRequest InternalLinkTypePassportDataRequest
		err := json.Unmarshal(*rawMsg, &internalLinkTypePassportDataRequest)
		return &internalLinkTypePassportDataRequest, err

	case InternalLinkTypePhoneNumberConfirmationType:
		var internalLinkTypePhoneNumberConfirmation InternalLinkTypePhoneNumberConfirmation
		err := json.Unmarshal(*rawMsg, &internalLinkTypePhoneNumberConfirmation)
		return &internalLinkTypePhoneNumberConfirmation, err

	case InternalLinkTypeProxyType:
		var internalLinkTypeProxy InternalLinkTypeProxy
		err := json.Unmarshal(*rawMsg, &internalLinkTypeProxy)
		return &internalLinkTypeProxy, err

	case InternalLinkTypePublicChatType:
		var internalLinkTypePublicChat InternalLinkTypePublicChat
		err := json.Unmarshal(*rawMsg, &internalLinkTypePublicChat)
		return &internalLinkTypePublicChat, err

	case InternalLinkTypeQrCodeAuthenticationType:
		var internalLinkTypeQrCodeAuthentication InternalLinkTypeQrCodeAuthentication
		err := json.Unmarshal(*rawMsg, &internalLinkTypeQrCodeAuthentication)
		return &internalLinkTypeQrCodeAuthentication, err

	case InternalLinkTypeSettingsType:
		var internalLinkTypeSettings InternalLinkTypeSettings
		err := json.Unmarshal(*rawMsg, &internalLinkTypeSettings)
		return &internalLinkTypeSettings, err

	case InternalLinkTypeStickerSetType:
		var internalLinkTypeStickerSet InternalLinkTypeStickerSet
		err := json.Unmarshal(*rawMsg, &internalLinkTypeStickerSet)
		return &internalLinkTypeStickerSet, err

	case InternalLinkTypeThemeType:
		var internalLinkTypeTheme InternalLinkTypeTheme
		err := json.Unmarshal(*rawMsg, &internalLinkTypeTheme)
		return &internalLinkTypeTheme, err

	case InternalLinkTypeThemeSettingsType:
		var internalLinkTypeThemeSettings InternalLinkTypeThemeSettings
		err := json.Unmarshal(*rawMsg, &internalLinkTypeThemeSettings)
		return &internalLinkTypeThemeSettings, err

	case InternalLinkTypeUnknownDeepLinkType:
		var internalLinkTypeUnknownDeepLink InternalLinkTypeUnknownDeepLink
		err := json.Unmarshal(*rawMsg, &internalLinkTypeUnknownDeepLink)
		return &internalLinkTypeUnknownDeepLink, err

	case InternalLinkTypeUnsupportedProxyType:
		var internalLinkTypeUnsupportedProxy InternalLinkTypeUnsupportedProxy
		err := json.Unmarshal(*rawMsg, &internalLinkTypeUnsupportedProxy)
		return &internalLinkTypeUnsupportedProxy, err

	case InternalLinkTypeVideoChatType:
		var internalLinkTypeVideoChat InternalLinkTypeVideoChat
		err := json.Unmarshal(*rawMsg, &internalLinkTypeVideoChat)
		return &internalLinkTypeVideoChat, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalInternalLinkTypeSlice(rawMsg *json.RawMessage) ([]InternalLinkType, error) {
	objects := make([]InternalLinkType, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch InternalLinkTypeEnum(objMap["@type"].(string)) {
		case InternalLinkTypeActiveSessionsType:
			var internalLinkTypeActiveSessions InternalLinkTypeActiveSessions
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &internalLinkTypeActiveSessions)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &internalLinkTypeActiveSessions)
		case InternalLinkTypeAuthenticationCodeType:
			var internalLinkTypeAuthenticationCode InternalLinkTypeAuthenticationCode
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &internalLinkTypeAuthenticationCode)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &internalLinkTypeAuthenticationCode)
		case InternalLinkTypeBackgroundType:
			var internalLinkTypeBackground InternalLinkTypeBackground
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &internalLinkTypeBackground)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &internalLinkTypeBackground)
		case InternalLinkTypeBotStartType:
			var internalLinkTypeBotStart InternalLinkTypeBotStart
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &internalLinkTypeBotStart)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &internalLinkTypeBotStart)
		case InternalLinkTypeBotStartInGroupType:
			var internalLinkTypeBotStartInGroup InternalLinkTypeBotStartInGroup
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &internalLinkTypeBotStartInGroup)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &internalLinkTypeBotStartInGroup)
		case InternalLinkTypeChangePhoneNumberType:
			var internalLinkTypeChangePhoneNumber InternalLinkTypeChangePhoneNumber
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &internalLinkTypeChangePhoneNumber)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &internalLinkTypeChangePhoneNumber)
		case InternalLinkTypeChatInviteType:
			var internalLinkTypeChatInvite InternalLinkTypeChatInvite
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &internalLinkTypeChatInvite)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &internalLinkTypeChatInvite)
		case InternalLinkTypeFilterSettingsType:
			var internalLinkTypeFilterSettings InternalLinkTypeFilterSettings
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &internalLinkTypeFilterSettings)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &internalLinkTypeFilterSettings)
		case InternalLinkTypeGameType:
			var internalLinkTypeGame InternalLinkTypeGame
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &internalLinkTypeGame)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &internalLinkTypeGame)
		case InternalLinkTypeLanguagePackType:
			var internalLinkTypeLanguagePack InternalLinkTypeLanguagePack
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &internalLinkTypeLanguagePack)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &internalLinkTypeLanguagePack)
		case InternalLinkTypeMessageType:
			var internalLinkTypeMessage InternalLinkTypeMessage
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &internalLinkTypeMessage)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &internalLinkTypeMessage)
		case InternalLinkTypeMessageDraftType:
			var internalLinkTypeMessageDraft InternalLinkTypeMessageDraft
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &internalLinkTypeMessageDraft)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &internalLinkTypeMessageDraft)
		case InternalLinkTypePassportDataRequestType:
			var internalLinkTypePassportDataRequest InternalLinkTypePassportDataRequest
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &internalLinkTypePassportDataRequest)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &internalLinkTypePassportDataRequest)
		case InternalLinkTypePhoneNumberConfirmationType:
			var internalLinkTypePhoneNumberConfirmation InternalLinkTypePhoneNumberConfirmation
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &internalLinkTypePhoneNumberConfirmation)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &internalLinkTypePhoneNumberConfirmation)
		case InternalLinkTypeProxyType:
			var internalLinkTypeProxy InternalLinkTypeProxy
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &internalLinkTypeProxy)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &internalLinkTypeProxy)
		case InternalLinkTypePublicChatType:
			var internalLinkTypePublicChat InternalLinkTypePublicChat
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &internalLinkTypePublicChat)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &internalLinkTypePublicChat)
		case InternalLinkTypeQrCodeAuthenticationType:
			var internalLinkTypeQrCodeAuthentication InternalLinkTypeQrCodeAuthentication
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &internalLinkTypeQrCodeAuthentication)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &internalLinkTypeQrCodeAuthentication)
		case InternalLinkTypeSettingsType:
			var internalLinkTypeSettings InternalLinkTypeSettings
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &internalLinkTypeSettings)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &internalLinkTypeSettings)
		case InternalLinkTypeStickerSetType:
			var internalLinkTypeStickerSet InternalLinkTypeStickerSet
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &internalLinkTypeStickerSet)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &internalLinkTypeStickerSet)
		case InternalLinkTypeThemeType:
			var internalLinkTypeTheme InternalLinkTypeTheme
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &internalLinkTypeTheme)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &internalLinkTypeTheme)
		case InternalLinkTypeThemeSettingsType:
			var internalLinkTypeThemeSettings InternalLinkTypeThemeSettings
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &internalLinkTypeThemeSettings)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &internalLinkTypeThemeSettings)
		case InternalLinkTypeUnknownDeepLinkType:
			var internalLinkTypeUnknownDeepLink InternalLinkTypeUnknownDeepLink
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &internalLinkTypeUnknownDeepLink)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &internalLinkTypeUnknownDeepLink)
		case InternalLinkTypeUnsupportedProxyType:
			var internalLinkTypeUnsupportedProxy InternalLinkTypeUnsupportedProxy
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &internalLinkTypeUnsupportedProxy)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &internalLinkTypeUnsupportedProxy)
		case InternalLinkTypeVideoChatType:
			var internalLinkTypeVideoChat InternalLinkTypeVideoChat
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &internalLinkTypeVideoChat)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &internalLinkTypeVideoChat)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// FileType Represents the type of a file
type FileType interface {
	GetFileTypeEnum() FileTypeEnum
}

// FileTypeEnum Alias for abstract FileType 'Sub-Classes', used as constant-enum here
type FileTypeEnum string

// FileType enums
const (
	FileTypeNoneType            FileTypeEnum = "fileTypeNone"
	FileTypeAnimationType       FileTypeEnum = "fileTypeAnimation"
	FileTypeAudioType           FileTypeEnum = "fileTypeAudio"
	FileTypeDocumentType        FileTypeEnum = "fileTypeDocument"
	FileTypePhotoType           FileTypeEnum = "fileTypePhoto"
	FileTypeProfilePhotoType    FileTypeEnum = "fileTypeProfilePhoto"
	FileTypeSecretType          FileTypeEnum = "fileTypeSecret"
	FileTypeSecretThumbnailType FileTypeEnum = "fileTypeSecretThumbnail"
	FileTypeSecureType          FileTypeEnum = "fileTypeSecure"
	FileTypeStickerType         FileTypeEnum = "fileTypeSticker"
	FileTypeThumbnailType       FileTypeEnum = "fileTypeThumbnail"
	FileTypeUnknownType         FileTypeEnum = "fileTypeUnknown"
	FileTypeVideoType           FileTypeEnum = "fileTypeVideo"
	FileTypeVideoNoteType       FileTypeEnum = "fileTypeVideoNote"
	FileTypeVoiceNoteType       FileTypeEnum = "fileTypeVoiceNote"
	FileTypeWallpaperType       FileTypeEnum = "fileTypeWallpaper"
)

func unmarshalFileType(rawMsg *json.RawMessage) (FileType, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch FileTypeEnum(objMap["@type"].(string)) {
	case FileTypeNoneType:
		var fileTypeNone FileTypeNone
		err := json.Unmarshal(*rawMsg, &fileTypeNone)
		return &fileTypeNone, err

	case FileTypeAnimationType:
		var fileTypeAnimation FileTypeAnimation
		err := json.Unmarshal(*rawMsg, &fileTypeAnimation)
		return &fileTypeAnimation, err

	case FileTypeAudioType:
		var fileTypeAudio FileTypeAudio
		err := json.Unmarshal(*rawMsg, &fileTypeAudio)
		return &fileTypeAudio, err

	case FileTypeDocumentType:
		var fileTypeDocument FileTypeDocument
		err := json.Unmarshal(*rawMsg, &fileTypeDocument)
		return &fileTypeDocument, err

	case FileTypePhotoType:
		var fileTypePhoto FileTypePhoto
		err := json.Unmarshal(*rawMsg, &fileTypePhoto)
		return &fileTypePhoto, err

	case FileTypeProfilePhotoType:
		var fileTypeProfilePhoto FileTypeProfilePhoto
		err := json.Unmarshal(*rawMsg, &fileTypeProfilePhoto)
		return &fileTypeProfilePhoto, err

	case FileTypeSecretType:
		var fileTypeSecret FileTypeSecret
		err := json.Unmarshal(*rawMsg, &fileTypeSecret)
		return &fileTypeSecret, err

	case FileTypeSecretThumbnailType:
		var fileTypeSecretThumbnail FileTypeSecretThumbnail
		err := json.Unmarshal(*rawMsg, &fileTypeSecretThumbnail)
		return &fileTypeSecretThumbnail, err

	case FileTypeSecureType:
		var fileTypeSecure FileTypeSecure
		err := json.Unmarshal(*rawMsg, &fileTypeSecure)
		return &fileTypeSecure, err

	case FileTypeStickerType:
		var fileTypeSticker FileTypeSticker
		err := json.Unmarshal(*rawMsg, &fileTypeSticker)
		return &fileTypeSticker, err

	case FileTypeThumbnailType:
		var fileTypeThumbnail FileTypeThumbnail
		err := json.Unmarshal(*rawMsg, &fileTypeThumbnail)
		return &fileTypeThumbnail, err

	case FileTypeUnknownType:
		var fileTypeUnknown FileTypeUnknown
		err := json.Unmarshal(*rawMsg, &fileTypeUnknown)
		return &fileTypeUnknown, err

	case FileTypeVideoType:
		var fileTypeVideo FileTypeVideo
		err := json.Unmarshal(*rawMsg, &fileTypeVideo)
		return &fileTypeVideo, err

	case FileTypeVideoNoteType:
		var fileTypeVideoNote FileTypeVideoNote
		err := json.Unmarshal(*rawMsg, &fileTypeVideoNote)
		return &fileTypeVideoNote, err

	case FileTypeVoiceNoteType:
		var fileTypeVoiceNote FileTypeVoiceNote
		err := json.Unmarshal(*rawMsg, &fileTypeVoiceNote)
		return &fileTypeVoiceNote, err

	case FileTypeWallpaperType:
		var fileTypeWallpaper FileTypeWallpaper
		err := json.Unmarshal(*rawMsg, &fileTypeWallpaper)
		return &fileTypeWallpaper, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalFileTypeSlice(rawMsg *json.RawMessage) ([]FileType, error) {
	objects := make([]FileType, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch FileTypeEnum(objMap["@type"].(string)) {
		case FileTypeNoneType:
			var fileTypeNone FileTypeNone
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &fileTypeNone)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &fileTypeNone)
		case FileTypeAnimationType:
			var fileTypeAnimation FileTypeAnimation
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &fileTypeAnimation)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &fileTypeAnimation)
		case FileTypeAudioType:
			var fileTypeAudio FileTypeAudio
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &fileTypeAudio)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &fileTypeAudio)
		case FileTypeDocumentType:
			var fileTypeDocument FileTypeDocument
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &fileTypeDocument)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &fileTypeDocument)
		case FileTypePhotoType:
			var fileTypePhoto FileTypePhoto
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &fileTypePhoto)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &fileTypePhoto)
		case FileTypeProfilePhotoType:
			var fileTypeProfilePhoto FileTypeProfilePhoto
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &fileTypeProfilePhoto)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &fileTypeProfilePhoto)
		case FileTypeSecretType:
			var fileTypeSecret FileTypeSecret
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &fileTypeSecret)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &fileTypeSecret)
		case FileTypeSecretThumbnailType:
			var fileTypeSecretThumbnail FileTypeSecretThumbnail
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &fileTypeSecretThumbnail)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &fileTypeSecretThumbnail)
		case FileTypeSecureType:
			var fileTypeSecure FileTypeSecure
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &fileTypeSecure)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &fileTypeSecure)
		case FileTypeStickerType:
			var fileTypeSticker FileTypeSticker
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &fileTypeSticker)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &fileTypeSticker)
		case FileTypeThumbnailType:
			var fileTypeThumbnail FileTypeThumbnail
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &fileTypeThumbnail)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &fileTypeThumbnail)
		case FileTypeUnknownType:
			var fileTypeUnknown FileTypeUnknown
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &fileTypeUnknown)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &fileTypeUnknown)
		case FileTypeVideoType:
			var fileTypeVideo FileTypeVideo
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &fileTypeVideo)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &fileTypeVideo)
		case FileTypeVideoNoteType:
			var fileTypeVideoNote FileTypeVideoNote
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &fileTypeVideoNote)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &fileTypeVideoNote)
		case FileTypeVoiceNoteType:
			var fileTypeVoiceNote FileTypeVoiceNote
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &fileTypeVoiceNote)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &fileTypeVoiceNote)
		case FileTypeWallpaperType:
			var fileTypeWallpaper FileTypeWallpaper
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &fileTypeWallpaper)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &fileTypeWallpaper)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// NetworkType Represents the type of a network
type NetworkType interface {
	GetNetworkTypeEnum() NetworkTypeEnum
}

// NetworkTypeEnum Alias for abstract NetworkType 'Sub-Classes', used as constant-enum here
type NetworkTypeEnum string

// NetworkType enums
const (
	NetworkTypeNoneType          NetworkTypeEnum = "networkTypeNone"
	NetworkTypeMobileType        NetworkTypeEnum = "networkTypeMobile"
	NetworkTypeMobileRoamingType NetworkTypeEnum = "networkTypeMobileRoaming"
	NetworkTypeWiFiType          NetworkTypeEnum = "networkTypeWiFi"
	NetworkTypeOtherType         NetworkTypeEnum = "networkTypeOther"
)

func unmarshalNetworkType(rawMsg *json.RawMessage) (NetworkType, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch NetworkTypeEnum(objMap["@type"].(string)) {
	case NetworkTypeNoneType:
		var networkTypeNone NetworkTypeNone
		err := json.Unmarshal(*rawMsg, &networkTypeNone)
		return &networkTypeNone, err

	case NetworkTypeMobileType:
		var networkTypeMobile NetworkTypeMobile
		err := json.Unmarshal(*rawMsg, &networkTypeMobile)
		return &networkTypeMobile, err

	case NetworkTypeMobileRoamingType:
		var networkTypeMobileRoaming NetworkTypeMobileRoaming
		err := json.Unmarshal(*rawMsg, &networkTypeMobileRoaming)
		return &networkTypeMobileRoaming, err

	case NetworkTypeWiFiType:
		var networkTypeWiFi NetworkTypeWiFi
		err := json.Unmarshal(*rawMsg, &networkTypeWiFi)
		return &networkTypeWiFi, err

	case NetworkTypeOtherType:
		var networkTypeOther NetworkTypeOther
		err := json.Unmarshal(*rawMsg, &networkTypeOther)
		return &networkTypeOther, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalNetworkTypeSlice(rawMsg *json.RawMessage) ([]NetworkType, error) {
	objects := make([]NetworkType, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch NetworkTypeEnum(objMap["@type"].(string)) {
		case NetworkTypeNoneType:
			var networkTypeNone NetworkTypeNone
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &networkTypeNone)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &networkTypeNone)
		case NetworkTypeMobileType:
			var networkTypeMobile NetworkTypeMobile
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &networkTypeMobile)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &networkTypeMobile)
		case NetworkTypeMobileRoamingType:
			var networkTypeMobileRoaming NetworkTypeMobileRoaming
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &networkTypeMobileRoaming)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &networkTypeMobileRoaming)
		case NetworkTypeWiFiType:
			var networkTypeWiFi NetworkTypeWiFi
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &networkTypeWiFi)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &networkTypeWiFi)
		case NetworkTypeOtherType:
			var networkTypeOther NetworkTypeOther
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &networkTypeOther)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &networkTypeOther)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// NetworkStatisticsEntry Contains statistics about network usage
type NetworkStatisticsEntry interface {
	GetNetworkStatisticsEntryEnum() NetworkStatisticsEntryEnum
}

// NetworkStatisticsEntryEnum Alias for abstract NetworkStatisticsEntry 'Sub-Classes', used as constant-enum here
type NetworkStatisticsEntryEnum string

// NetworkStatisticsEntry enums
const (
	NetworkStatisticsEntryFileType NetworkStatisticsEntryEnum = "networkStatisticsEntryFile"
	NetworkStatisticsEntryCallType NetworkStatisticsEntryEnum = "networkStatisticsEntryCall"
)

func unmarshalNetworkStatisticsEntry(rawMsg *json.RawMessage) (NetworkStatisticsEntry, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch NetworkStatisticsEntryEnum(objMap["@type"].(string)) {
	case NetworkStatisticsEntryFileType:
		var networkStatisticsEntryFile NetworkStatisticsEntryFile
		err := json.Unmarshal(*rawMsg, &networkStatisticsEntryFile)
		return &networkStatisticsEntryFile, err

	case NetworkStatisticsEntryCallType:
		var networkStatisticsEntryCall NetworkStatisticsEntryCall
		err := json.Unmarshal(*rawMsg, &networkStatisticsEntryCall)
		return &networkStatisticsEntryCall, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalNetworkStatisticsEntrySlice(rawMsg *json.RawMessage) ([]NetworkStatisticsEntry, error) {
	objects := make([]NetworkStatisticsEntry, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch NetworkStatisticsEntryEnum(objMap["@type"].(string)) {
		case NetworkStatisticsEntryFileType:
			var networkStatisticsEntryFile NetworkStatisticsEntryFile
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &networkStatisticsEntryFile)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &networkStatisticsEntryFile)
		case NetworkStatisticsEntryCallType:
			var networkStatisticsEntryCall NetworkStatisticsEntryCall
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &networkStatisticsEntryCall)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &networkStatisticsEntryCall)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// ConnectionState Describes the current state of the connection to Telegram servers
type ConnectionState interface {
	GetConnectionStateEnum() ConnectionStateEnum
}

// ConnectionStateEnum Alias for abstract ConnectionState 'Sub-Classes', used as constant-enum here
type ConnectionStateEnum string

// ConnectionState enums
const (
	ConnectionStateWaitingForNetworkType ConnectionStateEnum = "connectionStateWaitingForNetwork"
	ConnectionStateConnectingToProxyType ConnectionStateEnum = "connectionStateConnectingToProxy"
	ConnectionStateConnectingType        ConnectionStateEnum = "connectionStateConnecting"
	ConnectionStateUpdatingType          ConnectionStateEnum = "connectionStateUpdating"
	ConnectionStateReadyType             ConnectionStateEnum = "connectionStateReady"
)

func unmarshalConnectionState(rawMsg *json.RawMessage) (ConnectionState, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch ConnectionStateEnum(objMap["@type"].(string)) {
	case ConnectionStateWaitingForNetworkType:
		var connectionStateWaitingForNetwork ConnectionStateWaitingForNetwork
		err := json.Unmarshal(*rawMsg, &connectionStateWaitingForNetwork)
		return &connectionStateWaitingForNetwork, err

	case ConnectionStateConnectingToProxyType:
		var connectionStateConnectingToProxy ConnectionStateConnectingToProxy
		err := json.Unmarshal(*rawMsg, &connectionStateConnectingToProxy)
		return &connectionStateConnectingToProxy, err

	case ConnectionStateConnectingType:
		var connectionStateConnecting ConnectionStateConnecting
		err := json.Unmarshal(*rawMsg, &connectionStateConnecting)
		return &connectionStateConnecting, err

	case ConnectionStateUpdatingType:
		var connectionStateUpdating ConnectionStateUpdating
		err := json.Unmarshal(*rawMsg, &connectionStateUpdating)
		return &connectionStateUpdating, err

	case ConnectionStateReadyType:
		var connectionStateReady ConnectionStateReady
		err := json.Unmarshal(*rawMsg, &connectionStateReady)
		return &connectionStateReady, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalConnectionStateSlice(rawMsg *json.RawMessage) ([]ConnectionState, error) {
	objects := make([]ConnectionState, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch ConnectionStateEnum(objMap["@type"].(string)) {
		case ConnectionStateWaitingForNetworkType:
			var connectionStateWaitingForNetwork ConnectionStateWaitingForNetwork
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &connectionStateWaitingForNetwork)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &connectionStateWaitingForNetwork)
		case ConnectionStateConnectingToProxyType:
			var connectionStateConnectingToProxy ConnectionStateConnectingToProxy
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &connectionStateConnectingToProxy)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &connectionStateConnectingToProxy)
		case ConnectionStateConnectingType:
			var connectionStateConnecting ConnectionStateConnecting
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &connectionStateConnecting)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &connectionStateConnecting)
		case ConnectionStateUpdatingType:
			var connectionStateUpdating ConnectionStateUpdating
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &connectionStateUpdating)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &connectionStateUpdating)
		case ConnectionStateReadyType:
			var connectionStateReady ConnectionStateReady
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &connectionStateReady)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &connectionStateReady)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// TopChatCategory Represents the categories of chats for which a list of frequently used chats can be retrieved
type TopChatCategory interface {
	GetTopChatCategoryEnum() TopChatCategoryEnum
}

// TopChatCategoryEnum Alias for abstract TopChatCategory 'Sub-Classes', used as constant-enum here
type TopChatCategoryEnum string

// TopChatCategory enums
const (
	TopChatCategoryUsersType        TopChatCategoryEnum = "topChatCategoryUsers"
	TopChatCategoryBotsType         TopChatCategoryEnum = "topChatCategoryBots"
	TopChatCategoryGroupsType       TopChatCategoryEnum = "topChatCategoryGroups"
	TopChatCategoryChannelsType     TopChatCategoryEnum = "topChatCategoryChannels"
	TopChatCategoryInlineBotsType   TopChatCategoryEnum = "topChatCategoryInlineBots"
	TopChatCategoryCallsType        TopChatCategoryEnum = "topChatCategoryCalls"
	TopChatCategoryForwardChatsType TopChatCategoryEnum = "topChatCategoryForwardChats"
)

func unmarshalTopChatCategory(rawMsg *json.RawMessage) (TopChatCategory, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch TopChatCategoryEnum(objMap["@type"].(string)) {
	case TopChatCategoryUsersType:
		var topChatCategoryUsers TopChatCategoryUsers
		err := json.Unmarshal(*rawMsg, &topChatCategoryUsers)
		return &topChatCategoryUsers, err

	case TopChatCategoryBotsType:
		var topChatCategoryBots TopChatCategoryBots
		err := json.Unmarshal(*rawMsg, &topChatCategoryBots)
		return &topChatCategoryBots, err

	case TopChatCategoryGroupsType:
		var topChatCategoryGroups TopChatCategoryGroups
		err := json.Unmarshal(*rawMsg, &topChatCategoryGroups)
		return &topChatCategoryGroups, err

	case TopChatCategoryChannelsType:
		var topChatCategoryChannels TopChatCategoryChannels
		err := json.Unmarshal(*rawMsg, &topChatCategoryChannels)
		return &topChatCategoryChannels, err

	case TopChatCategoryInlineBotsType:
		var topChatCategoryInlineBots TopChatCategoryInlineBots
		err := json.Unmarshal(*rawMsg, &topChatCategoryInlineBots)
		return &topChatCategoryInlineBots, err

	case TopChatCategoryCallsType:
		var topChatCategoryCalls TopChatCategoryCalls
		err := json.Unmarshal(*rawMsg, &topChatCategoryCalls)
		return &topChatCategoryCalls, err

	case TopChatCategoryForwardChatsType:
		var topChatCategoryForwardChats TopChatCategoryForwardChats
		err := json.Unmarshal(*rawMsg, &topChatCategoryForwardChats)
		return &topChatCategoryForwardChats, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalTopChatCategorySlice(rawMsg *json.RawMessage) ([]TopChatCategory, error) {
	objects := make([]TopChatCategory, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch TopChatCategoryEnum(objMap["@type"].(string)) {
		case TopChatCategoryUsersType:
			var topChatCategoryUsers TopChatCategoryUsers
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &topChatCategoryUsers)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &topChatCategoryUsers)
		case TopChatCategoryBotsType:
			var topChatCategoryBots TopChatCategoryBots
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &topChatCategoryBots)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &topChatCategoryBots)
		case TopChatCategoryGroupsType:
			var topChatCategoryGroups TopChatCategoryGroups
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &topChatCategoryGroups)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &topChatCategoryGroups)
		case TopChatCategoryChannelsType:
			var topChatCategoryChannels TopChatCategoryChannels
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &topChatCategoryChannels)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &topChatCategoryChannels)
		case TopChatCategoryInlineBotsType:
			var topChatCategoryInlineBots TopChatCategoryInlineBots
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &topChatCategoryInlineBots)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &topChatCategoryInlineBots)
		case TopChatCategoryCallsType:
			var topChatCategoryCalls TopChatCategoryCalls
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &topChatCategoryCalls)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &topChatCategoryCalls)
		case TopChatCategoryForwardChatsType:
			var topChatCategoryForwardChats TopChatCategoryForwardChats
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &topChatCategoryForwardChats)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &topChatCategoryForwardChats)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// TMeURLType Describes the type of a URL linking to an internal Telegram entity
type TMeURLType interface {
	GetTMeURLTypeEnum() TMeURLTypeEnum
}

// TMeURLTypeEnum Alias for abstract TMeURLType 'Sub-Classes', used as constant-enum here
type TMeURLTypeEnum string

// TMeURLType enums
const ()

func unmarshalTMeURLType(rawMsg *json.RawMessage) (TMeURLType, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch TMeURLTypeEnum(objMap["@type"].(string)) {

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalTMeURLTypeSlice(rawMsg *json.RawMessage) ([]TMeURLType, error) {
	objects := make([]TMeURLType, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch TMeURLTypeEnum(objMap["@type"].(string)) {

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// SuggestedAction Describes an action suggested to the current user
type SuggestedAction interface {
	GetSuggestedActionEnum() SuggestedActionEnum
}

// SuggestedActionEnum Alias for abstract SuggestedAction 'Sub-Classes', used as constant-enum here
type SuggestedActionEnum string

// SuggestedAction enums
const (
	SuggestedActionEnableArchiveAndMuteNewChatsType SuggestedActionEnum = "suggestedActionEnableArchiveAndMuteNewChats"
	SuggestedActionCheckPasswordType                SuggestedActionEnum = "suggestedActionCheckPassword"
	SuggestedActionCheckPhoneNumberType             SuggestedActionEnum = "suggestedActionCheckPhoneNumber"
	SuggestedActionViewChecksHintType               SuggestedActionEnum = "suggestedActionViewChecksHint"
	SuggestedActionConvertToBroadcastGroupType      SuggestedActionEnum = "suggestedActionConvertToBroadcastGroup"
	SuggestedActionSetPasswordType                  SuggestedActionEnum = "suggestedActionSetPassword"
)

func unmarshalSuggestedAction(rawMsg *json.RawMessage) (SuggestedAction, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch SuggestedActionEnum(objMap["@type"].(string)) {
	case SuggestedActionEnableArchiveAndMuteNewChatsType:
		var suggestedActionEnableArchiveAndMuteNewChats SuggestedActionEnableArchiveAndMuteNewChats
		err := json.Unmarshal(*rawMsg, &suggestedActionEnableArchiveAndMuteNewChats)
		return &suggestedActionEnableArchiveAndMuteNewChats, err

	case SuggestedActionCheckPasswordType:
		var suggestedActionCheckPassword SuggestedActionCheckPassword
		err := json.Unmarshal(*rawMsg, &suggestedActionCheckPassword)
		return &suggestedActionCheckPassword, err

	case SuggestedActionCheckPhoneNumberType:
		var suggestedActionCheckPhoneNumber SuggestedActionCheckPhoneNumber
		err := json.Unmarshal(*rawMsg, &suggestedActionCheckPhoneNumber)
		return &suggestedActionCheckPhoneNumber, err

	case SuggestedActionViewChecksHintType:
		var suggestedActionViewChecksHint SuggestedActionViewChecksHint
		err := json.Unmarshal(*rawMsg, &suggestedActionViewChecksHint)
		return &suggestedActionViewChecksHint, err

	case SuggestedActionConvertToBroadcastGroupType:
		var suggestedActionConvertToBroadcastGroup SuggestedActionConvertToBroadcastGroup
		err := json.Unmarshal(*rawMsg, &suggestedActionConvertToBroadcastGroup)
		return &suggestedActionConvertToBroadcastGroup, err

	case SuggestedActionSetPasswordType:
		var suggestedActionSetPassword SuggestedActionSetPassword
		err := json.Unmarshal(*rawMsg, &suggestedActionSetPassword)
		return &suggestedActionSetPassword, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalSuggestedActionSlice(rawMsg *json.RawMessage) ([]SuggestedAction, error) {
	objects := make([]SuggestedAction, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch SuggestedActionEnum(objMap["@type"].(string)) {
		case SuggestedActionEnableArchiveAndMuteNewChatsType:
			var suggestedActionEnableArchiveAndMuteNewChats SuggestedActionEnableArchiveAndMuteNewChats
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &suggestedActionEnableArchiveAndMuteNewChats)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &suggestedActionEnableArchiveAndMuteNewChats)
		case SuggestedActionCheckPasswordType:
			var suggestedActionCheckPassword SuggestedActionCheckPassword
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &suggestedActionCheckPassword)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &suggestedActionCheckPassword)
		case SuggestedActionCheckPhoneNumberType:
			var suggestedActionCheckPhoneNumber SuggestedActionCheckPhoneNumber
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &suggestedActionCheckPhoneNumber)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &suggestedActionCheckPhoneNumber)
		case SuggestedActionViewChecksHintType:
			var suggestedActionViewChecksHint SuggestedActionViewChecksHint
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &suggestedActionViewChecksHint)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &suggestedActionViewChecksHint)
		case SuggestedActionConvertToBroadcastGroupType:
			var suggestedActionConvertToBroadcastGroup SuggestedActionConvertToBroadcastGroup
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &suggestedActionConvertToBroadcastGroup)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &suggestedActionConvertToBroadcastGroup)
		case SuggestedActionSetPasswordType:
			var suggestedActionSetPassword SuggestedActionSetPassword
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &suggestedActionSetPassword)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &suggestedActionSetPassword)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// TextParseMode Describes the way the text needs to be parsed for TextEntities
type TextParseMode interface {
	GetTextParseModeEnum() TextParseModeEnum
}

// TextParseModeEnum Alias for abstract TextParseMode 'Sub-Classes', used as constant-enum here
type TextParseModeEnum string

// TextParseMode enums
const (
	TextParseModeMarkdownType TextParseModeEnum = "textParseModeMarkdown"
	TextParseModeHTMLType     TextParseModeEnum = "textParseModeHTML"
)

func unmarshalTextParseMode(rawMsg *json.RawMessage) (TextParseMode, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch TextParseModeEnum(objMap["@type"].(string)) {
	case TextParseModeMarkdownType:
		var textParseModeMarkdown TextParseModeMarkdown
		err := json.Unmarshal(*rawMsg, &textParseModeMarkdown)
		return &textParseModeMarkdown, err

	case TextParseModeHTMLType:
		var textParseModeHTML TextParseModeHTML
		err := json.Unmarshal(*rawMsg, &textParseModeHTML)
		return &textParseModeHTML, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalTextParseModeSlice(rawMsg *json.RawMessage) ([]TextParseMode, error) {
	objects := make([]TextParseMode, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch TextParseModeEnum(objMap["@type"].(string)) {
		case TextParseModeMarkdownType:
			var textParseModeMarkdown TextParseModeMarkdown
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &textParseModeMarkdown)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &textParseModeMarkdown)
		case TextParseModeHTMLType:
			var textParseModeHTML TextParseModeHTML
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &textParseModeHTML)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &textParseModeHTML)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// ProxyType Describes the type of a proxy server
type ProxyType interface {
	GetProxyTypeEnum() ProxyTypeEnum
}

// ProxyTypeEnum Alias for abstract ProxyType 'Sub-Classes', used as constant-enum here
type ProxyTypeEnum string

// ProxyType enums
const (
	ProxyTypeSocks5Type  ProxyTypeEnum = "proxyTypeSocks5"
	ProxyTypeHttpType    ProxyTypeEnum = "proxyTypeHttp"
	ProxyTypeMtprotoType ProxyTypeEnum = "proxyTypeMtproto"
)

func unmarshalProxyType(rawMsg *json.RawMessage) (ProxyType, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch ProxyTypeEnum(objMap["@type"].(string)) {
	case ProxyTypeSocks5Type:
		var proxyTypeSocks5 ProxyTypeSocks5
		err := json.Unmarshal(*rawMsg, &proxyTypeSocks5)
		return &proxyTypeSocks5, err

	case ProxyTypeHttpType:
		var proxyTypeHttp ProxyTypeHttp
		err := json.Unmarshal(*rawMsg, &proxyTypeHttp)
		return &proxyTypeHttp, err

	case ProxyTypeMtprotoType:
		var proxyTypeMtproto ProxyTypeMtproto
		err := json.Unmarshal(*rawMsg, &proxyTypeMtproto)
		return &proxyTypeMtproto, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalProxyTypeSlice(rawMsg *json.RawMessage) ([]ProxyType, error) {
	objects := make([]ProxyType, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch ProxyTypeEnum(objMap["@type"].(string)) {
		case ProxyTypeSocks5Type:
			var proxyTypeSocks5 ProxyTypeSocks5
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &proxyTypeSocks5)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &proxyTypeSocks5)
		case ProxyTypeHttpType:
			var proxyTypeHttp ProxyTypeHttp
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &proxyTypeHttp)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &proxyTypeHttp)
		case ProxyTypeMtprotoType:
			var proxyTypeMtproto ProxyTypeMtproto
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &proxyTypeMtproto)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &proxyTypeMtproto)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// InputSticker Describes a sticker that needs to be added to a sticker set
type InputSticker interface {
	GetInputStickerEnum() InputStickerEnum
}

// InputStickerEnum Alias for abstract InputSticker 'Sub-Classes', used as constant-enum here
type InputStickerEnum string

// InputSticker enums
const (
	InputStickerStaticType   InputStickerEnum = "inputStickerStatic"
	InputStickerAnimatedType InputStickerEnum = "inputStickerAnimated"
)

func unmarshalInputSticker(rawMsg *json.RawMessage) (InputSticker, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch InputStickerEnum(objMap["@type"].(string)) {
	case InputStickerStaticType:
		var inputStickerStatic InputStickerStatic
		err := json.Unmarshal(*rawMsg, &inputStickerStatic)
		return &inputStickerStatic, err

	case InputStickerAnimatedType:
		var inputStickerAnimated InputStickerAnimated
		err := json.Unmarshal(*rawMsg, &inputStickerAnimated)
		return &inputStickerAnimated, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalInputStickerSlice(rawMsg *json.RawMessage) ([]InputSticker, error) {
	objects := make([]InputSticker, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch InputStickerEnum(objMap["@type"].(string)) {
		case InputStickerStaticType:
			var inputStickerStatic InputStickerStatic
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputStickerStatic)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputStickerStatic)
		case InputStickerAnimatedType:
			var inputStickerAnimated InputStickerAnimated
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &inputStickerAnimated)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &inputStickerAnimated)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// StatisticalGraph Describes a statistical graph
type StatisticalGraph interface {
	GetStatisticalGraphEnum() StatisticalGraphEnum
}

// StatisticalGraphEnum Alias for abstract StatisticalGraph 'Sub-Classes', used as constant-enum here
type StatisticalGraphEnum string

// StatisticalGraph enums
const (
	StatisticalGraphDataType  StatisticalGraphEnum = "statisticalGraphData"
	StatisticalGraphAsyncType StatisticalGraphEnum = "statisticalGraphAsync"
	StatisticalGraphErrorType StatisticalGraphEnum = "statisticalGraphError"
)

func unmarshalStatisticalGraph(rawMsg *json.RawMessage) (StatisticalGraph, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch StatisticalGraphEnum(objMap["@type"].(string)) {
	case StatisticalGraphDataType:
		var statisticalGraphData StatisticalGraphData
		err := json.Unmarshal(*rawMsg, &statisticalGraphData)
		return &statisticalGraphData, err

	case StatisticalGraphAsyncType:
		var statisticalGraphAsync StatisticalGraphAsync
		err := json.Unmarshal(*rawMsg, &statisticalGraphAsync)
		return &statisticalGraphAsync, err

	case StatisticalGraphErrorType:
		var statisticalGraphError StatisticalGraphError
		err := json.Unmarshal(*rawMsg, &statisticalGraphError)
		return &statisticalGraphError, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalStatisticalGraphSlice(rawMsg *json.RawMessage) ([]StatisticalGraph, error) {
	objects := make([]StatisticalGraph, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch StatisticalGraphEnum(objMap["@type"].(string)) {
		case StatisticalGraphDataType:
			var statisticalGraphData StatisticalGraphData
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &statisticalGraphData)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &statisticalGraphData)
		case StatisticalGraphAsyncType:
			var statisticalGraphAsync StatisticalGraphAsync
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &statisticalGraphAsync)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &statisticalGraphAsync)
		case StatisticalGraphErrorType:
			var statisticalGraphError StatisticalGraphError
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &statisticalGraphError)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &statisticalGraphError)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// ChatStatistics Contains a detailed statistics about a chat
type ChatStatistics interface {
	GetChatStatisticsEnum() ChatStatisticsEnum
}

// ChatStatisticsEnum Alias for abstract ChatStatistics 'Sub-Classes', used as constant-enum here
type ChatStatisticsEnum string

// ChatStatistics enums
const (
	ChatStatisticsSupergroupType ChatStatisticsEnum = "chatStatisticsSupergroup"
	ChatStatisticsChannelType    ChatStatisticsEnum = "chatStatisticsChannel"
)

func unmarshalChatStatistics(rawMsg *json.RawMessage) (ChatStatistics, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch ChatStatisticsEnum(objMap["@type"].(string)) {
	case ChatStatisticsSupergroupType:
		var chatStatisticsSupergroup ChatStatisticsSupergroup
		err := json.Unmarshal(*rawMsg, &chatStatisticsSupergroup)
		return &chatStatisticsSupergroup, err

	case ChatStatisticsChannelType:
		var chatStatisticsChannel ChatStatisticsChannel
		err := json.Unmarshal(*rawMsg, &chatStatisticsChannel)
		return &chatStatisticsChannel, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalChatStatisticsSlice(rawMsg *json.RawMessage) ([]ChatStatistics, error) {
	objects := make([]ChatStatistics, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch ChatStatisticsEnum(objMap["@type"].(string)) {
		case ChatStatisticsSupergroupType:
			var chatStatisticsSupergroup ChatStatisticsSupergroup
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatStatisticsSupergroup)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatStatisticsSupergroup)
		case ChatStatisticsChannelType:
			var chatStatisticsChannel ChatStatisticsChannel
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &chatStatisticsChannel)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &chatStatisticsChannel)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// VectorPathCommand Represents a vector path command
type VectorPathCommand interface {
	GetVectorPathCommandEnum() VectorPathCommandEnum
}

// VectorPathCommandEnum Alias for abstract VectorPathCommand 'Sub-Classes', used as constant-enum here
type VectorPathCommandEnum string

// VectorPathCommand enums
const (
	VectorPathCommandLineType             VectorPathCommandEnum = "vectorPathCommandLine"
	VectorPathCommandCubicBezierCurveType VectorPathCommandEnum = "vectorPathCommandCubicBezierCurve"
)

func unmarshalVectorPathCommand(rawMsg *json.RawMessage) (VectorPathCommand, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch VectorPathCommandEnum(objMap["@type"].(string)) {
	case VectorPathCommandLineType:
		var vectorPathCommandLine VectorPathCommandLine
		err := json.Unmarshal(*rawMsg, &vectorPathCommandLine)
		return &vectorPathCommandLine, err

	case VectorPathCommandCubicBezierCurveType:
		var vectorPathCommandCubicBezierCurve VectorPathCommandCubicBezierCurve
		err := json.Unmarshal(*rawMsg, &vectorPathCommandCubicBezierCurve)
		return &vectorPathCommandCubicBezierCurve, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalVectorPathCommandSlice(rawMsg *json.RawMessage) ([]VectorPathCommand, error) {
	objects := make([]VectorPathCommand, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch VectorPathCommandEnum(objMap["@type"].(string)) {
		case VectorPathCommandLineType:
			var vectorPathCommandLine VectorPathCommandLine
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &vectorPathCommandLine)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &vectorPathCommandLine)
		case VectorPathCommandCubicBezierCurveType:
			var vectorPathCommandCubicBezierCurve VectorPathCommandCubicBezierCurve
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &vectorPathCommandCubicBezierCurve)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &vectorPathCommandCubicBezierCurve)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// BotCommandScope Represents the scope to which bot commands are relevant
type BotCommandScope interface {
	GetBotCommandScopeEnum() BotCommandScopeEnum
}

// BotCommandScopeEnum Alias for abstract BotCommandScope 'Sub-Classes', used as constant-enum here
type BotCommandScopeEnum string

// BotCommandScope enums
const (
	BotCommandScopeDefaultType               BotCommandScopeEnum = "botCommandScopeDefault"
	BotCommandScopeAllPrivateChatsType       BotCommandScopeEnum = "botCommandScopeAllPrivateChats"
	BotCommandScopeAllGroupChatsType         BotCommandScopeEnum = "botCommandScopeAllGroupChats"
	BotCommandScopeAllChatAdministratorsType BotCommandScopeEnum = "botCommandScopeAllChatAdministrators"
	BotCommandScopeChatType                  BotCommandScopeEnum = "botCommandScopeChat"
	BotCommandScopeChatAdministratorsType    BotCommandScopeEnum = "botCommandScopeChatAdministrators"
	BotCommandScopeChatMemberType            BotCommandScopeEnum = "botCommandScopeChatMember"
)

func unmarshalBotCommandScope(rawMsg *json.RawMessage) (BotCommandScope, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch BotCommandScopeEnum(objMap["@type"].(string)) {
	case BotCommandScopeDefaultType:
		var botCommandScopeDefault BotCommandScopeDefault
		err := json.Unmarshal(*rawMsg, &botCommandScopeDefault)
		return &botCommandScopeDefault, err

	case BotCommandScopeAllPrivateChatsType:
		var botCommandScopeAllPrivateChats BotCommandScopeAllPrivateChats
		err := json.Unmarshal(*rawMsg, &botCommandScopeAllPrivateChats)
		return &botCommandScopeAllPrivateChats, err

	case BotCommandScopeAllGroupChatsType:
		var botCommandScopeAllGroupChats BotCommandScopeAllGroupChats
		err := json.Unmarshal(*rawMsg, &botCommandScopeAllGroupChats)
		return &botCommandScopeAllGroupChats, err

	case BotCommandScopeAllChatAdministratorsType:
		var botCommandScopeAllChatAdministrators BotCommandScopeAllChatAdministrators
		err := json.Unmarshal(*rawMsg, &botCommandScopeAllChatAdministrators)
		return &botCommandScopeAllChatAdministrators, err

	case BotCommandScopeChatType:
		var botCommandScopeChat BotCommandScopeChat
		err := json.Unmarshal(*rawMsg, &botCommandScopeChat)
		return &botCommandScopeChat, err

	case BotCommandScopeChatAdministratorsType:
		var botCommandScopeChatAdministrators BotCommandScopeChatAdministrators
		err := json.Unmarshal(*rawMsg, &botCommandScopeChatAdministrators)
		return &botCommandScopeChatAdministrators, err

	case BotCommandScopeChatMemberType:
		var botCommandScopeChatMember BotCommandScopeChatMember
		err := json.Unmarshal(*rawMsg, &botCommandScopeChatMember)
		return &botCommandScopeChatMember, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalBotCommandScopeSlice(rawMsg *json.RawMessage) ([]BotCommandScope, error) {
	objects := make([]BotCommandScope, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch BotCommandScopeEnum(objMap["@type"].(string)) {
		case BotCommandScopeDefaultType:
			var botCommandScopeDefault BotCommandScopeDefault
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &botCommandScopeDefault)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &botCommandScopeDefault)
		case BotCommandScopeAllPrivateChatsType:
			var botCommandScopeAllPrivateChats BotCommandScopeAllPrivateChats
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &botCommandScopeAllPrivateChats)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &botCommandScopeAllPrivateChats)
		case BotCommandScopeAllGroupChatsType:
			var botCommandScopeAllGroupChats BotCommandScopeAllGroupChats
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &botCommandScopeAllGroupChats)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &botCommandScopeAllGroupChats)
		case BotCommandScopeAllChatAdministratorsType:
			var botCommandScopeAllChatAdministrators BotCommandScopeAllChatAdministrators
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &botCommandScopeAllChatAdministrators)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &botCommandScopeAllChatAdministrators)
		case BotCommandScopeChatType:
			var botCommandScopeChat BotCommandScopeChat
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &botCommandScopeChat)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &botCommandScopeChat)
		case BotCommandScopeChatAdministratorsType:
			var botCommandScopeChatAdministrators BotCommandScopeChatAdministrators
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &botCommandScopeChatAdministrators)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &botCommandScopeChatAdministrators)
		case BotCommandScopeChatMemberType:
			var botCommandScopeChatMember BotCommandScopeChatMember
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &botCommandScopeChatMember)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &botCommandScopeChatMember)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// Update Contains notifications about data changes
type Update interface {
	GetUpdateEnum() UpdateEnum
}

// UpdateEnum Alias for abstract Update 'Sub-Classes', used as constant-enum here
type UpdateEnum string

// Update enums
const (
	UpdateAuthorizationStateType             UpdateEnum = "updateAuthorizationState"
	UpdateNewMessageType                     UpdateEnum = "updateNewMessage"
	UpdateMessageSendAcknowledgedType        UpdateEnum = "updateMessageSendAcknowledged"
	UpdateMessageSendSucceededType           UpdateEnum = "updateMessageSendSucceeded"
	UpdateMessageSendFailedType              UpdateEnum = "updateMessageSendFailed"
	UpdateMessageContentType                 UpdateEnum = "updateMessageContent"
	UpdateMessageEditedType                  UpdateEnum = "updateMessageEdited"
	UpdateMessageIsPinnedType                UpdateEnum = "updateMessageIsPinned"
	UpdateMessageInteractionInfoType         UpdateEnum = "updateMessageInteractionInfo"
	UpdateMessageContentOpenedType           UpdateEnum = "updateMessageContentOpened"
	UpdateMessageMentionReadType             UpdateEnum = "updateMessageMentionRead"
	UpdateMessageLiveLocationViewedType      UpdateEnum = "updateMessageLiveLocationViewed"
	UpdateNewChatType                        UpdateEnum = "updateNewChat"
	UpdateChatTitleType                      UpdateEnum = "updateChatTitle"
	UpdateChatPhotoType                      UpdateEnum = "updateChatPhoto"
	UpdateChatPermissionsType                UpdateEnum = "updateChatPermissions"
	UpdateChatLastMessageType                UpdateEnum = "updateChatLastMessage"
	UpdateChatPositionType                   UpdateEnum = "updateChatPosition"
	UpdateChatReadInboxType                  UpdateEnum = "updateChatReadInbox"
	UpdateChatReadOutboxType                 UpdateEnum = "updateChatReadOutbox"
	UpdateChatActionBarType                  UpdateEnum = "updateChatActionBar"
	UpdateChatDraftMessageType               UpdateEnum = "updateChatDraftMessage"
	UpdateChatMessageSenderType              UpdateEnum = "updateChatMessageSender"
	UpdateChatMessageTTLType                 UpdateEnum = "updateChatMessageTtl"
	UpdateChatNotificationSettingsType       UpdateEnum = "updateChatNotificationSettings"
	UpdateChatPendingJoinRequestsType        UpdateEnum = "updateChatPendingJoinRequests"
	UpdateChatReplyMarkupType                UpdateEnum = "updateChatReplyMarkup"
	UpdateChatThemeType                      UpdateEnum = "updateChatTheme"
	UpdateChatUnreadMentionCountType         UpdateEnum = "updateChatUnreadMentionCount"
	UpdateChatVideoChatType                  UpdateEnum = "updateChatVideoChat"
	UpdateChatDefaultDisableNotificationType UpdateEnum = "updateChatDefaultDisableNotification"
	UpdateChatHasProtectedContentType        UpdateEnum = "updateChatHasProtectedContent"
	UpdateChatHasScheduledMessagesType       UpdateEnum = "updateChatHasScheduledMessages"
	UpdateChatIsBlockedType                  UpdateEnum = "updateChatIsBlocked"
	UpdateChatIsMarkedAsUnreadType           UpdateEnum = "updateChatIsMarkedAsUnread"
	UpdateChatFiltersType                    UpdateEnum = "updateChatFilters"
	UpdateChatOnlineMemberCountType          UpdateEnum = "updateChatOnlineMemberCount"
	UpdateScopeNotificationSettingsType      UpdateEnum = "updateScopeNotificationSettings"
	UpdateNotificationType                   UpdateEnum = "updateNotification"
	UpdateNotificationGroupType              UpdateEnum = "updateNotificationGroup"
	UpdateActiveNotificationsType            UpdateEnum = "updateActiveNotifications"
	UpdateHavePendingNotificationsType       UpdateEnum = "updateHavePendingNotifications"
	UpdateDeleteMessagesType                 UpdateEnum = "updateDeleteMessages"
	UpdateChatActionType                     UpdateEnum = "updateChatAction"
	UpdateUserStatusType                     UpdateEnum = "updateUserStatus"
	UpdateUserType                           UpdateEnum = "updateUser"
	UpdateBasicGroupType                     UpdateEnum = "updateBasicGroup"
	UpdateSupergroupType                     UpdateEnum = "updateSupergroup"
	UpdateSecretChatType                     UpdateEnum = "updateSecretChat"
	UpdateUserFullInfoType                   UpdateEnum = "updateUserFullInfo"
	UpdateBasicGroupFullInfoType             UpdateEnum = "updateBasicGroupFullInfo"
	UpdateSupergroupFullInfoType             UpdateEnum = "updateSupergroupFullInfo"
	UpdateServiceNotificationType            UpdateEnum = "updateServiceNotification"
	UpdateFileType                           UpdateEnum = "updateFile"
	UpdateFileGenerationStartType            UpdateEnum = "updateFileGenerationStart"
	UpdateFileGenerationStopType             UpdateEnum = "updateFileGenerationStop"
	UpdateCallType                           UpdateEnum = "updateCall"
	UpdateGroupCallType                      UpdateEnum = "updateGroupCall"
	UpdateGroupCallParticipantType           UpdateEnum = "updateGroupCallParticipant"
	UpdateNewCallSignalingDataType           UpdateEnum = "updateNewCallSignalingData"
	UpdateUserPrivacySettingRulesType        UpdateEnum = "updateUserPrivacySettingRules"
	UpdateUnreadMessageCountType             UpdateEnum = "updateUnreadMessageCount"
	UpdateUnreadChatCountType                UpdateEnum = "updateUnreadChatCount"
	UpdateOptionType                         UpdateEnum = "updateOption"
	UpdateStickerSetType                     UpdateEnum = "updateStickerSet"
	UpdateInstalledStickerSetsType           UpdateEnum = "updateInstalledStickerSets"
	UpdateTrendingStickerSetsType            UpdateEnum = "updateTrendingStickerSets"
	UpdateRecentStickersType                 UpdateEnum = "updateRecentStickers"
	UpdateFavoriteStickersType               UpdateEnum = "updateFavoriteStickers"
	UpdateSavedAnimationsType                UpdateEnum = "updateSavedAnimations"
	UpdateSelectedBackgroundType             UpdateEnum = "updateSelectedBackground"
	UpdateChatThemesType                     UpdateEnum = "updateChatThemes"
	UpdateLanguagePackStringsType            UpdateEnum = "updateLanguagePackStrings"
	UpdateConnectionStateType                UpdateEnum = "updateConnectionState"
	UpdateTermsOfServiceType                 UpdateEnum = "updateTermsOfService"
	UpdateUsersNearbyType                    UpdateEnum = "updateUsersNearby"
	UpdateDiceEmojisType                     UpdateEnum = "updateDiceEmojis"
	UpdateAnimatedEmojiMessageClickedType    UpdateEnum = "updateAnimatedEmojiMessageClicked"
	UpdateAnimationSearchParametersType      UpdateEnum = "updateAnimationSearchParameters"
	UpdateSuggestedActionsType               UpdateEnum = "updateSuggestedActions"
	UpdateNewInlineQueryType                 UpdateEnum = "updateNewInlineQuery"
	UpdateNewChosenInlineResultType          UpdateEnum = "updateNewChosenInlineResult"
	UpdateNewCallbackQueryType               UpdateEnum = "updateNewCallbackQuery"
	UpdateNewInlineCallbackQueryType         UpdateEnum = "updateNewInlineCallbackQuery"
	UpdateNewShippingQueryType               UpdateEnum = "updateNewShippingQuery"
	UpdateNewPreCheckoutQueryType            UpdateEnum = "updateNewPreCheckoutQuery"
	UpdateNewCustomEventType                 UpdateEnum = "updateNewCustomEvent"
	UpdateNewCustomQueryType                 UpdateEnum = "updateNewCustomQuery"
	UpdatePollType                           UpdateEnum = "updatePoll"
	UpdatePollAnswerType                     UpdateEnum = "updatePollAnswer"
	UpdateChatMemberType                     UpdateEnum = "updateChatMember"
	UpdateNewChatJoinRequestType             UpdateEnum = "updateNewChatJoinRequest"
)

func unmarshalUpdate(rawMsg *json.RawMessage) (Update, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch UpdateEnum(objMap["@type"].(string)) {
	case UpdateAuthorizationStateType:
		var updateAuthorizationState UpdateAuthorizationState
		err := json.Unmarshal(*rawMsg, &updateAuthorizationState)
		return &updateAuthorizationState, err

	case UpdateNewMessageType:
		var updateNewMessage UpdateNewMessage
		err := json.Unmarshal(*rawMsg, &updateNewMessage)
		return &updateNewMessage, err

	case UpdateMessageSendAcknowledgedType:
		var updateMessageSendAcknowledged UpdateMessageSendAcknowledged
		err := json.Unmarshal(*rawMsg, &updateMessageSendAcknowledged)
		return &updateMessageSendAcknowledged, err

	case UpdateMessageSendSucceededType:
		var updateMessageSendSucceeded UpdateMessageSendSucceeded
		err := json.Unmarshal(*rawMsg, &updateMessageSendSucceeded)
		return &updateMessageSendSucceeded, err

	case UpdateMessageSendFailedType:
		var updateMessageSendFailed UpdateMessageSendFailed
		err := json.Unmarshal(*rawMsg, &updateMessageSendFailed)
		return &updateMessageSendFailed, err

	case UpdateMessageContentType:
		var updateMessageContent UpdateMessageContent
		err := json.Unmarshal(*rawMsg, &updateMessageContent)
		return &updateMessageContent, err

	case UpdateMessageEditedType:
		var updateMessageEdited UpdateMessageEdited
		err := json.Unmarshal(*rawMsg, &updateMessageEdited)
		return &updateMessageEdited, err

	case UpdateMessageIsPinnedType:
		var updateMessageIsPinned UpdateMessageIsPinned
		err := json.Unmarshal(*rawMsg, &updateMessageIsPinned)
		return &updateMessageIsPinned, err

	case UpdateMessageInteractionInfoType:
		var updateMessageInteractionInfo UpdateMessageInteractionInfo
		err := json.Unmarshal(*rawMsg, &updateMessageInteractionInfo)
		return &updateMessageInteractionInfo, err

	case UpdateMessageContentOpenedType:
		var updateMessageContentOpened UpdateMessageContentOpened
		err := json.Unmarshal(*rawMsg, &updateMessageContentOpened)
		return &updateMessageContentOpened, err

	case UpdateMessageMentionReadType:
		var updateMessageMentionRead UpdateMessageMentionRead
		err := json.Unmarshal(*rawMsg, &updateMessageMentionRead)
		return &updateMessageMentionRead, err

	case UpdateMessageLiveLocationViewedType:
		var updateMessageLiveLocationViewed UpdateMessageLiveLocationViewed
		err := json.Unmarshal(*rawMsg, &updateMessageLiveLocationViewed)
		return &updateMessageLiveLocationViewed, err

	case UpdateNewChatType:
		var updateNewChat UpdateNewChat
		err := json.Unmarshal(*rawMsg, &updateNewChat)
		return &updateNewChat, err

	case UpdateChatTitleType:
		var updateChatTitle UpdateChatTitle
		err := json.Unmarshal(*rawMsg, &updateChatTitle)
		return &updateChatTitle, err

	case UpdateChatPhotoType:
		var updateChatPhoto UpdateChatPhoto
		err := json.Unmarshal(*rawMsg, &updateChatPhoto)
		return &updateChatPhoto, err

	case UpdateChatPermissionsType:
		var updateChatPermissions UpdateChatPermissions
		err := json.Unmarshal(*rawMsg, &updateChatPermissions)
		return &updateChatPermissions, err

	case UpdateChatLastMessageType:
		var updateChatLastMessage UpdateChatLastMessage
		err := json.Unmarshal(*rawMsg, &updateChatLastMessage)
		return &updateChatLastMessage, err

	case UpdateChatPositionType:
		var updateChatPosition UpdateChatPosition
		err := json.Unmarshal(*rawMsg, &updateChatPosition)
		return &updateChatPosition, err

	case UpdateChatReadInboxType:
		var updateChatReadInbox UpdateChatReadInbox
		err := json.Unmarshal(*rawMsg, &updateChatReadInbox)
		return &updateChatReadInbox, err

	case UpdateChatReadOutboxType:
		var updateChatReadOutbox UpdateChatReadOutbox
		err := json.Unmarshal(*rawMsg, &updateChatReadOutbox)
		return &updateChatReadOutbox, err

	case UpdateChatActionBarType:
		var updateChatActionBar UpdateChatActionBar
		err := json.Unmarshal(*rawMsg, &updateChatActionBar)
		return &updateChatActionBar, err

	case UpdateChatDraftMessageType:
		var updateChatDraftMessage UpdateChatDraftMessage
		err := json.Unmarshal(*rawMsg, &updateChatDraftMessage)
		return &updateChatDraftMessage, err

	case UpdateChatMessageSenderType:
		var updateChatMessageSender UpdateChatMessageSender
		err := json.Unmarshal(*rawMsg, &updateChatMessageSender)
		return &updateChatMessageSender, err

	case UpdateChatMessageTTLType:
		var updateChatMessageTTL UpdateChatMessageTTL
		err := json.Unmarshal(*rawMsg, &updateChatMessageTTL)
		return &updateChatMessageTTL, err

	case UpdateChatNotificationSettingsType:
		var updateChatNotificationSettings UpdateChatNotificationSettings
		err := json.Unmarshal(*rawMsg, &updateChatNotificationSettings)
		return &updateChatNotificationSettings, err

	case UpdateChatPendingJoinRequestsType:
		var updateChatPendingJoinRequests UpdateChatPendingJoinRequests
		err := json.Unmarshal(*rawMsg, &updateChatPendingJoinRequests)
		return &updateChatPendingJoinRequests, err

	case UpdateChatReplyMarkupType:
		var updateChatReplyMarkup UpdateChatReplyMarkup
		err := json.Unmarshal(*rawMsg, &updateChatReplyMarkup)
		return &updateChatReplyMarkup, err

	case UpdateChatThemeType:
		var updateChatTheme UpdateChatTheme
		err := json.Unmarshal(*rawMsg, &updateChatTheme)
		return &updateChatTheme, err

	case UpdateChatUnreadMentionCountType:
		var updateChatUnreadMentionCount UpdateChatUnreadMentionCount
		err := json.Unmarshal(*rawMsg, &updateChatUnreadMentionCount)
		return &updateChatUnreadMentionCount, err

	case UpdateChatVideoChatType:
		var updateChatVideoChat UpdateChatVideoChat
		err := json.Unmarshal(*rawMsg, &updateChatVideoChat)
		return &updateChatVideoChat, err

	case UpdateChatDefaultDisableNotificationType:
		var updateChatDefaultDisableNotification UpdateChatDefaultDisableNotification
		err := json.Unmarshal(*rawMsg, &updateChatDefaultDisableNotification)
		return &updateChatDefaultDisableNotification, err

	case UpdateChatHasProtectedContentType:
		var updateChatHasProtectedContent UpdateChatHasProtectedContent
		err := json.Unmarshal(*rawMsg, &updateChatHasProtectedContent)
		return &updateChatHasProtectedContent, err

	case UpdateChatHasScheduledMessagesType:
		var updateChatHasScheduledMessages UpdateChatHasScheduledMessages
		err := json.Unmarshal(*rawMsg, &updateChatHasScheduledMessages)
		return &updateChatHasScheduledMessages, err

	case UpdateChatIsBlockedType:
		var updateChatIsBlocked UpdateChatIsBlocked
		err := json.Unmarshal(*rawMsg, &updateChatIsBlocked)
		return &updateChatIsBlocked, err

	case UpdateChatIsMarkedAsUnreadType:
		var updateChatIsMarkedAsUnread UpdateChatIsMarkedAsUnread
		err := json.Unmarshal(*rawMsg, &updateChatIsMarkedAsUnread)
		return &updateChatIsMarkedAsUnread, err

	case UpdateChatFiltersType:
		var updateChatFilters UpdateChatFilters
		err := json.Unmarshal(*rawMsg, &updateChatFilters)
		return &updateChatFilters, err

	case UpdateChatOnlineMemberCountType:
		var updateChatOnlineMemberCount UpdateChatOnlineMemberCount
		err := json.Unmarshal(*rawMsg, &updateChatOnlineMemberCount)
		return &updateChatOnlineMemberCount, err

	case UpdateScopeNotificationSettingsType:
		var updateScopeNotificationSettings UpdateScopeNotificationSettings
		err := json.Unmarshal(*rawMsg, &updateScopeNotificationSettings)
		return &updateScopeNotificationSettings, err

	case UpdateNotificationType:
		var updateNotification UpdateNotification
		err := json.Unmarshal(*rawMsg, &updateNotification)
		return &updateNotification, err

	case UpdateNotificationGroupType:
		var updateNotificationGroup UpdateNotificationGroup
		err := json.Unmarshal(*rawMsg, &updateNotificationGroup)
		return &updateNotificationGroup, err

	case UpdateActiveNotificationsType:
		var updateActiveNotifications UpdateActiveNotifications
		err := json.Unmarshal(*rawMsg, &updateActiveNotifications)
		return &updateActiveNotifications, err

	case UpdateHavePendingNotificationsType:
		var updateHavePendingNotifications UpdateHavePendingNotifications
		err := json.Unmarshal(*rawMsg, &updateHavePendingNotifications)
		return &updateHavePendingNotifications, err

	case UpdateDeleteMessagesType:
		var updateDeleteMessages UpdateDeleteMessages
		err := json.Unmarshal(*rawMsg, &updateDeleteMessages)
		return &updateDeleteMessages, err

	case UpdateChatActionType:
		var updateChatAction UpdateChatAction
		err := json.Unmarshal(*rawMsg, &updateChatAction)
		return &updateChatAction, err

	case UpdateUserStatusType:
		var updateUserStatus UpdateUserStatus
		err := json.Unmarshal(*rawMsg, &updateUserStatus)
		return &updateUserStatus, err

	case UpdateUserType:
		var updateUser UpdateUser
		err := json.Unmarshal(*rawMsg, &updateUser)
		return &updateUser, err

	case UpdateBasicGroupType:
		var updateBasicGroup UpdateBasicGroup
		err := json.Unmarshal(*rawMsg, &updateBasicGroup)
		return &updateBasicGroup, err

	case UpdateSupergroupType:
		var updateSupergroup UpdateSupergroup
		err := json.Unmarshal(*rawMsg, &updateSupergroup)
		return &updateSupergroup, err

	case UpdateSecretChatType:
		var updateSecretChat UpdateSecretChat
		err := json.Unmarshal(*rawMsg, &updateSecretChat)
		return &updateSecretChat, err

	case UpdateUserFullInfoType:
		var updateUserFullInfo UpdateUserFullInfo
		err := json.Unmarshal(*rawMsg, &updateUserFullInfo)
		return &updateUserFullInfo, err

	case UpdateBasicGroupFullInfoType:
		var updateBasicGroupFullInfo UpdateBasicGroupFullInfo
		err := json.Unmarshal(*rawMsg, &updateBasicGroupFullInfo)
		return &updateBasicGroupFullInfo, err

	case UpdateSupergroupFullInfoType:
		var updateSupergroupFullInfo UpdateSupergroupFullInfo
		err := json.Unmarshal(*rawMsg, &updateSupergroupFullInfo)
		return &updateSupergroupFullInfo, err

	case UpdateServiceNotificationType:
		var updateServiceNotification UpdateServiceNotification
		err := json.Unmarshal(*rawMsg, &updateServiceNotification)
		return &updateServiceNotification, err

	case UpdateFileType:
		var updateFile UpdateFile
		err := json.Unmarshal(*rawMsg, &updateFile)
		return &updateFile, err

	case UpdateFileGenerationStartType:
		var updateFileGenerationStart UpdateFileGenerationStart
		err := json.Unmarshal(*rawMsg, &updateFileGenerationStart)
		return &updateFileGenerationStart, err

	case UpdateFileGenerationStopType:
		var updateFileGenerationStop UpdateFileGenerationStop
		err := json.Unmarshal(*rawMsg, &updateFileGenerationStop)
		return &updateFileGenerationStop, err

	case UpdateCallType:
		var updateCall UpdateCall
		err := json.Unmarshal(*rawMsg, &updateCall)
		return &updateCall, err

	case UpdateGroupCallType:
		var updateGroupCall UpdateGroupCall
		err := json.Unmarshal(*rawMsg, &updateGroupCall)
		return &updateGroupCall, err

	case UpdateGroupCallParticipantType:
		var updateGroupCallParticipant UpdateGroupCallParticipant
		err := json.Unmarshal(*rawMsg, &updateGroupCallParticipant)
		return &updateGroupCallParticipant, err

	case UpdateNewCallSignalingDataType:
		var updateNewCallSignalingData UpdateNewCallSignalingData
		err := json.Unmarshal(*rawMsg, &updateNewCallSignalingData)
		return &updateNewCallSignalingData, err

	case UpdateUserPrivacySettingRulesType:
		var updateUserPrivacySettingRules UpdateUserPrivacySettingRules
		err := json.Unmarshal(*rawMsg, &updateUserPrivacySettingRules)
		return &updateUserPrivacySettingRules, err

	case UpdateUnreadMessageCountType:
		var updateUnreadMessageCount UpdateUnreadMessageCount
		err := json.Unmarshal(*rawMsg, &updateUnreadMessageCount)
		return &updateUnreadMessageCount, err

	case UpdateUnreadChatCountType:
		var updateUnreadChatCount UpdateUnreadChatCount
		err := json.Unmarshal(*rawMsg, &updateUnreadChatCount)
		return &updateUnreadChatCount, err

	case UpdateOptionType:
		var updateOption UpdateOption
		err := json.Unmarshal(*rawMsg, &updateOption)
		return &updateOption, err

	case UpdateStickerSetType:
		var updateStickerSet UpdateStickerSet
		err := json.Unmarshal(*rawMsg, &updateStickerSet)
		return &updateStickerSet, err

	case UpdateInstalledStickerSetsType:
		var updateInstalledStickerSets UpdateInstalledStickerSets
		err := json.Unmarshal(*rawMsg, &updateInstalledStickerSets)
		return &updateInstalledStickerSets, err

	case UpdateTrendingStickerSetsType:
		var updateTrendingStickerSets UpdateTrendingStickerSets
		err := json.Unmarshal(*rawMsg, &updateTrendingStickerSets)
		return &updateTrendingStickerSets, err

	case UpdateRecentStickersType:
		var updateRecentStickers UpdateRecentStickers
		err := json.Unmarshal(*rawMsg, &updateRecentStickers)
		return &updateRecentStickers, err

	case UpdateFavoriteStickersType:
		var updateFavoriteStickers UpdateFavoriteStickers
		err := json.Unmarshal(*rawMsg, &updateFavoriteStickers)
		return &updateFavoriteStickers, err

	case UpdateSavedAnimationsType:
		var updateSavedAnimations UpdateSavedAnimations
		err := json.Unmarshal(*rawMsg, &updateSavedAnimations)
		return &updateSavedAnimations, err

	case UpdateSelectedBackgroundType:
		var updateSelectedBackground UpdateSelectedBackground
		err := json.Unmarshal(*rawMsg, &updateSelectedBackground)
		return &updateSelectedBackground, err

	case UpdateChatThemesType:
		var updateChatThemes UpdateChatThemes
		err := json.Unmarshal(*rawMsg, &updateChatThemes)
		return &updateChatThemes, err

	case UpdateLanguagePackStringsType:
		var updateLanguagePackStrings UpdateLanguagePackStrings
		err := json.Unmarshal(*rawMsg, &updateLanguagePackStrings)
		return &updateLanguagePackStrings, err

	case UpdateConnectionStateType:
		var updateConnectionState UpdateConnectionState
		err := json.Unmarshal(*rawMsg, &updateConnectionState)
		return &updateConnectionState, err

	case UpdateTermsOfServiceType:
		var updateTermsOfService UpdateTermsOfService
		err := json.Unmarshal(*rawMsg, &updateTermsOfService)
		return &updateTermsOfService, err

	case UpdateUsersNearbyType:
		var updateUsersNearby UpdateUsersNearby
		err := json.Unmarshal(*rawMsg, &updateUsersNearby)
		return &updateUsersNearby, err

	case UpdateDiceEmojisType:
		var updateDiceEmojis UpdateDiceEmojis
		err := json.Unmarshal(*rawMsg, &updateDiceEmojis)
		return &updateDiceEmojis, err

	case UpdateAnimatedEmojiMessageClickedType:
		var updateAnimatedEmojiMessageClicked UpdateAnimatedEmojiMessageClicked
		err := json.Unmarshal(*rawMsg, &updateAnimatedEmojiMessageClicked)
		return &updateAnimatedEmojiMessageClicked, err

	case UpdateAnimationSearchParametersType:
		var updateAnimationSearchParameters UpdateAnimationSearchParameters
		err := json.Unmarshal(*rawMsg, &updateAnimationSearchParameters)
		return &updateAnimationSearchParameters, err

	case UpdateSuggestedActionsType:
		var updateSuggestedActions UpdateSuggestedActions
		err := json.Unmarshal(*rawMsg, &updateSuggestedActions)
		return &updateSuggestedActions, err

	case UpdateNewInlineQueryType:
		var updateNewInlineQuery UpdateNewInlineQuery
		err := json.Unmarshal(*rawMsg, &updateNewInlineQuery)
		return &updateNewInlineQuery, err

	case UpdateNewChosenInlineResultType:
		var updateNewChosenInlineResult UpdateNewChosenInlineResult
		err := json.Unmarshal(*rawMsg, &updateNewChosenInlineResult)
		return &updateNewChosenInlineResult, err

	case UpdateNewCallbackQueryType:
		var updateNewCallbackQuery UpdateNewCallbackQuery
		err := json.Unmarshal(*rawMsg, &updateNewCallbackQuery)
		return &updateNewCallbackQuery, err

	case UpdateNewInlineCallbackQueryType:
		var updateNewInlineCallbackQuery UpdateNewInlineCallbackQuery
		err := json.Unmarshal(*rawMsg, &updateNewInlineCallbackQuery)
		return &updateNewInlineCallbackQuery, err

	case UpdateNewShippingQueryType:
		var updateNewShippingQuery UpdateNewShippingQuery
		err := json.Unmarshal(*rawMsg, &updateNewShippingQuery)
		return &updateNewShippingQuery, err

	case UpdateNewPreCheckoutQueryType:
		var updateNewPreCheckoutQuery UpdateNewPreCheckoutQuery
		err := json.Unmarshal(*rawMsg, &updateNewPreCheckoutQuery)
		return &updateNewPreCheckoutQuery, err

	case UpdateNewCustomEventType:
		var updateNewCustomEvent UpdateNewCustomEvent
		err := json.Unmarshal(*rawMsg, &updateNewCustomEvent)
		return &updateNewCustomEvent, err

	case UpdateNewCustomQueryType:
		var updateNewCustomQuery UpdateNewCustomQuery
		err := json.Unmarshal(*rawMsg, &updateNewCustomQuery)
		return &updateNewCustomQuery, err

	case UpdatePollType:
		var updatePoll UpdatePoll
		err := json.Unmarshal(*rawMsg, &updatePoll)
		return &updatePoll, err

	case UpdatePollAnswerType:
		var updatePollAnswer UpdatePollAnswer
		err := json.Unmarshal(*rawMsg, &updatePollAnswer)
		return &updatePollAnswer, err

	case UpdateChatMemberType:
		var updateChatMember UpdateChatMember
		err := json.Unmarshal(*rawMsg, &updateChatMember)
		return &updateChatMember, err

	case UpdateNewChatJoinRequestType:
		var updateNewChatJoinRequest UpdateNewChatJoinRequest
		err := json.Unmarshal(*rawMsg, &updateNewChatJoinRequest)
		return &updateNewChatJoinRequest, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalUpdateSlice(rawMsg *json.RawMessage) ([]Update, error) {
	objects := make([]Update, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch UpdateEnum(objMap["@type"].(string)) {
		case UpdateAuthorizationStateType:
			var updateAuthorizationState UpdateAuthorizationState
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateAuthorizationState)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateAuthorizationState)
		case UpdateNewMessageType:
			var updateNewMessage UpdateNewMessage
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateNewMessage)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateNewMessage)
		case UpdateMessageSendAcknowledgedType:
			var updateMessageSendAcknowledged UpdateMessageSendAcknowledged
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateMessageSendAcknowledged)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateMessageSendAcknowledged)
		case UpdateMessageSendSucceededType:
			var updateMessageSendSucceeded UpdateMessageSendSucceeded
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateMessageSendSucceeded)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateMessageSendSucceeded)
		case UpdateMessageSendFailedType:
			var updateMessageSendFailed UpdateMessageSendFailed
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateMessageSendFailed)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateMessageSendFailed)
		case UpdateMessageContentType:
			var updateMessageContent UpdateMessageContent
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateMessageContent)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateMessageContent)
		case UpdateMessageEditedType:
			var updateMessageEdited UpdateMessageEdited
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateMessageEdited)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateMessageEdited)
		case UpdateMessageIsPinnedType:
			var updateMessageIsPinned UpdateMessageIsPinned
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateMessageIsPinned)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateMessageIsPinned)
		case UpdateMessageInteractionInfoType:
			var updateMessageInteractionInfo UpdateMessageInteractionInfo
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateMessageInteractionInfo)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateMessageInteractionInfo)
		case UpdateMessageContentOpenedType:
			var updateMessageContentOpened UpdateMessageContentOpened
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateMessageContentOpened)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateMessageContentOpened)
		case UpdateMessageMentionReadType:
			var updateMessageMentionRead UpdateMessageMentionRead
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateMessageMentionRead)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateMessageMentionRead)
		case UpdateMessageLiveLocationViewedType:
			var updateMessageLiveLocationViewed UpdateMessageLiveLocationViewed
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateMessageLiveLocationViewed)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateMessageLiveLocationViewed)
		case UpdateNewChatType:
			var updateNewChat UpdateNewChat
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateNewChat)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateNewChat)
		case UpdateChatTitleType:
			var updateChatTitle UpdateChatTitle
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateChatTitle)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateChatTitle)
		case UpdateChatPhotoType:
			var updateChatPhoto UpdateChatPhoto
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateChatPhoto)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateChatPhoto)
		case UpdateChatPermissionsType:
			var updateChatPermissions UpdateChatPermissions
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateChatPermissions)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateChatPermissions)
		case UpdateChatLastMessageType:
			var updateChatLastMessage UpdateChatLastMessage
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateChatLastMessage)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateChatLastMessage)
		case UpdateChatPositionType:
			var updateChatPosition UpdateChatPosition
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateChatPosition)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateChatPosition)
		case UpdateChatReadInboxType:
			var updateChatReadInbox UpdateChatReadInbox
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateChatReadInbox)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateChatReadInbox)
		case UpdateChatReadOutboxType:
			var updateChatReadOutbox UpdateChatReadOutbox
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateChatReadOutbox)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateChatReadOutbox)
		case UpdateChatActionBarType:
			var updateChatActionBar UpdateChatActionBar
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateChatActionBar)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateChatActionBar)
		case UpdateChatDraftMessageType:
			var updateChatDraftMessage UpdateChatDraftMessage
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateChatDraftMessage)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateChatDraftMessage)
		case UpdateChatMessageSenderType:
			var updateChatMessageSender UpdateChatMessageSender
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateChatMessageSender)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateChatMessageSender)
		case UpdateChatMessageTTLType:
			var updateChatMessageTTL UpdateChatMessageTTL
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateChatMessageTTL)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateChatMessageTTL)
		case UpdateChatNotificationSettingsType:
			var updateChatNotificationSettings UpdateChatNotificationSettings
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateChatNotificationSettings)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateChatNotificationSettings)
		case UpdateChatPendingJoinRequestsType:
			var updateChatPendingJoinRequests UpdateChatPendingJoinRequests
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateChatPendingJoinRequests)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateChatPendingJoinRequests)
		case UpdateChatReplyMarkupType:
			var updateChatReplyMarkup UpdateChatReplyMarkup
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateChatReplyMarkup)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateChatReplyMarkup)
		case UpdateChatThemeType:
			var updateChatTheme UpdateChatTheme
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateChatTheme)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateChatTheme)
		case UpdateChatUnreadMentionCountType:
			var updateChatUnreadMentionCount UpdateChatUnreadMentionCount
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateChatUnreadMentionCount)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateChatUnreadMentionCount)
		case UpdateChatVideoChatType:
			var updateChatVideoChat UpdateChatVideoChat
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateChatVideoChat)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateChatVideoChat)
		case UpdateChatDefaultDisableNotificationType:
			var updateChatDefaultDisableNotification UpdateChatDefaultDisableNotification
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateChatDefaultDisableNotification)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateChatDefaultDisableNotification)
		case UpdateChatHasProtectedContentType:
			var updateChatHasProtectedContent UpdateChatHasProtectedContent
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateChatHasProtectedContent)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateChatHasProtectedContent)
		case UpdateChatHasScheduledMessagesType:
			var updateChatHasScheduledMessages UpdateChatHasScheduledMessages
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateChatHasScheduledMessages)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateChatHasScheduledMessages)
		case UpdateChatIsBlockedType:
			var updateChatIsBlocked UpdateChatIsBlocked
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateChatIsBlocked)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateChatIsBlocked)
		case UpdateChatIsMarkedAsUnreadType:
			var updateChatIsMarkedAsUnread UpdateChatIsMarkedAsUnread
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateChatIsMarkedAsUnread)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateChatIsMarkedAsUnread)
		case UpdateChatFiltersType:
			var updateChatFilters UpdateChatFilters
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateChatFilters)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateChatFilters)
		case UpdateChatOnlineMemberCountType:
			var updateChatOnlineMemberCount UpdateChatOnlineMemberCount
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateChatOnlineMemberCount)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateChatOnlineMemberCount)
		case UpdateScopeNotificationSettingsType:
			var updateScopeNotificationSettings UpdateScopeNotificationSettings
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateScopeNotificationSettings)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateScopeNotificationSettings)
		case UpdateNotificationType:
			var updateNotification UpdateNotification
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateNotification)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateNotification)
		case UpdateNotificationGroupType:
			var updateNotificationGroup UpdateNotificationGroup
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateNotificationGroup)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateNotificationGroup)
		case UpdateActiveNotificationsType:
			var updateActiveNotifications UpdateActiveNotifications
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateActiveNotifications)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateActiveNotifications)
		case UpdateHavePendingNotificationsType:
			var updateHavePendingNotifications UpdateHavePendingNotifications
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateHavePendingNotifications)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateHavePendingNotifications)
		case UpdateDeleteMessagesType:
			var updateDeleteMessages UpdateDeleteMessages
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateDeleteMessages)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateDeleteMessages)
		case UpdateChatActionType:
			var updateChatAction UpdateChatAction
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateChatAction)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateChatAction)
		case UpdateUserStatusType:
			var updateUserStatus UpdateUserStatus
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateUserStatus)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateUserStatus)
		case UpdateUserType:
			var updateUser UpdateUser
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateUser)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateUser)
		case UpdateBasicGroupType:
			var updateBasicGroup UpdateBasicGroup
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateBasicGroup)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateBasicGroup)
		case UpdateSupergroupType:
			var updateSupergroup UpdateSupergroup
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateSupergroup)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateSupergroup)
		case UpdateSecretChatType:
			var updateSecretChat UpdateSecretChat
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateSecretChat)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateSecretChat)
		case UpdateUserFullInfoType:
			var updateUserFullInfo UpdateUserFullInfo
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateUserFullInfo)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateUserFullInfo)
		case UpdateBasicGroupFullInfoType:
			var updateBasicGroupFullInfo UpdateBasicGroupFullInfo
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateBasicGroupFullInfo)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateBasicGroupFullInfo)
		case UpdateSupergroupFullInfoType:
			var updateSupergroupFullInfo UpdateSupergroupFullInfo
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateSupergroupFullInfo)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateSupergroupFullInfo)
		case UpdateServiceNotificationType:
			var updateServiceNotification UpdateServiceNotification
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateServiceNotification)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateServiceNotification)
		case UpdateFileType:
			var updateFile UpdateFile
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateFile)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateFile)
		case UpdateFileGenerationStartType:
			var updateFileGenerationStart UpdateFileGenerationStart
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateFileGenerationStart)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateFileGenerationStart)
		case UpdateFileGenerationStopType:
			var updateFileGenerationStop UpdateFileGenerationStop
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateFileGenerationStop)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateFileGenerationStop)
		case UpdateCallType:
			var updateCall UpdateCall
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateCall)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateCall)
		case UpdateGroupCallType:
			var updateGroupCall UpdateGroupCall
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateGroupCall)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateGroupCall)
		case UpdateGroupCallParticipantType:
			var updateGroupCallParticipant UpdateGroupCallParticipant
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateGroupCallParticipant)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateGroupCallParticipant)
		case UpdateNewCallSignalingDataType:
			var updateNewCallSignalingData UpdateNewCallSignalingData
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateNewCallSignalingData)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateNewCallSignalingData)
		case UpdateUserPrivacySettingRulesType:
			var updateUserPrivacySettingRules UpdateUserPrivacySettingRules
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateUserPrivacySettingRules)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateUserPrivacySettingRules)
		case UpdateUnreadMessageCountType:
			var updateUnreadMessageCount UpdateUnreadMessageCount
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateUnreadMessageCount)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateUnreadMessageCount)
		case UpdateUnreadChatCountType:
			var updateUnreadChatCount UpdateUnreadChatCount
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateUnreadChatCount)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateUnreadChatCount)
		case UpdateOptionType:
			var updateOption UpdateOption
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateOption)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateOption)
		case UpdateStickerSetType:
			var updateStickerSet UpdateStickerSet
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateStickerSet)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateStickerSet)
		case UpdateInstalledStickerSetsType:
			var updateInstalledStickerSets UpdateInstalledStickerSets
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateInstalledStickerSets)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateInstalledStickerSets)
		case UpdateTrendingStickerSetsType:
			var updateTrendingStickerSets UpdateTrendingStickerSets
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateTrendingStickerSets)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateTrendingStickerSets)
		case UpdateRecentStickersType:
			var updateRecentStickers UpdateRecentStickers
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateRecentStickers)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateRecentStickers)
		case UpdateFavoriteStickersType:
			var updateFavoriteStickers UpdateFavoriteStickers
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateFavoriteStickers)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateFavoriteStickers)
		case UpdateSavedAnimationsType:
			var updateSavedAnimations UpdateSavedAnimations
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateSavedAnimations)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateSavedAnimations)
		case UpdateSelectedBackgroundType:
			var updateSelectedBackground UpdateSelectedBackground
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateSelectedBackground)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateSelectedBackground)
		case UpdateChatThemesType:
			var updateChatThemes UpdateChatThemes
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateChatThemes)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateChatThemes)
		case UpdateLanguagePackStringsType:
			var updateLanguagePackStrings UpdateLanguagePackStrings
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateLanguagePackStrings)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateLanguagePackStrings)
		case UpdateConnectionStateType:
			var updateConnectionState UpdateConnectionState
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateConnectionState)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateConnectionState)
		case UpdateTermsOfServiceType:
			var updateTermsOfService UpdateTermsOfService
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateTermsOfService)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateTermsOfService)
		case UpdateUsersNearbyType:
			var updateUsersNearby UpdateUsersNearby
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateUsersNearby)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateUsersNearby)
		case UpdateDiceEmojisType:
			var updateDiceEmojis UpdateDiceEmojis
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateDiceEmojis)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateDiceEmojis)
		case UpdateAnimatedEmojiMessageClickedType:
			var updateAnimatedEmojiMessageClicked UpdateAnimatedEmojiMessageClicked
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateAnimatedEmojiMessageClicked)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateAnimatedEmojiMessageClicked)
		case UpdateAnimationSearchParametersType:
			var updateAnimationSearchParameters UpdateAnimationSearchParameters
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateAnimationSearchParameters)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateAnimationSearchParameters)
		case UpdateSuggestedActionsType:
			var updateSuggestedActions UpdateSuggestedActions
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateSuggestedActions)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateSuggestedActions)
		case UpdateNewInlineQueryType:
			var updateNewInlineQuery UpdateNewInlineQuery
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateNewInlineQuery)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateNewInlineQuery)
		case UpdateNewChosenInlineResultType:
			var updateNewChosenInlineResult UpdateNewChosenInlineResult
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateNewChosenInlineResult)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateNewChosenInlineResult)
		case UpdateNewCallbackQueryType:
			var updateNewCallbackQuery UpdateNewCallbackQuery
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateNewCallbackQuery)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateNewCallbackQuery)
		case UpdateNewInlineCallbackQueryType:
			var updateNewInlineCallbackQuery UpdateNewInlineCallbackQuery
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateNewInlineCallbackQuery)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateNewInlineCallbackQuery)
		case UpdateNewShippingQueryType:
			var updateNewShippingQuery UpdateNewShippingQuery
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateNewShippingQuery)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateNewShippingQuery)
		case UpdateNewPreCheckoutQueryType:
			var updateNewPreCheckoutQuery UpdateNewPreCheckoutQuery
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateNewPreCheckoutQuery)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateNewPreCheckoutQuery)
		case UpdateNewCustomEventType:
			var updateNewCustomEvent UpdateNewCustomEvent
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateNewCustomEvent)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateNewCustomEvent)
		case UpdateNewCustomQueryType:
			var updateNewCustomQuery UpdateNewCustomQuery
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateNewCustomQuery)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateNewCustomQuery)
		case UpdatePollType:
			var updatePoll UpdatePoll
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updatePoll)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updatePoll)
		case UpdatePollAnswerType:
			var updatePollAnswer UpdatePollAnswer
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updatePollAnswer)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updatePollAnswer)
		case UpdateChatMemberType:
			var updateChatMember UpdateChatMember
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateChatMember)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateChatMember)
		case UpdateNewChatJoinRequestType:
			var updateNewChatJoinRequest UpdateNewChatJoinRequest
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &updateNewChatJoinRequest)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &updateNewChatJoinRequest)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}

// LogStream Describes a stream to which TDLib internal log is written
type LogStream interface {
	GetLogStreamEnum() LogStreamEnum
}

// LogStreamEnum Alias for abstract LogStream 'Sub-Classes', used as constant-enum here
type LogStreamEnum string

// LogStream enums
const (
	LogStreamDefaultType LogStreamEnum = "logStreamDefault"
	LogStreamFileType    LogStreamEnum = "logStreamFile"
	LogStreamEmptyType   LogStreamEnum = "logStreamEmpty"
)

func unmarshalLogStream(rawMsg *json.RawMessage) (LogStream, error) {

	if rawMsg == nil {
		return nil, nil
	}
	var objMap map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objMap)
	if err != nil {
		return nil, err
	}

	switch LogStreamEnum(objMap["@type"].(string)) {
	case LogStreamDefaultType:
		var logStreamDefault LogStreamDefault
		err := json.Unmarshal(*rawMsg, &logStreamDefault)
		return &logStreamDefault, err

	case LogStreamFileType:
		var logStreamFile LogStreamFile
		err := json.Unmarshal(*rawMsg, &logStreamFile)
		return &logStreamFile, err

	case LogStreamEmptyType:
		var logStreamEmpty LogStreamEmpty
		err := json.Unmarshal(*rawMsg, &logStreamEmpty)
		return &logStreamEmpty, err

	default:
		return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
	}
}

func unmarshalLogStreamSlice(rawMsg *json.RawMessage) ([]LogStream, error) {
	objects := make([]LogStream, 0)
	if rawMsg == nil {
		return nil, nil
	}
	var objsMap []map[string]interface{}
	err := json.Unmarshal(*rawMsg, &objsMap)
	if err != nil {
		return nil, err
	}

	for _, objMap := range objsMap {
		switch LogStreamEnum(objMap["@type"].(string)) {
		case LogStreamDefaultType:
			var logStreamDefault LogStreamDefault
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &logStreamDefault)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &logStreamDefault)
		case LogStreamFileType:
			var logStreamFile LogStreamFile
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &logStreamFile)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &logStreamFile)
		case LogStreamEmptyType:
			var logStreamEmpty LogStreamEmpty
			obj, err := json.Marshal(objMap)
			if err != nil {
				return nil, err
			}

			err = json.Unmarshal(obj, &logStreamEmpty)
			if err != nil {
				return nil, err
			}

			objects = append(objects, &logStreamEmpty)

		default:
			return nil, fmt.Errorf("Error UnMarshaling, unknown type:" + objMap["@type"].(string))
		}
	}

	return objects, nil
}
