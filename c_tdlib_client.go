// AUTOGENERATED - DO NOT EDIT

package tdlib

//#cgo linux CFLAGS: -I/usr/local/include
//#cgo darwin CFLAGS: -I/usr/local/include
//#cgo windows CFLAGS: -IC:/src/td -IC:/src/td/build
//#cgo linux LDFLAGS: -L/usr/local/lib -ltdjson_static -ltdjson_private -ltdclient -ltdcore -ltdapi -ltdactor -ltddb -ltdsqlite -ltdnet -ltdutils -lstdc++ -lssl -lcrypto -ldl -lz -lm
//#cgo darwin LDFLAGS: -L/usr/local/lib -L/usr/local/opt/openssl/lib -ltdjson_static -ltdjson_private -ltdclient -ltdcore -ltdapi -ltdactor -ltddb -ltdsqlite -ltdnet -ltdutils -lc++ -lssl -lcrypto -ldl -lz -lm
//#cgo windows LDFLAGS: -LC:/src/td/build/Debug -ltdjson
//#include <stdlib.h>
//#include <td/telegram/td_json_client.h>
//#include <td/telegram/td_log.h>
import "C"

import (
	"encoding/json"
	"unsafe"
)

//go:generate mockgen -source c_tdlib_client.go -destination=./mocks/c_tdlib_client.go

// Contract wrapper over tdlib client in C language
type tdlibClient interface {
	send(jsonQuery interface{})
	receive(timeout float64) []byte
	execute(jsonQuery interface{}) UpdateMsg
	destroyInstance()
}

// Implementation wrappers over tdlib client in C language
type tdlibClientImpl struct {
	client unsafe.Pointer
}

// newTDLibClient Init implementation wrappers over tdlib client in C language
func newTDLibClient() *tdlibClientImpl {
	return &tdlibClientImpl{
		client: C.td_json_client_create(),
	}
}

// destroyInstance Destroys the TDLib client instance.
// After this is called the client instance shouldn't be used anymore.
func (c *tdlibClientImpl) destroyInstance() {
	C.td_json_client_destroy(c.client)
}

// send Sends request to the TDLib client.
// You can provide string or UpdateData.
func (c *tdlibClientImpl) send(jsonQuery interface{}) {
	var query *C.char

	switch jsonQuery.(type) {
	case string:
		query = C.CString(jsonQuery.(string))
	case UpdateData:
		jsonBytes, _ := json.Marshal(jsonQuery.(UpdateData))
		query = C.CString(string(jsonBytes))
	}

	defer C.free(unsafe.Pointer(query))
	C.td_json_client_send(c.client, query)
}

// receive Receives incoming updates and request responses from the TDLib client.
// You can provide string or UpdateData.
func (c *tdlibClientImpl) receive(timeout float64) []byte {
	result := C.td_json_client_receive(c.client, C.double(timeout))

	return []byte(C.GoString(result))
}

// execute Synchronously executes TDLib request.
// Only a few requests can be executed synchronously.
func (c *tdlibClientImpl) execute(jsonQuery interface{}) UpdateMsg {
	var query *C.char

	switch jsonQuery.(type) {
	case string:
		query = C.CString(jsonQuery.(string))
	case UpdateData:
		jsonBytes, _ := json.Marshal(jsonQuery.(UpdateData))
		query = C.CString(string(jsonBytes))
	}

	defer C.free(unsafe.Pointer(query))
	result := C.td_json_client_execute(c.client, query)

	var update UpdateData
	json.Unmarshal([]byte(C.GoString(result)), &update)
	return UpdateMsg{Data: update, Raw: []byte(C.GoString(result))}
}
